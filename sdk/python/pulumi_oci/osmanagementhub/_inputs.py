# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'EventDataArgs',
    'EventDataArgsDict',
    'EventDataAdditionalDetailArgs',
    'EventDataAdditionalDetailArgsDict',
    'EventDataAdditionalDetailVmcoreArgs',
    'EventDataAdditionalDetailVmcoreArgsDict',
    'EventDataContentArgs',
    'EventDataContentArgsDict',
    'EventSystemDetailArgs',
    'EventSystemDetailArgsDict',
    'LifecycleEnvironmentManagedInstanceIdArgs',
    'LifecycleEnvironmentManagedInstanceIdArgsDict',
    'LifecycleEnvironmentStageArgs',
    'LifecycleEnvironmentStageArgsDict',
    'LifecycleEnvironmentStageManagedInstanceIdArgs',
    'LifecycleEnvironmentStageManagedInstanceIdArgsDict',
    'LifecycleEnvironmentStageSoftwareSourceIdArgs',
    'LifecycleEnvironmentStageSoftwareSourceIdArgsDict',
    'LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsArgs',
    'LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsArgsDict',
    'LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs',
    'LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgsDict',
    'LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsArgs',
    'LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsArgsDict',
    'LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs',
    'LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgsDict',
    'LifecycleStagePromoteSoftwareSourceManagementWorkRequestDetailsArgs',
    'LifecycleStagePromoteSoftwareSourceManagementWorkRequestDetailsArgsDict',
    'LifecycleStageRebootManagementWorkRequestDetailsArgs',
    'LifecycleStageRebootManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceAutonomousSettingsArgs',
    'ManagedInstanceAutonomousSettingsArgsDict',
    'ManagedInstanceGroupAttachManagedInstancesManagementWorkRequestDetailsArgs',
    'ManagedInstanceGroupAttachManagedInstancesManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceGroupAttachSoftwareSourcesManagementWorkRequestDetailsArgs',
    'ManagedInstanceGroupAttachSoftwareSourcesManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceGroupAutonomousSettingsArgs',
    'ManagedInstanceGroupAutonomousSettingsArgsDict',
    'ManagedInstanceGroupDetachSoftwareSourcesManagementWorkRequestDetailsArgs',
    'ManagedInstanceGroupDetachSoftwareSourcesManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceGroupInstallPackagesManagementWorkRequestDetailsArgs',
    'ManagedInstanceGroupInstallPackagesManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceGroupInstallWindowsUpdatesManagementWorkRequestDetailsArgs',
    'ManagedInstanceGroupInstallWindowsUpdatesManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceGroupManageModuleStreamsManagementDisableArgs',
    'ManagedInstanceGroupManageModuleStreamsManagementDisableArgsDict',
    'ManagedInstanceGroupManageModuleStreamsManagementEnableArgs',
    'ManagedInstanceGroupManageModuleStreamsManagementEnableArgsDict',
    'ManagedInstanceGroupManageModuleStreamsManagementInstallArgs',
    'ManagedInstanceGroupManageModuleStreamsManagementInstallArgsDict',
    'ManagedInstanceGroupManageModuleStreamsManagementRemoveArgs',
    'ManagedInstanceGroupManageModuleStreamsManagementRemoveArgsDict',
    'ManagedInstanceGroupManageModuleStreamsManagementWorkRequestDetailsArgs',
    'ManagedInstanceGroupManageModuleStreamsManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceGroupRebootManagementWorkRequestDetailsArgs',
    'ManagedInstanceGroupRebootManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceGroupRemovePackagesManagementWorkRequestDetailsArgs',
    'ManagedInstanceGroupRemovePackagesManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceGroupSoftwareSourceArgs',
    'ManagedInstanceGroupSoftwareSourceArgsDict',
    'ManagedInstanceGroupUpdateAllPackagesManagementWorkRequestDetailsArgs',
    'ManagedInstanceGroupUpdateAllPackagesManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceInstallWindowsUpdatesManagementWorkRequestDetailsArgs',
    'ManagedInstanceInstallWindowsUpdatesManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceLifecycleEnvironmentArgs',
    'ManagedInstanceLifecycleEnvironmentArgsDict',
    'ManagedInstanceLifecycleStageArgs',
    'ManagedInstanceLifecycleStageArgsDict',
    'ManagedInstanceManagedInstanceGroupArgs',
    'ManagedInstanceManagedInstanceGroupArgsDict',
    'ManagedInstanceRebootManagementWorkRequestDetailsArgs',
    'ManagedInstanceRebootManagementWorkRequestDetailsArgsDict',
    'ManagedInstanceSoftwareSourceArgs',
    'ManagedInstanceSoftwareSourceArgsDict',
    'ManagedInstanceUpdatePackagesManagementWorkRequestDetailsArgs',
    'ManagedInstanceUpdatePackagesManagementWorkRequestDetailsArgsDict',
    'ManagementStationAssociateManagedInstancesManagementWorkRequestDetailsArgs',
    'ManagementStationAssociateManagedInstancesManagementWorkRequestDetailsArgsDict',
    'ManagementStationHealthArgs',
    'ManagementStationHealthArgsDict',
    'ManagementStationMirrorArgs',
    'ManagementStationMirrorArgsDict',
    'ManagementStationMirrorSyncStatusArgs',
    'ManagementStationMirrorSyncStatusArgsDict',
    'ManagementStationPeerManagementStationArgs',
    'ManagementStationPeerManagementStationArgsDict',
    'ManagementStationProxyArgs',
    'ManagementStationProxyArgsDict',
    'ProfileLifecycleEnvironmentArgs',
    'ProfileLifecycleEnvironmentArgsDict',
    'ProfileLifecycleStageArgs',
    'ProfileLifecycleStageArgsDict',
    'ProfileManagedInstanceGroupArgs',
    'ProfileManagedInstanceGroupArgsDict',
    'ProfileSoftwareSourceArgs',
    'ProfileSoftwareSourceArgsDict',
    'ScheduledJobOperationArgs',
    'ScheduledJobOperationArgsDict',
    'ScheduledJobOperationManageModuleStreamsDetailsArgs',
    'ScheduledJobOperationManageModuleStreamsDetailsArgsDict',
    'ScheduledJobOperationManageModuleStreamsDetailsDisableArgs',
    'ScheduledJobOperationManageModuleStreamsDetailsDisableArgsDict',
    'ScheduledJobOperationManageModuleStreamsDetailsEnableArgs',
    'ScheduledJobOperationManageModuleStreamsDetailsEnableArgsDict',
    'ScheduledJobOperationManageModuleStreamsDetailsInstallArgs',
    'ScheduledJobOperationManageModuleStreamsDetailsInstallArgsDict',
    'ScheduledJobOperationManageModuleStreamsDetailsRemoveArgs',
    'ScheduledJobOperationManageModuleStreamsDetailsRemoveArgsDict',
    'ScheduledJobOperationSwitchModuleStreamsDetailsArgs',
    'ScheduledJobOperationSwitchModuleStreamsDetailsArgsDict',
    'SoftwareSourceChangeAvailabilityManagementSoftwareSourceAvailabilityArgs',
    'SoftwareSourceChangeAvailabilityManagementSoftwareSourceAvailabilityArgsDict',
    'SoftwareSourceCustomSoftwareSourceFilterArgs',
    'SoftwareSourceCustomSoftwareSourceFilterArgsDict',
    'SoftwareSourceCustomSoftwareSourceFilterModuleStreamProfileFilterArgs',
    'SoftwareSourceCustomSoftwareSourceFilterModuleStreamProfileFilterArgsDict',
    'SoftwareSourceCustomSoftwareSourceFilterPackageFilterArgs',
    'SoftwareSourceCustomSoftwareSourceFilterPackageFilterArgsDict',
    'SoftwareSourceCustomSoftwareSourceFilterPackageGroupFilterArgs',
    'SoftwareSourceCustomSoftwareSourceFilterPackageGroupFilterArgsDict',
    'SoftwareSourceVendorSoftwareSourceArgs',
    'SoftwareSourceVendorSoftwareSourceArgsDict',
    'WorkRequestRerunManagementWorkRequestDetailsArgs',
    'WorkRequestRerunManagementWorkRequestDetailsArgsDict',
    'GetEntitlementsFilterArgs',
    'GetEntitlementsFilterArgsDict',
    'GetErrataFilterArgs',
    'GetErrataFilterArgsDict',
    'GetEventsFilterArgs',
    'GetEventsFilterArgsDict',
    'GetLifecycleEnvironmentsFilterArgs',
    'GetLifecycleEnvironmentsFilterArgsDict',
    'GetLifecycleStagesFilterArgs',
    'GetLifecycleStagesFilterArgsDict',
    'GetManagedInstanceAvailablePackagesFilterArgs',
    'GetManagedInstanceAvailablePackagesFilterArgsDict',
    'GetManagedInstanceAvailableSoftwareSourcesFilterArgs',
    'GetManagedInstanceAvailableSoftwareSourcesFilterArgsDict',
    'GetManagedInstanceAvailableWindowsUpdatesFilterArgs',
    'GetManagedInstanceAvailableWindowsUpdatesFilterArgsDict',
    'GetManagedInstanceErrataFilterArgs',
    'GetManagedInstanceErrataFilterArgsDict',
    'GetManagedInstanceGroupAvailableModulesFilterArgs',
    'GetManagedInstanceGroupAvailableModulesFilterArgsDict',
    'GetManagedInstanceGroupAvailablePackagesFilterArgs',
    'GetManagedInstanceGroupAvailablePackagesFilterArgsDict',
    'GetManagedInstanceGroupAvailableSoftwareSourcesFilterArgs',
    'GetManagedInstanceGroupAvailableSoftwareSourcesFilterArgsDict',
    'GetManagedInstanceGroupInstalledPackagesFilterArgs',
    'GetManagedInstanceGroupInstalledPackagesFilterArgsDict',
    'GetManagedInstanceGroupModulesFilterArgs',
    'GetManagedInstanceGroupModulesFilterArgsDict',
    'GetManagedInstanceGroupsFilterArgs',
    'GetManagedInstanceGroupsFilterArgsDict',
    'GetManagedInstanceInstalledPackagesFilterArgs',
    'GetManagedInstanceInstalledPackagesFilterArgsDict',
    'GetManagedInstanceInstalledWindowsUpdatesFilterArgs',
    'GetManagedInstanceInstalledWindowsUpdatesFilterArgsDict',
    'GetManagedInstanceModulesFilterArgs',
    'GetManagedInstanceModulesFilterArgsDict',
    'GetManagedInstanceUpdatablePackagesFilterArgs',
    'GetManagedInstanceUpdatablePackagesFilterArgsDict',
    'GetManagedInstancesFilterArgs',
    'GetManagedInstancesFilterArgsDict',
    'GetManagementStationMirrorsFilterArgs',
    'GetManagementStationMirrorsFilterArgsDict',
    'GetManagementStationsFilterArgs',
    'GetManagementStationsFilterArgsDict',
    'GetProfileAvailableSoftwareSourcesFilterArgs',
    'GetProfileAvailableSoftwareSourcesFilterArgsDict',
    'GetProfilesFilterArgs',
    'GetProfilesFilterArgsDict',
    'GetScheduledJobsFilterArgs',
    'GetScheduledJobsFilterArgsDict',
    'GetSoftwarePackageSoftwareSourceFilterArgs',
    'GetSoftwarePackageSoftwareSourceFilterArgsDict',
    'GetSoftwarePackagesFilterArgs',
    'GetSoftwarePackagesFilterArgsDict',
    'GetSoftwareSourceAvailableSoftwarePackagesFilterArgs',
    'GetSoftwareSourceAvailableSoftwarePackagesFilterArgsDict',
    'GetSoftwareSourceModuleStreamProfilesFilterArgs',
    'GetSoftwareSourceModuleStreamProfilesFilterArgsDict',
    'GetSoftwareSourceModuleStreamsFilterArgs',
    'GetSoftwareSourceModuleStreamsFilterArgsDict',
    'GetSoftwareSourcePackageGroupsFilterArgs',
    'GetSoftwareSourcePackageGroupsFilterArgsDict',
    'GetSoftwareSourceSoftwarePackagesFilterArgs',
    'GetSoftwareSourceSoftwarePackagesFilterArgsDict',
    'GetSoftwareSourceVendorsFilterArgs',
    'GetSoftwareSourceVendorsFilterArgsDict',
    'GetSoftwareSourcesFilterArgs',
    'GetSoftwareSourcesFilterArgsDict',
    'GetWindowsUpdatesFilterArgs',
    'GetWindowsUpdatesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class EventDataArgsDict(TypedDict):
        additional_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventDataAdditionalDetailArgsDict']]]]
        """
        Provides additional information for the work request associated with an event.
        """
        attempted_resolutions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The actions used to attempt fixing the error.
        """
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventDataContentArgsDict']]]]
        """
        Provides information collected for the exploit attempt event.
        """
        error_cause: NotRequired[pulumi.Input[_builtins.str]]
        """
        The commands executed by the agent that caused the error.
        """
        error_log: NotRequired[pulumi.Input[_builtins.str]]
        """
        The output log of the error.
        """
        event_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of times the event has occurred.
        """
        event_fingerprint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fingerprint of the event.
        """
        health_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Health state of the management station
        """
        operation_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of management station operation.
        """
        reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reason for the event.
        """
        reboot_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reboot status for the current event
        """
        resolution_log: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log output after the resolutions.
        """
        resolution_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates if the event succeeded.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the management station operation.
        """
        time_first_occurred: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time that the event first occurred.
        """
elif False:
    EventDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventDataArgs:
    def __init__(__self__, *,
                 additional_details: Optional[pulumi.Input[Sequence[pulumi.Input['EventDataAdditionalDetailArgs']]]] = None,
                 attempted_resolutions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['EventDataContentArgs']]]] = None,
                 error_cause: Optional[pulumi.Input[_builtins.str]] = None,
                 error_log: Optional[pulumi.Input[_builtins.str]] = None,
                 event_count: Optional[pulumi.Input[_builtins.int]] = None,
                 event_fingerprint: Optional[pulumi.Input[_builtins.str]] = None,
                 health_state: Optional[pulumi.Input[_builtins.str]] = None,
                 operation_type: Optional[pulumi.Input[_builtins.str]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None,
                 reboot_status: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution_log: Optional[pulumi.Input[_builtins.str]] = None,
                 resolution_status: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_first_occurred: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventDataAdditionalDetailArgs']]] additional_details: Provides additional information for the work request associated with an event.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attempted_resolutions: The actions used to attempt fixing the error.
        :param pulumi.Input[Sequence[pulumi.Input['EventDataContentArgs']]] contents: Provides information collected for the exploit attempt event.
        :param pulumi.Input[_builtins.str] error_cause: The commands executed by the agent that caused the error.
        :param pulumi.Input[_builtins.str] error_log: The output log of the error.
        :param pulumi.Input[_builtins.int] event_count: Number of times the event has occurred.
        :param pulumi.Input[_builtins.str] event_fingerprint: Fingerprint of the event.
        :param pulumi.Input[_builtins.str] health_state: Health state of the management station
        :param pulumi.Input[_builtins.str] operation_type: Type of management station operation.
        :param pulumi.Input[_builtins.str] reason: Reason for the event.
        :param pulumi.Input[_builtins.str] reboot_status: Reboot status for the current event
        :param pulumi.Input[_builtins.str] resolution_log: The log output after the resolutions.
        :param pulumi.Input[_builtins.str] resolution_status: Indicates if the event succeeded.
        :param pulumi.Input[_builtins.str] status: Status of the management station operation.
        :param pulumi.Input[_builtins.str] time_first_occurred: The date and time that the event first occurred.
        """
        if additional_details is not None:
            pulumi.set(__self__, "additional_details", additional_details)
        if attempted_resolutions is not None:
            pulumi.set(__self__, "attempted_resolutions", attempted_resolutions)
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if error_cause is not None:
            pulumi.set(__self__, "error_cause", error_cause)
        if error_log is not None:
            pulumi.set(__self__, "error_log", error_log)
        if event_count is not None:
            pulumi.set(__self__, "event_count", event_count)
        if event_fingerprint is not None:
            pulumi.set(__self__, "event_fingerprint", event_fingerprint)
        if health_state is not None:
            pulumi.set(__self__, "health_state", health_state)
        if operation_type is not None:
            pulumi.set(__self__, "operation_type", operation_type)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if reboot_status is not None:
            pulumi.set(__self__, "reboot_status", reboot_status)
        if resolution_log is not None:
            pulumi.set(__self__, "resolution_log", resolution_log)
        if resolution_status is not None:
            pulumi.set(__self__, "resolution_status", resolution_status)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_first_occurred is not None:
            pulumi.set(__self__, "time_first_occurred", time_first_occurred)

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventDataAdditionalDetailArgs']]]]:
        """
        Provides additional information for the work request associated with an event.
        """
        return pulumi.get(self, "additional_details")

    @additional_details.setter
    def additional_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventDataAdditionalDetailArgs']]]]):
        pulumi.set(self, "additional_details", value)

    @_builtins.property
    @pulumi.getter(name="attemptedResolutions")
    def attempted_resolutions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The actions used to attempt fixing the error.
        """
        return pulumi.get(self, "attempted_resolutions")

    @attempted_resolutions.setter
    def attempted_resolutions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attempted_resolutions", value)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventDataContentArgs']]]]:
        """
        Provides information collected for the exploit attempt event.
        """
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventDataContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @_builtins.property
    @pulumi.getter(name="errorCause")
    def error_cause(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The commands executed by the agent that caused the error.
        """
        return pulumi.get(self, "error_cause")

    @error_cause.setter
    def error_cause(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_cause", value)

    @_builtins.property
    @pulumi.getter(name="errorLog")
    def error_log(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The output log of the error.
        """
        return pulumi.get(self, "error_log")

    @error_log.setter
    def error_log(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_log", value)

    @_builtins.property
    @pulumi.getter(name="eventCount")
    def event_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of times the event has occurred.
        """
        return pulumi.get(self, "event_count")

    @event_count.setter
    def event_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "event_count", value)

    @_builtins.property
    @pulumi.getter(name="eventFingerprint")
    def event_fingerprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fingerprint of the event.
        """
        return pulumi.get(self, "event_fingerprint")

    @event_fingerprint.setter
    def event_fingerprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="healthState")
    def health_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Health state of the management station
        """
        return pulumi.get(self, "health_state")

    @health_state.setter
    def health_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "health_state", value)

    @_builtins.property
    @pulumi.getter(name="operationType")
    def operation_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of management station operation.
        """
        return pulumi.get(self, "operation_type")

    @operation_type.setter
    def operation_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation_type", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reason for the event.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)

    @_builtins.property
    @pulumi.getter(name="rebootStatus")
    def reboot_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reboot status for the current event
        """
        return pulumi.get(self, "reboot_status")

    @reboot_status.setter
    def reboot_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reboot_status", value)

    @_builtins.property
    @pulumi.getter(name="resolutionLog")
    def resolution_log(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log output after the resolutions.
        """
        return pulumi.get(self, "resolution_log")

    @resolution_log.setter
    def resolution_log(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution_log", value)

    @_builtins.property
    @pulumi.getter(name="resolutionStatus")
    def resolution_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates if the event succeeded.
        """
        return pulumi.get(self, "resolution_status")

    @resolution_status.setter
    def resolution_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolution_status", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the management station operation.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeFirstOccurred")
    def time_first_occurred(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time that the event first occurred.
        """
        return pulumi.get(self, "time_first_occurred")

    @time_first_occurred.setter
    def time_first_occurred(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_first_occurred", value)


if not MYPY:
    class EventDataAdditionalDetailArgsDict(TypedDict):
        exploit_cves: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of CVEs in the exploit.
        """
        initiator_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that triggered the event, such as scheduled job id.
        """
        vmcores: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventDataAdditionalDetailVmcoreArgsDict']]]]
        """
        Kernel event vmcore details
        """
        work_request_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of all work request [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) associated with the event.
        """
elif False:
    EventDataAdditionalDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventDataAdditionalDetailArgs:
    def __init__(__self__, *,
                 exploit_cves: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 initiator_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vmcores: Optional[pulumi.Input[Sequence[pulumi.Input['EventDataAdditionalDetailVmcoreArgs']]]] = None,
                 work_request_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exploit_cves: List of CVEs in the exploit.
        :param pulumi.Input[_builtins.str] initiator_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that triggered the event, such as scheduled job id.
        :param pulumi.Input[Sequence[pulumi.Input['EventDataAdditionalDetailVmcoreArgs']]] vmcores: Kernel event vmcore details
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] work_request_ids: List of all work request [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) associated with the event.
        """
        if exploit_cves is not None:
            pulumi.set(__self__, "exploit_cves", exploit_cves)
        if initiator_id is not None:
            pulumi.set(__self__, "initiator_id", initiator_id)
        if vmcores is not None:
            pulumi.set(__self__, "vmcores", vmcores)
        if work_request_ids is not None:
            pulumi.set(__self__, "work_request_ids", work_request_ids)

    @_builtins.property
    @pulumi.getter(name="exploitCves")
    def exploit_cves(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of CVEs in the exploit.
        """
        return pulumi.get(self, "exploit_cves")

    @exploit_cves.setter
    def exploit_cves(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exploit_cves", value)

    @_builtins.property
    @pulumi.getter(name="initiatorId")
    def initiator_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that triggered the event, such as scheduled job id.
        """
        return pulumi.get(self, "initiator_id")

    @initiator_id.setter
    def initiator_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "initiator_id", value)

    @_builtins.property
    @pulumi.getter
    def vmcores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventDataAdditionalDetailVmcoreArgs']]]]:
        """
        Kernel event vmcore details
        """
        return pulumi.get(self, "vmcores")

    @vmcores.setter
    def vmcores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventDataAdditionalDetailVmcoreArgs']]]]):
        pulumi.set(self, "vmcores", value)

    @_builtins.property
    @pulumi.getter(name="workRequestIds")
    def work_request_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of all work request [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) associated with the event.
        """
        return pulumi.get(self, "work_request_ids")

    @work_request_ids.setter
    def work_request_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "work_request_ids", value)


if not MYPY:
    class EventDataAdditionalDetailVmcoreArgsDict(TypedDict):
        backtrace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kernel vmcore backtrace.
        """
        component: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kernel vmcore component.
        """
elif False:
    EventDataAdditionalDetailVmcoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventDataAdditionalDetailVmcoreArgs:
    def __init__(__self__, *,
                 backtrace: Optional[pulumi.Input[_builtins.str]] = None,
                 component: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] backtrace: Kernel vmcore backtrace.
        :param pulumi.Input[_builtins.str] component: Kernel vmcore component.
        """
        if backtrace is not None:
            pulumi.set(__self__, "backtrace", backtrace)
        if component is not None:
            pulumi.set(__self__, "component", component)

    @_builtins.property
    @pulumi.getter
    def backtrace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kernel vmcore backtrace.
        """
        return pulumi.get(self, "backtrace")

    @backtrace.setter
    def backtrace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backtrace", value)

    @_builtins.property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kernel vmcore component.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "component", value)


if not MYPY:
    class EventDataContentArgsDict(TypedDict):
        content_availability: NotRequired[pulumi.Input[_builtins.str]]
        """
        Crash content availability status:
        * 'NOT_AVAILABLE' indicates the content is not available on the instance nor in the service
        * 'AVAILABLE_ON_INSTANCE' indicates the content is only available on the instance.
        * 'AVAILABLE_ON_SERVICE' indicates the content is only available on the service.
        * 'AVAILABLE_ON_INSTANCE_AND_SERVICE' indicates the content is available both on the instance and the service
        * 'AVAILABLE_ON_INSTANCE_UPLOAD_IN_PROGRESS' indicates the content is available on the instance and its upload to the service is in progress.
        """
        content_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Location of the Kernel event content.
        """
        exploit_detection_log_content: NotRequired[pulumi.Input[_builtins.str]]
        """
        The content of the exploit detection log.
        """
        exploit_object_store_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The location of the exploit detection log within object storage.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Size of the event content.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Event type:
        * `KERNEL_OOPS` - Used to identify a kernel panic condition event
        * `KERNEL_CRASH` - Used to identify an internal fatal kernel error that cannot be safely recovered from
        * `EXPLOIT_ATTEMPT` - Used to identify a known exploit detection as identified by Ksplice
        * `SOFTWARE_UPDATE` - Software updates - Packages
        * `KSPLICE_UPDATE` - Ksplice updates
        * `SOFTWARE_SOURCE` - Software source
        * `AGENT` - Agent
        * `MANAGEMENT_STATION` - Management Station
        * `SYSADMIN` - Used to identify attempts on fixing agent errors on the instance
        * `REBOOT` - Reboot
        """
elif False:
    EventDataContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventDataContentArgs:
    def __init__(__self__, *,
                 content_availability: Optional[pulumi.Input[_builtins.str]] = None,
                 content_location: Optional[pulumi.Input[_builtins.str]] = None,
                 exploit_detection_log_content: Optional[pulumi.Input[_builtins.str]] = None,
                 exploit_object_store_location: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content_availability: Crash content availability status:
               * 'NOT_AVAILABLE' indicates the content is not available on the instance nor in the service
               * 'AVAILABLE_ON_INSTANCE' indicates the content is only available on the instance.
               * 'AVAILABLE_ON_SERVICE' indicates the content is only available on the service.
               * 'AVAILABLE_ON_INSTANCE_AND_SERVICE' indicates the content is available both on the instance and the service
               * 'AVAILABLE_ON_INSTANCE_UPLOAD_IN_PROGRESS' indicates the content is available on the instance and its upload to the service is in progress.
        :param pulumi.Input[_builtins.str] content_location: Location of the Kernel event content.
        :param pulumi.Input[_builtins.str] exploit_detection_log_content: The content of the exploit detection log.
        :param pulumi.Input[_builtins.str] exploit_object_store_location: The location of the exploit detection log within object storage.
        :param pulumi.Input[_builtins.int] size: Size of the event content.
        :param pulumi.Input[_builtins.str] type: Event type:
               * `KERNEL_OOPS` - Used to identify a kernel panic condition event
               * `KERNEL_CRASH` - Used to identify an internal fatal kernel error that cannot be safely recovered from
               * `EXPLOIT_ATTEMPT` - Used to identify a known exploit detection as identified by Ksplice
               * `SOFTWARE_UPDATE` - Software updates - Packages
               * `KSPLICE_UPDATE` - Ksplice updates
               * `SOFTWARE_SOURCE` - Software source
               * `AGENT` - Agent
               * `MANAGEMENT_STATION` - Management Station
               * `SYSADMIN` - Used to identify attempts on fixing agent errors on the instance
               * `REBOOT` - Reboot
        """
        if content_availability is not None:
            pulumi.set(__self__, "content_availability", content_availability)
        if content_location is not None:
            pulumi.set(__self__, "content_location", content_location)
        if exploit_detection_log_content is not None:
            pulumi.set(__self__, "exploit_detection_log_content", exploit_detection_log_content)
        if exploit_object_store_location is not None:
            pulumi.set(__self__, "exploit_object_store_location", exploit_object_store_location)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="contentAvailability")
    def content_availability(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Crash content availability status:
        * 'NOT_AVAILABLE' indicates the content is not available on the instance nor in the service
        * 'AVAILABLE_ON_INSTANCE' indicates the content is only available on the instance.
        * 'AVAILABLE_ON_SERVICE' indicates the content is only available on the service.
        * 'AVAILABLE_ON_INSTANCE_AND_SERVICE' indicates the content is available both on the instance and the service
        * 'AVAILABLE_ON_INSTANCE_UPLOAD_IN_PROGRESS' indicates the content is available on the instance and its upload to the service is in progress.
        """
        return pulumi.get(self, "content_availability")

    @content_availability.setter
    def content_availability(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_availability", value)

    @_builtins.property
    @pulumi.getter(name="contentLocation")
    def content_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Location of the Kernel event content.
        """
        return pulumi.get(self, "content_location")

    @content_location.setter
    def content_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_location", value)

    @_builtins.property
    @pulumi.getter(name="exploitDetectionLogContent")
    def exploit_detection_log_content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The content of the exploit detection log.
        """
        return pulumi.get(self, "exploit_detection_log_content")

    @exploit_detection_log_content.setter
    def exploit_detection_log_content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exploit_detection_log_content", value)

    @_builtins.property
    @pulumi.getter(name="exploitObjectStoreLocation")
    def exploit_object_store_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The location of the exploit detection log within object storage.
        """
        return pulumi.get(self, "exploit_object_store_location")

    @exploit_object_store_location.setter
    def exploit_object_store_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exploit_object_store_location", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Size of the event content.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Event type:
        * `KERNEL_OOPS` - Used to identify a kernel panic condition event
        * `KERNEL_CRASH` - Used to identify an internal fatal kernel error that cannot be safely recovered from
        * `EXPLOIT_ATTEMPT` - Used to identify a known exploit detection as identified by Ksplice
        * `SOFTWARE_UPDATE` - Software updates - Packages
        * `KSPLICE_UPDATE` - Ksplice updates
        * `SOFTWARE_SOURCE` - Software source
        * `AGENT` - Agent
        * `MANAGEMENT_STATION` - Management Station
        * `SYSADMIN` - Used to identify attempts on fixing agent errors on the instance
        * `REBOOT` - Reboot
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EventSystemDetailArgsDict(TypedDict):
        architecture: NotRequired[pulumi.Input[_builtins.str]]
        """
        Architecture type.
        """
        ksplice_effective_kernel_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of the Ksplice effective kernel.
        """
        os_family: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operating system type.
        """
        os_kernel_release: NotRequired[pulumi.Input[_builtins.str]]
        """
        Release of the kernel.
        """
        os_kernel_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of the kernel.
        """
        os_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the operating system.
        """
        os_system_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of the operating system.
        """
elif False:
    EventSystemDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSystemDetailArgs:
    def __init__(__self__, *,
                 architecture: Optional[pulumi.Input[_builtins.str]] = None,
                 ksplice_effective_kernel_version: Optional[pulumi.Input[_builtins.str]] = None,
                 os_family: Optional[pulumi.Input[_builtins.str]] = None,
                 os_kernel_release: Optional[pulumi.Input[_builtins.str]] = None,
                 os_kernel_version: Optional[pulumi.Input[_builtins.str]] = None,
                 os_name: Optional[pulumi.Input[_builtins.str]] = None,
                 os_system_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] architecture: Architecture type.
        :param pulumi.Input[_builtins.str] ksplice_effective_kernel_version: Version of the Ksplice effective kernel.
        :param pulumi.Input[_builtins.str] os_family: Operating system type.
        :param pulumi.Input[_builtins.str] os_kernel_release: Release of the kernel.
        :param pulumi.Input[_builtins.str] os_kernel_version: Version of the kernel.
        :param pulumi.Input[_builtins.str] os_name: Name of the operating system.
        :param pulumi.Input[_builtins.str] os_system_version: Version of the operating system.
        """
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if ksplice_effective_kernel_version is not None:
            pulumi.set(__self__, "ksplice_effective_kernel_version", ksplice_effective_kernel_version)
        if os_family is not None:
            pulumi.set(__self__, "os_family", os_family)
        if os_kernel_release is not None:
            pulumi.set(__self__, "os_kernel_release", os_kernel_release)
        if os_kernel_version is not None:
            pulumi.set(__self__, "os_kernel_version", os_kernel_version)
        if os_name is not None:
            pulumi.set(__self__, "os_name", os_name)
        if os_system_version is not None:
            pulumi.set(__self__, "os_system_version", os_system_version)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Architecture type.
        """
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "architecture", value)

    @_builtins.property
    @pulumi.getter(name="kspliceEffectiveKernelVersion")
    def ksplice_effective_kernel_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of the Ksplice effective kernel.
        """
        return pulumi.get(self, "ksplice_effective_kernel_version")

    @ksplice_effective_kernel_version.setter
    def ksplice_effective_kernel_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ksplice_effective_kernel_version", value)

    @_builtins.property
    @pulumi.getter(name="osFamily")
    def os_family(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operating system type.
        """
        return pulumi.get(self, "os_family")

    @os_family.setter
    def os_family(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_family", value)

    @_builtins.property
    @pulumi.getter(name="osKernelRelease")
    def os_kernel_release(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Release of the kernel.
        """
        return pulumi.get(self, "os_kernel_release")

    @os_kernel_release.setter
    def os_kernel_release(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_kernel_release", value)

    @_builtins.property
    @pulumi.getter(name="osKernelVersion")
    def os_kernel_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of the kernel.
        """
        return pulumi.get(self, "os_kernel_version")

    @os_kernel_version.setter
    def os_kernel_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_kernel_version", value)

    @_builtins.property
    @pulumi.getter(name="osName")
    def os_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the operating system.
        """
        return pulumi.get(self, "os_name")

    @os_name.setter
    def os_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_name", value)

    @_builtins.property
    @pulumi.getter(name="osSystemVersion")
    def os_system_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of the operating system.
        """
        return pulumi.get(self, "os_system_version")

    @os_system_version.setter
    def os_system_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_system_version", value)


if not MYPY:
    class LifecycleEnvironmentManagedInstanceIdArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name for the lifecycle environment. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
elif False:
    LifecycleEnvironmentManagedInstanceIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecycleEnvironmentManagedInstanceIdArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name for the lifecycle environment. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name for the lifecycle environment. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LifecycleEnvironmentStageArgsDict(TypedDict):
        display_name: pulumi.Input[_builtins.str]
        """
        (Updatable) A user-friendly name for the lifecycle stage. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        rank: pulumi.Input[_builtins.int]
        """
        User-specified rank for the lifecycle stage. Rank determines the hierarchy of the lifecycle stages within the lifecycle environment.
        """
        arch_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CPU architecture of the managed instances in the lifecycle environment.
        """
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment that contains the lifecycle stage.
        """
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        lifecycle_environment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the lifecycle environment that contains the lifecycle stage.
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The location of managed instances attached to the lifecycle environment. If no location is provided, the default is 'ON_PREMISE.'
        """
        managed_instance_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input['LifecycleEnvironmentStageManagedInstanceIdArgsDict']]]]
        """
        The list of managed instances associated with the lifecycle stage.
        """
        os_family: NotRequired[pulumi.Input[_builtins.str]]
        """
        The operating system of the managed instances in the lifecycle environment.
        """
        software_source_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input['LifecycleEnvironmentStageSoftwareSourceIdArgsDict']]]]
        """
        Provides identifying information for the specified software source.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current state of the lifecycle environment.
        """
        system_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time the lifecycle environment was created (in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) format).
        """
        time_modified: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time the lifecycle environment was last modified (in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) format).
        """
        vendor_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The vendor of the operating system used by the managed instances in the lifecycle environment.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    LifecycleEnvironmentStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecycleEnvironmentStageArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[_builtins.str],
                 rank: pulumi.Input[_builtins.int],
                 arch_type: Optional[pulumi.Input[_builtins.str]] = None,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 lifecycle_environment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 managed_instance_ids: Optional[pulumi.Input[Sequence[pulumi.Input['LifecycleEnvironmentStageManagedInstanceIdArgs']]]] = None,
                 os_family: Optional[pulumi.Input[_builtins.str]] = None,
                 software_source_ids: Optional[pulumi.Input[Sequence[pulumi.Input['LifecycleEnvironmentStageSoftwareSourceIdArgs']]]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 system_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 time_modified: Optional[pulumi.Input[_builtins.str]] = None,
                 vendor_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name for the lifecycle stage. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        :param pulumi.Input[_builtins.int] rank: User-specified rank for the lifecycle stage. Rank determines the hierarchy of the lifecycle stages within the lifecycle environment.
        :param pulumi.Input[_builtins.str] arch_type: The CPU architecture of the managed instances in the lifecycle environment.
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment that contains the lifecycle stage.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        :param pulumi.Input[_builtins.str] lifecycle_environment_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the lifecycle environment that contains the lifecycle stage.
        :param pulumi.Input[_builtins.str] location: The location of managed instances attached to the lifecycle environment. If no location is provided, the default is 'ON_PREMISE.'
        :param pulumi.Input[Sequence[pulumi.Input['LifecycleEnvironmentStageManagedInstanceIdArgs']]] managed_instance_ids: The list of managed instances associated with the lifecycle stage.
        :param pulumi.Input[_builtins.str] os_family: The operating system of the managed instances in the lifecycle environment.
        :param pulumi.Input[Sequence[pulumi.Input['LifecycleEnvironmentStageSoftwareSourceIdArgs']]] software_source_ids: Provides identifying information for the specified software source.
        :param pulumi.Input[_builtins.str] state: The current state of the lifecycle environment.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param pulumi.Input[_builtins.str] time_created: The time the lifecycle environment was created (in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) format).
        :param pulumi.Input[_builtins.str] time_modified: The time the lifecycle environment was last modified (in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) format).
        :param pulumi.Input[_builtins.str] vendor_name: The vendor of the operating system used by the managed instances in the lifecycle environment.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "rank", rank)
        if arch_type is not None:
            pulumi.set(__self__, "arch_type", arch_type)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if lifecycle_environment_id is not None:
            pulumi.set(__self__, "lifecycle_environment_id", lifecycle_environment_id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if managed_instance_ids is not None:
            pulumi.set(__self__, "managed_instance_ids", managed_instance_ids)
        if os_family is not None:
            pulumi.set(__self__, "os_family", os_family)
        if software_source_ids is not None:
            pulumi.set(__self__, "software_source_ids", software_source_ids)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if system_tags is not None:
            pulumi.set(__self__, "system_tags", system_tags)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_modified is not None:
            pulumi.set(__self__, "time_modified", time_modified)
        if vendor_name is not None:
            pulumi.set(__self__, "vendor_name", vendor_name)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) A user-friendly name for the lifecycle stage. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def rank(self) -> pulumi.Input[_builtins.int]:
        """
        User-specified rank for the lifecycle stage. Rank determines the hierarchy of the lifecycle stages within the lifecycle environment.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rank", value)

    @_builtins.property
    @pulumi.getter(name="archType")
    def arch_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CPU architecture of the managed instances in the lifecycle environment.
        """
        return pulumi.get(self, "arch_type")

    @arch_type.setter
    def arch_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "arch_type", value)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment that contains the lifecycle stage.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "defined_tags", value)

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="lifecycleEnvironmentId")
    def lifecycle_environment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the lifecycle environment that contains the lifecycle stage.
        """
        return pulumi.get(self, "lifecycle_environment_id")

    @lifecycle_environment_id.setter
    def lifecycle_environment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lifecycle_environment_id", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The location of managed instances attached to the lifecycle environment. If no location is provided, the default is 'ON_PREMISE.'
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="managedInstanceIds")
    def managed_instance_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LifecycleEnvironmentStageManagedInstanceIdArgs']]]]:
        """
        The list of managed instances associated with the lifecycle stage.
        """
        return pulumi.get(self, "managed_instance_ids")

    @managed_instance_ids.setter
    def managed_instance_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LifecycleEnvironmentStageManagedInstanceIdArgs']]]]):
        pulumi.set(self, "managed_instance_ids", value)

    @_builtins.property
    @pulumi.getter(name="osFamily")
    def os_family(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operating system of the managed instances in the lifecycle environment.
        """
        return pulumi.get(self, "os_family")

    @os_family.setter
    def os_family(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_family", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceIds")
    def software_source_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LifecycleEnvironmentStageSoftwareSourceIdArgs']]]]:
        """
        Provides identifying information for the specified software source.
        """
        return pulumi.get(self, "software_source_ids")

    @software_source_ids.setter
    def software_source_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LifecycleEnvironmentStageSoftwareSourceIdArgs']]]]):
        pulumi.set(self, "software_source_ids", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current state of the lifecycle environment.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @system_tags.setter
    def system_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "system_tags", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time the lifecycle environment was created (in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) format).
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter(name="timeModified")
    def time_modified(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time the lifecycle environment was last modified (in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) format).
        """
        return pulumi.get(self, "time_modified")

    @time_modified.setter
    def time_modified(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_modified", value)

    @_builtins.property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The vendor of the operating system used by the managed instances in the lifecycle environment.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vendor_name")

    @vendor_name.setter
    def vendor_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vendor_name", value)


if not MYPY:
    class LifecycleEnvironmentStageManagedInstanceIdArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name for the lifecycle environment. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
elif False:
    LifecycleEnvironmentStageManagedInstanceIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecycleEnvironmentStageManagedInstanceIdArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name for the lifecycle environment. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name for the lifecycle environment. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LifecycleEnvironmentStageSoftwareSourceIdArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) User-specified information about the lifecycle environment. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name for the lifecycle environment. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        is_mandatory_for_autonomous_linux: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        """
        software_source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the software source.
        """
elif False:
    LifecycleEnvironmentStageSoftwareSourceIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecycleEnvironmentStageSoftwareSourceIdArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_mandatory_for_autonomous_linux: Optional[pulumi.Input[_builtins.bool]] = None,
                 software_source_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Updatable) User-specified information about the lifecycle environment. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name for the lifecycle environment. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        :param pulumi.Input[_builtins.bool] is_mandatory_for_autonomous_linux: Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        :param pulumi.Input[_builtins.str] software_source_type: Type of the software source.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_mandatory_for_autonomous_linux is not None:
            pulumi.set(__self__, "is_mandatory_for_autonomous_linux", is_mandatory_for_autonomous_linux)
        if software_source_type is not None:
            pulumi.set(__self__, "software_source_type", software_source_type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) User-specified information about the lifecycle environment. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name for the lifecycle environment. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isMandatoryForAutonomousLinux")
    def is_mandatory_for_autonomous_linux(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        """
        return pulumi.get(self, "is_mandatory_for_autonomous_linux")

    @is_mandatory_for_autonomous_linux.setter
    def is_mandatory_for_autonomous_linux(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_mandatory_for_autonomous_linux", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceType")
    def software_source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the software source.
        """
        return pulumi.get(self, "software_source_type")

    @software_source_type.setter
    def software_source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_type", value)


if not MYPY:
    class LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsArgsDict(TypedDict):
        managed_instances: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of managed instance OCIDs to be attached/detached.
        """
        work_request_details: NotRequired[pulumi.Input['LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgsDict']]
        """
        Provides the name and description of the job.
        """
elif False:
    LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsArgs:
    def __init__(__self__, *,
                 managed_instances: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 work_request_details: Optional[pulumi.Input['LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] managed_instances: The list of managed instance OCIDs to be attached/detached.
        :param pulumi.Input['LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs'] work_request_details: Provides the name and description of the job.
        """
        pulumi.set(__self__, "managed_instances", managed_instances)
        if work_request_details is not None:
            pulumi.set(__self__, "work_request_details", work_request_details)

    @_builtins.property
    @pulumi.getter(name="managedInstances")
    def managed_instances(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of managed instance OCIDs to be attached/detached.
        """
        return pulumi.get(self, "managed_instances")

    @managed_instances.setter
    def managed_instances(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "managed_instances", value)

    @_builtins.property
    @pulumi.getter(name="workRequestDetails")
    def work_request_details(self) -> Optional[pulumi.Input['LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs']]:
        """
        Provides the name and description of the job.
        """
        return pulumi.get(self, "work_request_details")

    @work_request_details.setter
    def work_request_details(self, value: Optional[pulumi.Input['LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs']]):
        pulumi.set(self, "work_request_details", value)


if not MYPY:
    class LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecycleStageAttachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsArgsDict(TypedDict):
        managed_instances: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of managed instance OCIDs to be attached/detached.
        """
        work_request_details: NotRequired[pulumi.Input['LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgsDict']]
        """
        Provides the name and description of the job.
        """
elif False:
    LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsArgs:
    def __init__(__self__, *,
                 managed_instances: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 work_request_details: Optional[pulumi.Input['LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] managed_instances: The list of managed instance OCIDs to be attached/detached.
        :param pulumi.Input['LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs'] work_request_details: Provides the name and description of the job.
        """
        pulumi.set(__self__, "managed_instances", managed_instances)
        if work_request_details is not None:
            pulumi.set(__self__, "work_request_details", work_request_details)

    @_builtins.property
    @pulumi.getter(name="managedInstances")
    def managed_instances(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of managed instance OCIDs to be attached/detached.
        """
        return pulumi.get(self, "managed_instances")

    @managed_instances.setter
    def managed_instances(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "managed_instances", value)

    @_builtins.property
    @pulumi.getter(name="workRequestDetails")
    def work_request_details(self) -> Optional[pulumi.Input['LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs']]:
        """
        Provides the name and description of the job.
        """
        return pulumi.get(self, "work_request_details")

    @work_request_details.setter
    def work_request_details(self, value: Optional[pulumi.Input['LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs']]):
        pulumi.set(self, "work_request_details", value)


if not MYPY:
    class LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecycleStageDetachManagedInstancesManagementManagedInstanceDetailsWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class LifecycleStagePromoteSoftwareSourceManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    LifecycleStagePromoteSoftwareSourceManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecycleStagePromoteSoftwareSourceManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class LifecycleStageRebootManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    LifecycleStageRebootManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecycleStageRebootManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceAutonomousSettingsArgsDict(TypedDict):
        is_data_collection_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Indicates whether Autonomous Linux will collect crash files.
        """
        scheduled_job_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the restricted scheduled job associated with this instance. This value cannot be deleted by the user.
        """
elif False:
    ManagedInstanceAutonomousSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceAutonomousSettingsArgs:
    def __init__(__self__, *,
                 is_data_collection_authorized: Optional[pulumi.Input[_builtins.bool]] = None,
                 scheduled_job_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_data_collection_authorized: (Updatable) Indicates whether Autonomous Linux will collect crash files.
        :param pulumi.Input[_builtins.str] scheduled_job_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the restricted scheduled job associated with this instance. This value cannot be deleted by the user.
        """
        if is_data_collection_authorized is not None:
            pulumi.set(__self__, "is_data_collection_authorized", is_data_collection_authorized)
        if scheduled_job_id is not None:
            pulumi.set(__self__, "scheduled_job_id", scheduled_job_id)

    @_builtins.property
    @pulumi.getter(name="isDataCollectionAuthorized")
    def is_data_collection_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Indicates whether Autonomous Linux will collect crash files.
        """
        return pulumi.get(self, "is_data_collection_authorized")

    @is_data_collection_authorized.setter
    def is_data_collection_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_data_collection_authorized", value)

    @_builtins.property
    @pulumi.getter(name="scheduledJobId")
    def scheduled_job_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the restricted scheduled job associated with this instance. This value cannot be deleted by the user.
        """
        return pulumi.get(self, "scheduled_job_id")

    @scheduled_job_id.setter
    def scheduled_job_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_job_id", value)


if not MYPY:
    class ManagedInstanceGroupAttachManagedInstancesManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceGroupAttachManagedInstancesManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupAttachManagedInstancesManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceGroupAttachSoftwareSourcesManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceGroupAttachSoftwareSourcesManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupAttachSoftwareSourcesManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceGroupAutonomousSettingsArgsDict(TypedDict):
        is_data_collection_authorized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Indicates whether Autonomous Linux will collect crash files.
        """
        scheduled_job_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the restricted scheduled job associated with this instance. This value cannot be deleted by the user.
        """
elif False:
    ManagedInstanceGroupAutonomousSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupAutonomousSettingsArgs:
    def __init__(__self__, *,
                 is_data_collection_authorized: Optional[pulumi.Input[_builtins.bool]] = None,
                 scheduled_job_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_data_collection_authorized: (Updatable) Indicates whether Autonomous Linux will collect crash files.
        :param pulumi.Input[_builtins.str] scheduled_job_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the restricted scheduled job associated with this instance. This value cannot be deleted by the user.
        """
        if is_data_collection_authorized is not None:
            pulumi.set(__self__, "is_data_collection_authorized", is_data_collection_authorized)
        if scheduled_job_id is not None:
            pulumi.set(__self__, "scheduled_job_id", scheduled_job_id)

    @_builtins.property
    @pulumi.getter(name="isDataCollectionAuthorized")
    def is_data_collection_authorized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Indicates whether Autonomous Linux will collect crash files.
        """
        return pulumi.get(self, "is_data_collection_authorized")

    @is_data_collection_authorized.setter
    def is_data_collection_authorized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_data_collection_authorized", value)

    @_builtins.property
    @pulumi.getter(name="scheduledJobId")
    def scheduled_job_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the restricted scheduled job associated with this instance. This value cannot be deleted by the user.
        """
        return pulumi.get(self, "scheduled_job_id")

    @scheduled_job_id.setter
    def scheduled_job_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_job_id", value)


if not MYPY:
    class ManagedInstanceGroupDetachSoftwareSourcesManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceGroupDetachSoftwareSourcesManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupDetachSoftwareSourcesManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceGroupInstallPackagesManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceGroupInstallPackagesManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupInstallPackagesManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceGroupInstallWindowsUpdatesManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceGroupInstallWindowsUpdatesManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupInstallWindowsUpdatesManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceGroupManageModuleStreamsManagementDisableArgsDict(TypedDict):
        module_name: pulumi.Input[_builtins.str]
        """
        The name of a module.
        """
        stream_name: pulumi.Input[_builtins.str]
        """
        The name of a stream of the specified module.
        """
        software_source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
elif False:
    ManagedInstanceGroupManageModuleStreamsManagementDisableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupManageModuleStreamsManagementDisableArgs:
    def __init__(__self__, *,
                 module_name: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 software_source_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] module_name: The name of a module.
        :param pulumi.Input[_builtins.str] stream_name: The name of a stream of the specified module.
        :param pulumi.Input[_builtins.str] software_source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        pulumi.set(__self__, "module_name", module_name)
        pulumi.set(__self__, "stream_name", stream_name)
        if software_source_id is not None:
            pulumi.set(__self__, "software_source_id", software_source_id)

    @_builtins.property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of a module.
        """
        return pulumi.get(self, "module_name")

    @module_name.setter
    def module_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "module_name", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of a stream of the specified module.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceId")
    def software_source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        return pulumi.get(self, "software_source_id")

    @software_source_id.setter
    def software_source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_id", value)


if not MYPY:
    class ManagedInstanceGroupManageModuleStreamsManagementEnableArgsDict(TypedDict):
        module_name: pulumi.Input[_builtins.str]
        """
        The name of a module.
        """
        stream_name: pulumi.Input[_builtins.str]
        """
        The name of a stream of the specified module.
        """
        software_source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
elif False:
    ManagedInstanceGroupManageModuleStreamsManagementEnableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupManageModuleStreamsManagementEnableArgs:
    def __init__(__self__, *,
                 module_name: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 software_source_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] module_name: The name of a module.
        :param pulumi.Input[_builtins.str] stream_name: The name of a stream of the specified module.
        :param pulumi.Input[_builtins.str] software_source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        pulumi.set(__self__, "module_name", module_name)
        pulumi.set(__self__, "stream_name", stream_name)
        if software_source_id is not None:
            pulumi.set(__self__, "software_source_id", software_source_id)

    @_builtins.property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of a module.
        """
        return pulumi.get(self, "module_name")

    @module_name.setter
    def module_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "module_name", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of a stream of the specified module.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceId")
    def software_source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        return pulumi.get(self, "software_source_id")

    @software_source_id.setter
    def software_source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_id", value)


if not MYPY:
    class ManagedInstanceGroupManageModuleStreamsManagementInstallArgsDict(TypedDict):
        module_name: pulumi.Input[_builtins.str]
        """
        The name of a module.
        """
        profile_name: pulumi.Input[_builtins.str]
        """
        The name of a profile of the specified module stream.
        """
        stream_name: pulumi.Input[_builtins.str]
        """
        The name of a stream of the specified module.
        """
        software_source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
elif False:
    ManagedInstanceGroupManageModuleStreamsManagementInstallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupManageModuleStreamsManagementInstallArgs:
    def __init__(__self__, *,
                 module_name: pulumi.Input[_builtins.str],
                 profile_name: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 software_source_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] module_name: The name of a module.
        :param pulumi.Input[_builtins.str] profile_name: The name of a profile of the specified module stream.
        :param pulumi.Input[_builtins.str] stream_name: The name of a stream of the specified module.
        :param pulumi.Input[_builtins.str] software_source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        pulumi.set(__self__, "module_name", module_name)
        pulumi.set(__self__, "profile_name", profile_name)
        pulumi.set(__self__, "stream_name", stream_name)
        if software_source_id is not None:
            pulumi.set(__self__, "software_source_id", software_source_id)

    @_builtins.property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of a module.
        """
        return pulumi.get(self, "module_name")

    @module_name.setter
    def module_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "module_name", value)

    @_builtins.property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of a profile of the specified module stream.
        """
        return pulumi.get(self, "profile_name")

    @profile_name.setter
    def profile_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "profile_name", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of a stream of the specified module.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceId")
    def software_source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        return pulumi.get(self, "software_source_id")

    @software_source_id.setter
    def software_source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_id", value)


if not MYPY:
    class ManagedInstanceGroupManageModuleStreamsManagementRemoveArgsDict(TypedDict):
        module_name: pulumi.Input[_builtins.str]
        """
        The name of a module.
        """
        profile_name: pulumi.Input[_builtins.str]
        """
        The name of a profile of the specified module stream.
        """
        stream_name: pulumi.Input[_builtins.str]
        """
        The name of a stream of the specified module.
        """
        software_source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
elif False:
    ManagedInstanceGroupManageModuleStreamsManagementRemoveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupManageModuleStreamsManagementRemoveArgs:
    def __init__(__self__, *,
                 module_name: pulumi.Input[_builtins.str],
                 profile_name: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 software_source_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] module_name: The name of a module.
        :param pulumi.Input[_builtins.str] profile_name: The name of a profile of the specified module stream.
        :param pulumi.Input[_builtins.str] stream_name: The name of a stream of the specified module.
        :param pulumi.Input[_builtins.str] software_source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        pulumi.set(__self__, "module_name", module_name)
        pulumi.set(__self__, "profile_name", profile_name)
        pulumi.set(__self__, "stream_name", stream_name)
        if software_source_id is not None:
            pulumi.set(__self__, "software_source_id", software_source_id)

    @_builtins.property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of a module.
        """
        return pulumi.get(self, "module_name")

    @module_name.setter
    def module_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "module_name", value)

    @_builtins.property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of a profile of the specified module stream.
        """
        return pulumi.get(self, "profile_name")

    @profile_name.setter
    def profile_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "profile_name", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of a stream of the specified module.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceId")
    def software_source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        return pulumi.get(self, "software_source_id")

    @software_source_id.setter
    def software_source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_id", value)


if not MYPY:
    class ManagedInstanceGroupManageModuleStreamsManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceGroupManageModuleStreamsManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupManageModuleStreamsManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceGroupRebootManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceGroupRebootManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupRebootManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceGroupRemovePackagesManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceGroupRemovePackagesManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupRemovePackagesManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceGroupSoftwareSourceArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) User-specified description of the managed instance group. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name for the managed instance group. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        is_mandatory_for_autonomous_linux: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        """
        software_source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the software source.
        """
elif False:
    ManagedInstanceGroupSoftwareSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupSoftwareSourceArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_mandatory_for_autonomous_linux: Optional[pulumi.Input[_builtins.bool]] = None,
                 software_source_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Updatable) User-specified description of the managed instance group. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name for the managed instance group. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        :param pulumi.Input[_builtins.bool] is_mandatory_for_autonomous_linux: Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        :param pulumi.Input[_builtins.str] software_source_type: Type of the software source.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_mandatory_for_autonomous_linux is not None:
            pulumi.set(__self__, "is_mandatory_for_autonomous_linux", is_mandatory_for_autonomous_linux)
        if software_source_type is not None:
            pulumi.set(__self__, "software_source_type", software_source_type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) User-specified description of the managed instance group. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name for the managed instance group. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isMandatoryForAutonomousLinux")
    def is_mandatory_for_autonomous_linux(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        """
        return pulumi.get(self, "is_mandatory_for_autonomous_linux")

    @is_mandatory_for_autonomous_linux.setter
    def is_mandatory_for_autonomous_linux(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_mandatory_for_autonomous_linux", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceType")
    def software_source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the software source.
        """
        return pulumi.get(self, "software_source_type")

    @software_source_type.setter
    def software_source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_type", value)


if not MYPY:
    class ManagedInstanceGroupUpdateAllPackagesManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceGroupUpdateAllPackagesManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceGroupUpdateAllPackagesManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceInstallWindowsUpdatesManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceInstallWindowsUpdatesManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceInstallWindowsUpdatesManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceLifecycleEnvironmentArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Software source name.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
elif False:
    ManagedInstanceLifecycleEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceLifecycleEnvironmentArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: Software source name.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Software source name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ManagedInstanceLifecycleStageArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Software source name.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
elif False:
    ManagedInstanceLifecycleStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceLifecycleStageArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: Software source name.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Software source name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ManagedInstanceManagedInstanceGroupArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Software source name.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
elif False:
    ManagedInstanceManagedInstanceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceManagedInstanceGroupArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: Software source name.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Software source name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ManagedInstanceRebootManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceRebootManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceRebootManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedInstanceSoftwareSourceArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) User-specified description of the managed instance. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Software source name.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        is_mandatory_for_autonomous_linux: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        """
        software_source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the software source.
        """
elif False:
    ManagedInstanceSoftwareSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceSoftwareSourceArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_mandatory_for_autonomous_linux: Optional[pulumi.Input[_builtins.bool]] = None,
                 software_source_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Updatable) User-specified description of the managed instance. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: Software source name.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        :param pulumi.Input[_builtins.bool] is_mandatory_for_autonomous_linux: Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        :param pulumi.Input[_builtins.str] software_source_type: Type of the software source.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_mandatory_for_autonomous_linux is not None:
            pulumi.set(__self__, "is_mandatory_for_autonomous_linux", is_mandatory_for_autonomous_linux)
        if software_source_type is not None:
            pulumi.set(__self__, "software_source_type", software_source_type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) User-specified description of the managed instance. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Software source name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isMandatoryForAutonomousLinux")
    def is_mandatory_for_autonomous_linux(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        """
        return pulumi.get(self, "is_mandatory_for_autonomous_linux")

    @is_mandatory_for_autonomous_linux.setter
    def is_mandatory_for_autonomous_linux(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_mandatory_for_autonomous_linux", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceType")
    def software_source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the software source.
        """
        return pulumi.get(self, "software_source_type")

    @software_source_type.setter
    def software_source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_type", value)


if not MYPY:
    class ManagedInstanceUpdatePackagesManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedInstanceUpdatePackagesManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceUpdatePackagesManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagementStationAssociateManagedInstancesManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagementStationAssociateManagedInstancesManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementStationAssociateManagedInstancesManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagementStationHealthArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) User-specified description of the management station. Avoid entering confidential information.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current state of the management station.
        """
elif False:
    ManagementStationHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementStationHealthArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Updatable) User-specified description of the management station. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] state: The current state of the management station.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) User-specified description of the management station. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current state of the management station.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ManagementStationMirrorArgsDict(TypedDict):
        directory: pulumi.Input[_builtins.str]
        """
        (Updatable) Path to the data volume on the management station where software source mirrors are stored.
        """
        port: pulumi.Input[_builtins.str]
        """
        (Updatable) Default mirror listening port for http.
        """
        sslport: pulumi.Input[_builtins.str]
        """
        (Updatable) Default mirror listening port for https.
        """
        is_sslverify_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) When enabled, the SSL certificate is verified whenever an instance installs or updates a package from a software source that is mirrored on the management station.
        """
        sslcert: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Path to the SSL cerfificate.
        """
elif False:
    ManagementStationMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementStationMirrorArgs:
    def __init__(__self__, *,
                 directory: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.str],
                 sslport: pulumi.Input[_builtins.str],
                 is_sslverify_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 sslcert: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] directory: (Updatable) Path to the data volume on the management station where software source mirrors are stored.
        :param pulumi.Input[_builtins.str] port: (Updatable) Default mirror listening port for http.
        :param pulumi.Input[_builtins.str] sslport: (Updatable) Default mirror listening port for https.
        :param pulumi.Input[_builtins.bool] is_sslverify_enabled: (Updatable) When enabled, the SSL certificate is verified whenever an instance installs or updates a package from a software source that is mirrored on the management station.
        :param pulumi.Input[_builtins.str] sslcert: (Updatable) Path to the SSL cerfificate.
        """
        pulumi.set(__self__, "directory", directory)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "sslport", sslport)
        if is_sslverify_enabled is not None:
            pulumi.set(__self__, "is_sslverify_enabled", is_sslverify_enabled)
        if sslcert is not None:
            pulumi.set(__self__, "sslcert", sslcert)

    @_builtins.property
    @pulumi.getter
    def directory(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Path to the data volume on the management station where software source mirrors are stored.
        """
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "directory", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Default mirror listening port for http.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def sslport(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Default mirror listening port for https.
        """
        return pulumi.get(self, "sslport")

    @sslport.setter
    def sslport(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sslport", value)

    @_builtins.property
    @pulumi.getter(name="isSslverifyEnabled")
    def is_sslverify_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) When enabled, the SSL certificate is verified whenever an instance installs or updates a package from a software source that is mirrored on the management station.
        """
        return pulumi.get(self, "is_sslverify_enabled")

    @is_sslverify_enabled.setter
    def is_sslverify_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_sslverify_enabled", value)

    @_builtins.property
    @pulumi.getter
    def sslcert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Path to the SSL cerfificate.
        """
        return pulumi.get(self, "sslcert")

    @sslcert.setter
    def sslcert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sslcert", value)


if not MYPY:
    class ManagementStationMirrorSyncStatusArgsDict(TypedDict):
        failed: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total number of software sources that failed to sync.
        """
        queued: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total number of software sources that are queued for sync.
        """
        synced: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total number of software sources that successfully synced.
        """
        syncing: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total number of software sources currently syncing.
        """
        unsynced: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total number of software sources that have not yet been synced.
        """
elif False:
    ManagementStationMirrorSyncStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementStationMirrorSyncStatusArgs:
    def __init__(__self__, *,
                 failed: Optional[pulumi.Input[_builtins.int]] = None,
                 queued: Optional[pulumi.Input[_builtins.int]] = None,
                 synced: Optional[pulumi.Input[_builtins.int]] = None,
                 syncing: Optional[pulumi.Input[_builtins.int]] = None,
                 unsynced: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] failed: Total number of software sources that failed to sync.
        :param pulumi.Input[_builtins.int] queued: Total number of software sources that are queued for sync.
        :param pulumi.Input[_builtins.int] synced: Total number of software sources that successfully synced.
        :param pulumi.Input[_builtins.int] syncing: Total number of software sources currently syncing.
        :param pulumi.Input[_builtins.int] unsynced: Total number of software sources that have not yet been synced.
        """
        if failed is not None:
            pulumi.set(__self__, "failed", failed)
        if queued is not None:
            pulumi.set(__self__, "queued", queued)
        if synced is not None:
            pulumi.set(__self__, "synced", synced)
        if syncing is not None:
            pulumi.set(__self__, "syncing", syncing)
        if unsynced is not None:
            pulumi.set(__self__, "unsynced", unsynced)

    @_builtins.property
    @pulumi.getter
    def failed(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total number of software sources that failed to sync.
        """
        return pulumi.get(self, "failed")

    @failed.setter
    def failed(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failed", value)

    @_builtins.property
    @pulumi.getter
    def queued(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total number of software sources that are queued for sync.
        """
        return pulumi.get(self, "queued")

    @queued.setter
    def queued(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "queued", value)

    @_builtins.property
    @pulumi.getter
    def synced(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total number of software sources that successfully synced.
        """
        return pulumi.get(self, "synced")

    @synced.setter
    def synced(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "synced", value)

    @_builtins.property
    @pulumi.getter
    def syncing(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total number of software sources currently syncing.
        """
        return pulumi.get(self, "syncing")

    @syncing.setter
    def syncing(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "syncing", value)

    @_builtins.property
    @pulumi.getter
    def unsynced(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total number of software sources that have not yet been synced.
        """
        return pulumi.get(self, "unsynced")

    @unsynced.setter
    def unsynced(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "unsynced", value)


if not MYPY:
    class ManagementStationPeerManagementStationArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) User-friendly name for the management station. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the management station.
        """
elif False:
    ManagementStationPeerManagementStationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementStationPeerManagementStationArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) User-friendly name for the management station. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the management station.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) User-friendly name for the management station. Does not have to be unique and you can change the name later. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the management station.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ManagementStationProxyArgsDict(TypedDict):
        is_enabled: pulumi.Input[_builtins.bool]
        """
        (Updatable) Indicates if the proxy should be enabled or disabled. Default is enabled.
        """
        forward: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The URL the proxy will forward to.
        """
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of hosts.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Listening port used for the proxy.
        """
elif False:
    ManagementStationProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementStationProxyArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[_builtins.bool],
                 forward: Optional[pulumi.Input[_builtins.str]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Indicates if the proxy should be enabled or disabled. Default is enabled.
        :param pulumi.Input[_builtins.str] forward: (Updatable) The URL the proxy will forward to.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] hosts: (Updatable) List of hosts.
        :param pulumi.Input[_builtins.str] port: (Updatable) Listening port used for the proxy.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) Indicates if the proxy should be enabled or disabled. Default is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter
    def forward(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The URL the proxy will forward to.
        """
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "forward", value)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of hosts.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "hosts", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Listening port used for the proxy.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ProfileLifecycleEnvironmentArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
elif False:
    ProfileLifecycleEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileLifecycleEnvironmentArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProfileLifecycleStageArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
elif False:
    ProfileLifecycleStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileLifecycleStageArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProfileManagedInstanceGroupArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
elif False:
    ProfileManagedInstanceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileManagedInstanceGroupArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProfileSoftwareSourceArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) User-specified description of the registration profile.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        is_mandatory_for_autonomous_linux: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        """
        software_source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the software source.
        """
elif False:
    ProfileSoftwareSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileSoftwareSourceArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_mandatory_for_autonomous_linux: Optional[pulumi.Input[_builtins.bool]] = None,
                 software_source_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Updatable) User-specified description of the registration profile.
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        :param pulumi.Input[_builtins.bool] is_mandatory_for_autonomous_linux: Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        :param pulumi.Input[_builtins.str] software_source_type: Type of the software source.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_mandatory_for_autonomous_linux is not None:
            pulumi.set(__self__, "is_mandatory_for_autonomous_linux", is_mandatory_for_autonomous_linux)
        if software_source_type is not None:
            pulumi.set(__self__, "software_source_type", software_source_type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) User-specified description of the registration profile.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique and you can change the name later. Avoid entering  confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isMandatoryForAutonomousLinux")
    def is_mandatory_for_autonomous_linux(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this is a required software source for Autonomous Linux instances. If true, the user can't unselect it.
        """
        return pulumi.get(self, "is_mandatory_for_autonomous_linux")

    @is_mandatory_for_autonomous_linux.setter
    def is_mandatory_for_autonomous_linux(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_mandatory_for_autonomous_linux", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceType")
    def software_source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the software source.
        """
        return pulumi.get(self, "software_source_type")

    @software_source_type.setter
    def software_source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_type", value)


if not MYPY:
    class ScheduledJobOperationArgsDict(TypedDict):
        operation_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of operation this scheduled job performs.
        """
        manage_module_streams_details: NotRequired[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsArgsDict']]
        """
        (Updatable) The set of changes to make to the state of the modules, streams, and profiles on the managed target.
        """
        package_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The names of the target packages. This parameter only applies when the scheduled job is for installing, updating, or removing packages.
        """
        reboot_timeout_in_mins: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The number of minutes the service waits for the reboot to complete. If the instance doesn't reboot within the  timeout, the service marks the reboot job as failed.
        """
        software_source_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The software source [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).  This parameter only applies when the scheduled job is for attaching or detaching software sources.
        """
        switch_module_streams_details: NotRequired[pulumi.Input['ScheduledJobOperationSwitchModuleStreamsDetailsArgsDict']]
        """
        (Updatable) Provides the information used to update a module stream.
        """
        windows_update_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Unique identifier for the Windows update. This parameter only applies if the scheduled job is for installing Windows updates. Note that this is not an OCID, but is a unique identifier assigned by Microsoft. For example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'.
        """
elif False:
    ScheduledJobOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledJobOperationArgs:
    def __init__(__self__, *,
                 operation_type: pulumi.Input[_builtins.str],
                 manage_module_streams_details: Optional[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsArgs']] = None,
                 package_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 reboot_timeout_in_mins: Optional[pulumi.Input[_builtins.int]] = None,
                 software_source_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 switch_module_streams_details: Optional[pulumi.Input['ScheduledJobOperationSwitchModuleStreamsDetailsArgs']] = None,
                 windows_update_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] operation_type: (Updatable) The type of operation this scheduled job performs.
        :param pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsArgs'] manage_module_streams_details: (Updatable) The set of changes to make to the state of the modules, streams, and profiles on the managed target.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] package_names: (Updatable) The names of the target packages. This parameter only applies when the scheduled job is for installing, updating, or removing packages.
        :param pulumi.Input[_builtins.int] reboot_timeout_in_mins: (Updatable) The number of minutes the service waits for the reboot to complete. If the instance doesn't reboot within the  timeout, the service marks the reboot job as failed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] software_source_ids: (Updatable) The software source [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).  This parameter only applies when the scheduled job is for attaching or detaching software sources.
        :param pulumi.Input['ScheduledJobOperationSwitchModuleStreamsDetailsArgs'] switch_module_streams_details: (Updatable) Provides the information used to update a module stream.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] windows_update_names: (Updatable) Unique identifier for the Windows update. This parameter only applies if the scheduled job is for installing Windows updates. Note that this is not an OCID, but is a unique identifier assigned by Microsoft. For example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'.
        """
        pulumi.set(__self__, "operation_type", operation_type)
        if manage_module_streams_details is not None:
            pulumi.set(__self__, "manage_module_streams_details", manage_module_streams_details)
        if package_names is not None:
            pulumi.set(__self__, "package_names", package_names)
        if reboot_timeout_in_mins is not None:
            pulumi.set(__self__, "reboot_timeout_in_mins", reboot_timeout_in_mins)
        if software_source_ids is not None:
            pulumi.set(__self__, "software_source_ids", software_source_ids)
        if switch_module_streams_details is not None:
            pulumi.set(__self__, "switch_module_streams_details", switch_module_streams_details)
        if windows_update_names is not None:
            pulumi.set(__self__, "windows_update_names", windows_update_names)

    @_builtins.property
    @pulumi.getter(name="operationType")
    def operation_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of operation this scheduled job performs.
        """
        return pulumi.get(self, "operation_type")

    @operation_type.setter
    def operation_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation_type", value)

    @_builtins.property
    @pulumi.getter(name="manageModuleStreamsDetails")
    def manage_module_streams_details(self) -> Optional[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsArgs']]:
        """
        (Updatable) The set of changes to make to the state of the modules, streams, and profiles on the managed target.
        """
        return pulumi.get(self, "manage_module_streams_details")

    @manage_module_streams_details.setter
    def manage_module_streams_details(self, value: Optional[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsArgs']]):
        pulumi.set(self, "manage_module_streams_details", value)

    @_builtins.property
    @pulumi.getter(name="packageNames")
    def package_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The names of the target packages. This parameter only applies when the scheduled job is for installing, updating, or removing packages.
        """
        return pulumi.get(self, "package_names")

    @package_names.setter
    def package_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "package_names", value)

    @_builtins.property
    @pulumi.getter(name="rebootTimeoutInMins")
    def reboot_timeout_in_mins(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The number of minutes the service waits for the reboot to complete. If the instance doesn't reboot within the  timeout, the service marks the reboot job as failed.
        """
        return pulumi.get(self, "reboot_timeout_in_mins")

    @reboot_timeout_in_mins.setter
    def reboot_timeout_in_mins(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "reboot_timeout_in_mins", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceIds")
    def software_source_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The software source [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).  This parameter only applies when the scheduled job is for attaching or detaching software sources.
        """
        return pulumi.get(self, "software_source_ids")

    @software_source_ids.setter
    def software_source_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "software_source_ids", value)

    @_builtins.property
    @pulumi.getter(name="switchModuleStreamsDetails")
    def switch_module_streams_details(self) -> Optional[pulumi.Input['ScheduledJobOperationSwitchModuleStreamsDetailsArgs']]:
        """
        (Updatable) Provides the information used to update a module stream.
        """
        return pulumi.get(self, "switch_module_streams_details")

    @switch_module_streams_details.setter
    def switch_module_streams_details(self, value: Optional[pulumi.Input['ScheduledJobOperationSwitchModuleStreamsDetailsArgs']]):
        pulumi.set(self, "switch_module_streams_details", value)

    @_builtins.property
    @pulumi.getter(name="windowsUpdateNames")
    def windows_update_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Unique identifier for the Windows update. This parameter only applies if the scheduled job is for installing Windows updates. Note that this is not an OCID, but is a unique identifier assigned by Microsoft. For example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'.
        """
        return pulumi.get(self, "windows_update_names")

    @windows_update_names.setter
    def windows_update_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "windows_update_names", value)


if not MYPY:
    class ScheduledJobOperationManageModuleStreamsDetailsArgsDict(TypedDict):
        disables: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsDisableArgsDict']]]]
        """
        (Updatable) The set of module streams to disable.
        """
        enables: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsEnableArgsDict']]]]
        """
        (Updatable) The set of module streams to enable.
        """
        installs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsInstallArgsDict']]]]
        """
        (Updatable) The set of module stream profiles to install.
        """
        removes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsRemoveArgsDict']]]]
        """
        (Updatable) The set of module stream profiles to remove.
        """
elif False:
    ScheduledJobOperationManageModuleStreamsDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledJobOperationManageModuleStreamsDetailsArgs:
    def __init__(__self__, *,
                 disables: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsDisableArgs']]]] = None,
                 enables: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsEnableArgs']]]] = None,
                 installs: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsInstallArgs']]]] = None,
                 removes: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsRemoveArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsDisableArgs']]] disables: (Updatable) The set of module streams to disable.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsEnableArgs']]] enables: (Updatable) The set of module streams to enable.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsInstallArgs']]] installs: (Updatable) The set of module stream profiles to install.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsRemoveArgs']]] removes: (Updatable) The set of module stream profiles to remove.
        """
        if disables is not None:
            pulumi.set(__self__, "disables", disables)
        if enables is not None:
            pulumi.set(__self__, "enables", enables)
        if installs is not None:
            pulumi.set(__self__, "installs", installs)
        if removes is not None:
            pulumi.set(__self__, "removes", removes)

    @_builtins.property
    @pulumi.getter
    def disables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsDisableArgs']]]]:
        """
        (Updatable) The set of module streams to disable.
        """
        return pulumi.get(self, "disables")

    @disables.setter
    def disables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsDisableArgs']]]]):
        pulumi.set(self, "disables", value)

    @_builtins.property
    @pulumi.getter
    def enables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsEnableArgs']]]]:
        """
        (Updatable) The set of module streams to enable.
        """
        return pulumi.get(self, "enables")

    @enables.setter
    def enables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsEnableArgs']]]]):
        pulumi.set(self, "enables", value)

    @_builtins.property
    @pulumi.getter
    def installs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsInstallArgs']]]]:
        """
        (Updatable) The set of module stream profiles to install.
        """
        return pulumi.get(self, "installs")

    @installs.setter
    def installs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsInstallArgs']]]]):
        pulumi.set(self, "installs", value)

    @_builtins.property
    @pulumi.getter
    def removes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsRemoveArgs']]]]:
        """
        (Updatable) The set of module stream profiles to remove.
        """
        return pulumi.get(self, "removes")

    @removes.setter
    def removes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledJobOperationManageModuleStreamsDetailsRemoveArgs']]]]):
        pulumi.set(self, "removes", value)


if not MYPY:
    class ScheduledJobOperationManageModuleStreamsDetailsDisableArgsDict(TypedDict):
        module_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a module.
        """
        stream_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a stream of the specified module.
        """
        software_source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
elif False:
    ScheduledJobOperationManageModuleStreamsDetailsDisableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledJobOperationManageModuleStreamsDetailsDisableArgs:
    def __init__(__self__, *,
                 module_name: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 software_source_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] module_name: (Updatable) The name of a module.
        :param pulumi.Input[_builtins.str] stream_name: (Updatable) The name of a stream of the specified module.
        :param pulumi.Input[_builtins.str] software_source_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        pulumi.set(__self__, "module_name", module_name)
        pulumi.set(__self__, "stream_name", stream_name)
        if software_source_id is not None:
            pulumi.set(__self__, "software_source_id", software_source_id)

    @_builtins.property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a module.
        """
        return pulumi.get(self, "module_name")

    @module_name.setter
    def module_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "module_name", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a stream of the specified module.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceId")
    def software_source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        return pulumi.get(self, "software_source_id")

    @software_source_id.setter
    def software_source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_id", value)


if not MYPY:
    class ScheduledJobOperationManageModuleStreamsDetailsEnableArgsDict(TypedDict):
        module_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a module.
        """
        stream_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a stream of the specified module.
        """
        software_source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
elif False:
    ScheduledJobOperationManageModuleStreamsDetailsEnableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledJobOperationManageModuleStreamsDetailsEnableArgs:
    def __init__(__self__, *,
                 module_name: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 software_source_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] module_name: (Updatable) The name of a module.
        :param pulumi.Input[_builtins.str] stream_name: (Updatable) The name of a stream of the specified module.
        :param pulumi.Input[_builtins.str] software_source_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        pulumi.set(__self__, "module_name", module_name)
        pulumi.set(__self__, "stream_name", stream_name)
        if software_source_id is not None:
            pulumi.set(__self__, "software_source_id", software_source_id)

    @_builtins.property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a module.
        """
        return pulumi.get(self, "module_name")

    @module_name.setter
    def module_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "module_name", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a stream of the specified module.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceId")
    def software_source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        return pulumi.get(self, "software_source_id")

    @software_source_id.setter
    def software_source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_id", value)


if not MYPY:
    class ScheduledJobOperationManageModuleStreamsDetailsInstallArgsDict(TypedDict):
        module_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a module.
        """
        profile_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a profile of the specified module stream.
        """
        stream_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a stream of the specified module.
        """
        software_source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
elif False:
    ScheduledJobOperationManageModuleStreamsDetailsInstallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledJobOperationManageModuleStreamsDetailsInstallArgs:
    def __init__(__self__, *,
                 module_name: pulumi.Input[_builtins.str],
                 profile_name: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 software_source_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] module_name: (Updatable) The name of a module.
        :param pulumi.Input[_builtins.str] profile_name: (Updatable) The name of a profile of the specified module stream.
        :param pulumi.Input[_builtins.str] stream_name: (Updatable) The name of a stream of the specified module.
        :param pulumi.Input[_builtins.str] software_source_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        pulumi.set(__self__, "module_name", module_name)
        pulumi.set(__self__, "profile_name", profile_name)
        pulumi.set(__self__, "stream_name", stream_name)
        if software_source_id is not None:
            pulumi.set(__self__, "software_source_id", software_source_id)

    @_builtins.property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a module.
        """
        return pulumi.get(self, "module_name")

    @module_name.setter
    def module_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "module_name", value)

    @_builtins.property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a profile of the specified module stream.
        """
        return pulumi.get(self, "profile_name")

    @profile_name.setter
    def profile_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "profile_name", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a stream of the specified module.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceId")
    def software_source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        return pulumi.get(self, "software_source_id")

    @software_source_id.setter
    def software_source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_id", value)


if not MYPY:
    class ScheduledJobOperationManageModuleStreamsDetailsRemoveArgsDict(TypedDict):
        module_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a module.
        """
        profile_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a profile of the specified module stream.
        """
        stream_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a stream of the specified module.
        """
        software_source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
elif False:
    ScheduledJobOperationManageModuleStreamsDetailsRemoveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledJobOperationManageModuleStreamsDetailsRemoveArgs:
    def __init__(__self__, *,
                 module_name: pulumi.Input[_builtins.str],
                 profile_name: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 software_source_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] module_name: (Updatable) The name of a module.
        :param pulumi.Input[_builtins.str] profile_name: (Updatable) The name of a profile of the specified module stream.
        :param pulumi.Input[_builtins.str] stream_name: (Updatable) The name of a stream of the specified module.
        :param pulumi.Input[_builtins.str] software_source_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        pulumi.set(__self__, "module_name", module_name)
        pulumi.set(__self__, "profile_name", profile_name)
        pulumi.set(__self__, "stream_name", stream_name)
        if software_source_id is not None:
            pulumi.set(__self__, "software_source_id", software_source_id)

    @_builtins.property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a module.
        """
        return pulumi.get(self, "module_name")

    @module_name.setter
    def module_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "module_name", value)

    @_builtins.property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a profile of the specified module stream.
        """
        return pulumi.get(self, "profile_name")

    @profile_name.setter
    def profile_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "profile_name", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a stream of the specified module.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceId")
    def software_source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        return pulumi.get(self, "software_source_id")

    @software_source_id.setter
    def software_source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_id", value)


if not MYPY:
    class ScheduledJobOperationSwitchModuleStreamsDetailsArgsDict(TypedDict):
        module_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a module.
        """
        stream_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of a stream of the specified module.
        """
        software_source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
elif False:
    ScheduledJobOperationSwitchModuleStreamsDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledJobOperationSwitchModuleStreamsDetailsArgs:
    def __init__(__self__, *,
                 module_name: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 software_source_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] module_name: (Updatable) The name of a module.
        :param pulumi.Input[_builtins.str] stream_name: (Updatable) The name of a stream of the specified module.
        :param pulumi.Input[_builtins.str] software_source_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        pulumi.set(__self__, "module_name", module_name)
        pulumi.set(__self__, "stream_name", stream_name)
        if software_source_id is not None:
            pulumi.set(__self__, "software_source_id", software_source_id)

    @_builtins.property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a module.
        """
        return pulumi.get(self, "module_name")

    @module_name.setter
    def module_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "module_name", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of a stream of the specified module.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="softwareSourceId")
    def software_source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the software source that contains the module stream.
        """
        return pulumi.get(self, "software_source_id")

    @software_source_id.setter
    def software_source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "software_source_id", value)


if not MYPY:
    class SoftwareSourceChangeAvailabilityManagementSoftwareSourceAvailabilityArgsDict(TypedDict):
        software_source_id: pulumi.Input[_builtins.str]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the vendor software source.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        availability: NotRequired[pulumi.Input[_builtins.str]]
        """
        Availability of the software source to instances in private data centers or third-party clouds.
        """
        availability_at_oci: NotRequired[pulumi.Input[_builtins.str]]
        """
        Availability of the software source to Oracle Cloud Infrastructure instances.
        """
elif False:
    SoftwareSourceChangeAvailabilityManagementSoftwareSourceAvailabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SoftwareSourceChangeAvailabilityManagementSoftwareSourceAvailabilityArgs:
    def __init__(__self__, *,
                 software_source_id: pulumi.Input[_builtins.str],
                 availability: Optional[pulumi.Input[_builtins.str]] = None,
                 availability_at_oci: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] software_source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the vendor software source.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] availability: Availability of the software source to instances in private data centers or third-party clouds.
        :param pulumi.Input[_builtins.str] availability_at_oci: Availability of the software source to Oracle Cloud Infrastructure instances.
        """
        pulumi.set(__self__, "software_source_id", software_source_id)
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if availability_at_oci is not None:
            pulumi.set(__self__, "availability_at_oci", availability_at_oci)

    @_builtins.property
    @pulumi.getter(name="softwareSourceId")
    def software_source_id(self) -> pulumi.Input[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the vendor software source.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "software_source_id")

    @software_source_id.setter
    def software_source_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "software_source_id", value)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Availability of the software source to instances in private data centers or third-party clouds.
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability", value)

    @_builtins.property
    @pulumi.getter(name="availabilityAtOci")
    def availability_at_oci(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Availability of the software source to Oracle Cloud Infrastructure instances.
        """
        return pulumi.get(self, "availability_at_oci")

    @availability_at_oci.setter
    def availability_at_oci(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_at_oci", value)


if not MYPY:
    class SoftwareSourceCustomSoftwareSourceFilterArgsDict(TypedDict):
        module_stream_profile_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterModuleStreamProfileFilterArgsDict']]]]
        """
        (Updatable) The list of module stream/profile filters.
        """
        package_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterPackageFilterArgsDict']]]]
        """
        (Updatable) The list of package filters.
        """
        package_group_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterPackageGroupFilterArgsDict']]]]
        """
        (Updatable) The list of group filters.
        """
elif False:
    SoftwareSourceCustomSoftwareSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SoftwareSourceCustomSoftwareSourceFilterArgs:
    def __init__(__self__, *,
                 module_stream_profile_filters: Optional[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterModuleStreamProfileFilterArgs']]]] = None,
                 package_filters: Optional[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterPackageFilterArgs']]]] = None,
                 package_group_filters: Optional[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterPackageGroupFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterModuleStreamProfileFilterArgs']]] module_stream_profile_filters: (Updatable) The list of module stream/profile filters.
        :param pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterPackageFilterArgs']]] package_filters: (Updatable) The list of package filters.
        :param pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterPackageGroupFilterArgs']]] package_group_filters: (Updatable) The list of group filters.
        """
        if module_stream_profile_filters is not None:
            pulumi.set(__self__, "module_stream_profile_filters", module_stream_profile_filters)
        if package_filters is not None:
            pulumi.set(__self__, "package_filters", package_filters)
        if package_group_filters is not None:
            pulumi.set(__self__, "package_group_filters", package_group_filters)

    @_builtins.property
    @pulumi.getter(name="moduleStreamProfileFilters")
    def module_stream_profile_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterModuleStreamProfileFilterArgs']]]]:
        """
        (Updatable) The list of module stream/profile filters.
        """
        return pulumi.get(self, "module_stream_profile_filters")

    @module_stream_profile_filters.setter
    def module_stream_profile_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterModuleStreamProfileFilterArgs']]]]):
        pulumi.set(self, "module_stream_profile_filters", value)

    @_builtins.property
    @pulumi.getter(name="packageFilters")
    def package_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterPackageFilterArgs']]]]:
        """
        (Updatable) The list of package filters.
        """
        return pulumi.get(self, "package_filters")

    @package_filters.setter
    def package_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterPackageFilterArgs']]]]):
        pulumi.set(self, "package_filters", value)

    @_builtins.property
    @pulumi.getter(name="packageGroupFilters")
    def package_group_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterPackageGroupFilterArgs']]]]:
        """
        (Updatable) The list of group filters.
        """
        return pulumi.get(self, "package_group_filters")

    @package_group_filters.setter
    def package_group_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SoftwareSourceCustomSoftwareSourceFilterPackageGroupFilterArgs']]]]):
        pulumi.set(self, "package_group_filters", value)


if not MYPY:
    class SoftwareSourceCustomSoftwareSourceFilterModuleStreamProfileFilterArgsDict(TypedDict):
        filter_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of the filter.
        """
        module_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Module name.
        """
        profile_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Profile name.
        """
        stream_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Stream name.
        """
elif False:
    SoftwareSourceCustomSoftwareSourceFilterModuleStreamProfileFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SoftwareSourceCustomSoftwareSourceFilterModuleStreamProfileFilterArgs:
    def __init__(__self__, *,
                 filter_type: Optional[pulumi.Input[_builtins.str]] = None,
                 module_name: Optional[pulumi.Input[_builtins.str]] = None,
                 profile_name: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] filter_type: (Updatable) The type of the filter.
        :param pulumi.Input[_builtins.str] module_name: (Updatable) Module name.
        :param pulumi.Input[_builtins.str] profile_name: (Updatable) Profile name.
        :param pulumi.Input[_builtins.str] stream_name: (Updatable) Stream name.
        """
        if filter_type is not None:
            pulumi.set(__self__, "filter_type", filter_type)
        if module_name is not None:
            pulumi.set(__self__, "module_name", module_name)
        if profile_name is not None:
            pulumi.set(__self__, "profile_name", profile_name)
        if stream_name is not None:
            pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of the filter.
        """
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter_type", value)

    @_builtins.property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Module name.
        """
        return pulumi.get(self, "module_name")

    @module_name.setter
    def module_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "module_name", value)

    @_builtins.property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Profile name.
        """
        return pulumi.get(self, "profile_name")

    @profile_name.setter
    def profile_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_name", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Stream name.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_name", value)


if not MYPY:
    class SoftwareSourceCustomSoftwareSourceFilterPackageFilterArgsDict(TypedDict):
        filter_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of the filter.
        """
        package_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The package name.
        """
        package_name_pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The package name pattern.
        """
        package_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The package version, which is denoted by 'version-release', or 'epoch:version-release'.
        """
elif False:
    SoftwareSourceCustomSoftwareSourceFilterPackageFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SoftwareSourceCustomSoftwareSourceFilterPackageFilterArgs:
    def __init__(__self__, *,
                 filter_type: Optional[pulumi.Input[_builtins.str]] = None,
                 package_name: Optional[pulumi.Input[_builtins.str]] = None,
                 package_name_pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 package_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] filter_type: (Updatable) The type of the filter.
        :param pulumi.Input[_builtins.str] package_name: (Updatable) The package name.
        :param pulumi.Input[_builtins.str] package_name_pattern: (Updatable) The package name pattern.
        :param pulumi.Input[_builtins.str] package_version: (Updatable) The package version, which is denoted by 'version-release', or 'epoch:version-release'.
        """
        if filter_type is not None:
            pulumi.set(__self__, "filter_type", filter_type)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if package_name_pattern is not None:
            pulumi.set(__self__, "package_name_pattern", package_name_pattern)
        if package_version is not None:
            pulumi.set(__self__, "package_version", package_version)

    @_builtins.property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of the filter.
        """
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter_type", value)

    @_builtins.property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The package name.
        """
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "package_name", value)

    @_builtins.property
    @pulumi.getter(name="packageNamePattern")
    def package_name_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The package name pattern.
        """
        return pulumi.get(self, "package_name_pattern")

    @package_name_pattern.setter
    def package_name_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "package_name_pattern", value)

    @_builtins.property
    @pulumi.getter(name="packageVersion")
    def package_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The package version, which is denoted by 'version-release', or 'epoch:version-release'.
        """
        return pulumi.get(self, "package_version")

    @package_version.setter
    def package_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "package_version", value)


if not MYPY:
    class SoftwareSourceCustomSoftwareSourceFilterPackageGroupFilterArgsDict(TypedDict):
        filter_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of the filter.
        """
        package_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of package group names.
        """
elif False:
    SoftwareSourceCustomSoftwareSourceFilterPackageGroupFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SoftwareSourceCustomSoftwareSourceFilterPackageGroupFilterArgs:
    def __init__(__self__, *,
                 filter_type: Optional[pulumi.Input[_builtins.str]] = None,
                 package_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] filter_type: (Updatable) The type of the filter.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] package_groups: (Updatable) List of package group names.
        """
        if filter_type is not None:
            pulumi.set(__self__, "filter_type", filter_type)
        if package_groups is not None:
            pulumi.set(__self__, "package_groups", package_groups)

    @_builtins.property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of the filter.
        """
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter_type", value)

    @_builtins.property
    @pulumi.getter(name="packageGroups")
    def package_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of package group names.
        """
        return pulumi.get(self, "package_groups")

    @package_groups.setter
    def package_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "package_groups", value)


if not MYPY:
    class SoftwareSourceVendorSoftwareSourceArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) User-friendly name.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that is immutable on creation.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    SoftwareSourceVendorSoftwareSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SoftwareSourceVendorSoftwareSourceArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) User-friendly name.
        :param pulumi.Input[_builtins.str] id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that is immutable on creation.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) User-friendly name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that is immutable on creation.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class WorkRequestRerunManagementWorkRequestDetailsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
        """
elif False:
    WorkRequestRerunManagementWorkRequestDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkRequestRerunManagementWorkRequestDetailsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: User-specified information about the job. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-specified information about the job. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name for the job. The name does not have to be unique. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class GetEntitlementsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetEntitlementsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEntitlementsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetErrataFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The assigned erratum name. It's unique and not changeable.  Example: `ELSA-2020-5804`
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetErrataFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetErrataFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The assigned erratum name. It's unique and not changeable.  Example: `ELSA-2020-5804`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The assigned erratum name. It's unique and not changeable.  Example: `ELSA-2020-5804`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetEventsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetEventsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEventsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetLifecycleEnvironmentsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetLifecycleEnvironmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLifecycleEnvironmentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetLifecycleStagesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetLifecycleStagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLifecycleStagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceAvailablePackagesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Unique identifier for the package.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceAvailablePackagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceAvailablePackagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique identifier for the package.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique identifier for the package.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceAvailableSoftwareSourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceAvailableSoftwareSourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceAvailableSoftwareSourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceAvailableWindowsUpdatesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter based on the unique identifier for the Windows update. Note that this is not an OCID, but is a unique identifier assigned by Microsoft.  Example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceAvailableWindowsUpdatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceAvailableWindowsUpdatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter based on the unique identifier for the Windows update. Note that this is not an OCID, but is a unique identifier assigned by Microsoft.  Example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter based on the unique identifier for the Windows update. Note that this is not an OCID, but is a unique identifier assigned by Microsoft.  Example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceErrataFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The assigned erratum name. It's unique and not changeable.  Example: `ELSA-2020-5804`
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceErrataFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceErrataFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The assigned erratum name. It's unique and not changeable.  Example: `ELSA-2020-5804`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The assigned erratum name. It's unique and not changeable.  Example: `ELSA-2020-5804`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceGroupAvailableModulesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The resource name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceGroupAvailableModulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceGroupAvailableModulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The resource name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceGroupAvailablePackagesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Unique identifier for the package. Note that this is not an OCID.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceGroupAvailablePackagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceGroupAvailablePackagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique identifier for the package. Note that this is not an OCID.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique identifier for the package. Note that this is not an OCID.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceGroupAvailableSoftwareSourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceGroupAvailableSoftwareSourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceGroupAvailableSoftwareSourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceGroupInstalledPackagesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the package that is installed on the managed instance group.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceGroupInstalledPackagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceGroupInstalledPackagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the package that is installed on the managed instance group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the package that is installed on the managed instance group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceGroupModulesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The resource name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceGroupModulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceGroupModulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The resource name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceInstalledPackagesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Unique identifier for the package.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceInstalledPackagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceInstalledPackagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique identifier for the package.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique identifier for the package.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceInstalledWindowsUpdatesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter based on the unique identifier for the Windows update. Note that this is not an OCID, but is a unique identifier assigned by Microsoft.  Example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceInstalledWindowsUpdatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceInstalledWindowsUpdatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter based on the unique identifier for the Windows update. Note that this is not an OCID, but is a unique identifier assigned by Microsoft.  Example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter based on the unique identifier for the Windows update. Note that this is not an OCID, but is a unique identifier assigned by Microsoft.  Example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceModulesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The resource name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceModulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceModulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The resource name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstanceUpdatablePackagesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Unique identifier for the package.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstanceUpdatablePackagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstanceUpdatablePackagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique identifier for the package.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique identifier for the package.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagementStationMirrorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagementStationMirrorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagementStationMirrorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagementStationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagementStationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagementStationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProfileAvailableSoftwareSourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetProfileAvailableSoftwareSourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProfileAvailableSoftwareSourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProfilesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetProfilesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProfilesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetScheduledJobsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetScheduledJobsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetScheduledJobsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSoftwarePackageSoftwareSourceFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSoftwarePackageSoftwareSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSoftwarePackageSoftwareSourceFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSoftwarePackagesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Unique identifier for the package. Note that this is not an OCID.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSoftwarePackagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSoftwarePackagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique identifier for the package. Note that this is not an OCID.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique identifier for the package. Note that this is not an OCID.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSoftwareSourceAvailableSoftwarePackagesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Unique identifier for the package. Note that this is not an OCID.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSoftwareSourceAvailableSoftwarePackagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSoftwareSourceAvailableSoftwarePackagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique identifier for the package. Note that this is not an OCID.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique identifier for the package. Note that this is not an OCID.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSoftwareSourceModuleStreamProfilesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the entity to be queried.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSoftwareSourceModuleStreamProfilesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSoftwareSourceModuleStreamProfilesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the entity to be queried.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the entity to be queried.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSoftwareSourceModuleStreamsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the entity to be queried.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSoftwareSourceModuleStreamsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSoftwareSourceModuleStreamsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the entity to be queried.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the entity to be queried.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSoftwareSourcePackageGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the entity to be queried.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSoftwareSourcePackageGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSoftwareSourcePackageGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the entity to be queried.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the entity to be queried.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSoftwareSourceSoftwarePackagesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Unique identifier for the package. Note that this is not an OCID.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSoftwareSourceSoftwarePackagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSoftwareSourceSoftwarePackagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique identifier for the package. Note that this is not an OCID.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique identifier for the package. Note that this is not an OCID.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSoftwareSourceVendorsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the entity to be queried.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSoftwareSourceVendorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSoftwareSourceVendorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the entity to be queried.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the entity to be queried.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSoftwareSourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSoftwareSourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSoftwareSourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWindowsUpdatesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter based on the unique identifier for the Windows update. Note that this is not an OCID, but is a unique identifier assigned by Microsoft.  Example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWindowsUpdatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWindowsUpdatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter based on the unique identifier for the Windows update. Note that this is not an OCID, but is a unique identifier assigned by Microsoft.  Example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter based on the unique identifier for the Windows update. Note that this is not an OCID, but is a unique identifier assigned by Microsoft.  Example: '6981d463-cd91-4a26-b7c4-ea4ded9183ed'
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


