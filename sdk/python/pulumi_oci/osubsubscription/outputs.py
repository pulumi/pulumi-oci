# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'GetCommitmentsCommitmentResult',
    'GetCommitmentsFilterResult',
    'GetRatecardsFilterResult',
    'GetRatecardsRateCardResult',
    'GetRatecardsRateCardCurrencyResult',
    'GetRatecardsRateCardProductResult',
    'GetRatecardsRateCardRateCardTierResult',
    'GetSubscriptionsFilterResult',
    'GetSubscriptionsSubscriptionResult',
    'GetSubscriptionsSubscriptionCurrencyResult',
    'GetSubscriptionsSubscriptionSubscribedServiceResult',
    'GetSubscriptionsSubscriptionSubscribedServiceCommitmentServiceResult',
    'GetSubscriptionsSubscriptionSubscribedServiceProductResult',
]

@pulumi.output_type
class GetCommitmentsCommitmentResult(dict):
    def __init__(__self__, *,
                 available_amount: str,
                 funded_allocation_value: str,
                 id: str,
                 quantity: str,
                 time_end: str,
                 time_start: str,
                 used_amount: str):
        """
        :param str available_amount: Commitment available amount
        :param str funded_allocation_value: Funded Allocation line value example: 12000.00
        :param str id: SPM internal Commitment ID
        :param str quantity: Commitment quantity
        :param str time_end: Commitment end date
        :param str time_start: Commitment start date
        :param str used_amount: Commitment used amount
        """
        GetCommitmentsCommitmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_amount=available_amount,
            funded_allocation_value=funded_allocation_value,
            id=id,
            quantity=quantity,
            time_end=time_end,
            time_start=time_start,
            used_amount=used_amount,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_amount: Optional[str] = None,
             funded_allocation_value: Optional[str] = None,
             id: Optional[str] = None,
             quantity: Optional[str] = None,
             time_end: Optional[str] = None,
             time_start: Optional[str] = None,
             used_amount: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if available_amount is None and 'availableAmount' in kwargs:
            available_amount = kwargs['availableAmount']
        if available_amount is None:
            raise TypeError("Missing 'available_amount' argument")
        if funded_allocation_value is None and 'fundedAllocationValue' in kwargs:
            funded_allocation_value = kwargs['fundedAllocationValue']
        if funded_allocation_value is None:
            raise TypeError("Missing 'funded_allocation_value' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if quantity is None:
            raise TypeError("Missing 'quantity' argument")
        if time_end is None and 'timeEnd' in kwargs:
            time_end = kwargs['timeEnd']
        if time_end is None:
            raise TypeError("Missing 'time_end' argument")
        if time_start is None and 'timeStart' in kwargs:
            time_start = kwargs['timeStart']
        if time_start is None:
            raise TypeError("Missing 'time_start' argument")
        if used_amount is None and 'usedAmount' in kwargs:
            used_amount = kwargs['usedAmount']
        if used_amount is None:
            raise TypeError("Missing 'used_amount' argument")

        _setter("available_amount", available_amount)
        _setter("funded_allocation_value", funded_allocation_value)
        _setter("id", id)
        _setter("quantity", quantity)
        _setter("time_end", time_end)
        _setter("time_start", time_start)
        _setter("used_amount", used_amount)

    @property
    @pulumi.getter(name="availableAmount")
    def available_amount(self) -> str:
        """
        Commitment available amount
        """
        return pulumi.get(self, "available_amount")

    @property
    @pulumi.getter(name="fundedAllocationValue")
    def funded_allocation_value(self) -> str:
        """
        Funded Allocation line value example: 12000.00
        """
        return pulumi.get(self, "funded_allocation_value")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        SPM internal Commitment ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def quantity(self) -> str:
        """
        Commitment quantity
        """
        return pulumi.get(self, "quantity")

    @property
    @pulumi.getter(name="timeEnd")
    def time_end(self) -> str:
        """
        Commitment end date
        """
        return pulumi.get(self, "time_end")

    @property
    @pulumi.getter(name="timeStart")
    def time_start(self) -> str:
        """
        Commitment start date
        """
        return pulumi.get(self, "time_start")

    @property
    @pulumi.getter(name="usedAmount")
    def used_amount(self) -> str:
        """
        Commitment used amount
        """
        return pulumi.get(self, "used_amount")


@pulumi.output_type
class GetCommitmentsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetCommitmentsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetRatecardsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Product name
        """
        GetRatecardsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetRatecardsRateCardResult(dict):
    def __init__(__self__, *,
                 currencies: Sequence['outputs.GetRatecardsRateCardCurrencyResult'],
                 discretionary_discount_percentage: str,
                 is_tier: bool,
                 net_unit_price: str,
                 overage_price: str,
                 products: Sequence['outputs.GetRatecardsRateCardProductResult'],
                 rate_card_tiers: Sequence['outputs.GetRatecardsRateCardRateCardTierResult'],
                 time_end: str,
                 time_start: str):
        """
        :param Sequence['GetRatecardsRateCardCurrencyArgs'] currencies: Currency details
        :param str discretionary_discount_percentage: Rate card discretionary discount percentage
        :param bool is_tier: Rate card price tier flag
        :param str net_unit_price: Rate card tier net unit price
        :param str overage_price: Rate card tier overage price
        :param Sequence['GetRatecardsRateCardProductArgs'] products: Product description
        :param Sequence['GetRatecardsRateCardRateCardTierArgs'] rate_card_tiers: List of tiered rate card prices
        :param str time_end: Rate card end date
        :param str time_start: Rate card start date
        """
        GetRatecardsRateCardResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            currencies=currencies,
            discretionary_discount_percentage=discretionary_discount_percentage,
            is_tier=is_tier,
            net_unit_price=net_unit_price,
            overage_price=overage_price,
            products=products,
            rate_card_tiers=rate_card_tiers,
            time_end=time_end,
            time_start=time_start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             currencies: Optional[Sequence['outputs.GetRatecardsRateCardCurrencyResult']] = None,
             discretionary_discount_percentage: Optional[str] = None,
             is_tier: Optional[bool] = None,
             net_unit_price: Optional[str] = None,
             overage_price: Optional[str] = None,
             products: Optional[Sequence['outputs.GetRatecardsRateCardProductResult']] = None,
             rate_card_tiers: Optional[Sequence['outputs.GetRatecardsRateCardRateCardTierResult']] = None,
             time_end: Optional[str] = None,
             time_start: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if currencies is None:
            raise TypeError("Missing 'currencies' argument")
        if discretionary_discount_percentage is None and 'discretionaryDiscountPercentage' in kwargs:
            discretionary_discount_percentage = kwargs['discretionaryDiscountPercentage']
        if discretionary_discount_percentage is None:
            raise TypeError("Missing 'discretionary_discount_percentage' argument")
        if is_tier is None and 'isTier' in kwargs:
            is_tier = kwargs['isTier']
        if is_tier is None:
            raise TypeError("Missing 'is_tier' argument")
        if net_unit_price is None and 'netUnitPrice' in kwargs:
            net_unit_price = kwargs['netUnitPrice']
        if net_unit_price is None:
            raise TypeError("Missing 'net_unit_price' argument")
        if overage_price is None and 'overagePrice' in kwargs:
            overage_price = kwargs['overagePrice']
        if overage_price is None:
            raise TypeError("Missing 'overage_price' argument")
        if products is None:
            raise TypeError("Missing 'products' argument")
        if rate_card_tiers is None and 'rateCardTiers' in kwargs:
            rate_card_tiers = kwargs['rateCardTiers']
        if rate_card_tiers is None:
            raise TypeError("Missing 'rate_card_tiers' argument")
        if time_end is None and 'timeEnd' in kwargs:
            time_end = kwargs['timeEnd']
        if time_end is None:
            raise TypeError("Missing 'time_end' argument")
        if time_start is None and 'timeStart' in kwargs:
            time_start = kwargs['timeStart']
        if time_start is None:
            raise TypeError("Missing 'time_start' argument")

        _setter("currencies", currencies)
        _setter("discretionary_discount_percentage", discretionary_discount_percentage)
        _setter("is_tier", is_tier)
        _setter("net_unit_price", net_unit_price)
        _setter("overage_price", overage_price)
        _setter("products", products)
        _setter("rate_card_tiers", rate_card_tiers)
        _setter("time_end", time_end)
        _setter("time_start", time_start)

    @property
    @pulumi.getter
    def currencies(self) -> Sequence['outputs.GetRatecardsRateCardCurrencyResult']:
        """
        Currency details
        """
        return pulumi.get(self, "currencies")

    @property
    @pulumi.getter(name="discretionaryDiscountPercentage")
    def discretionary_discount_percentage(self) -> str:
        """
        Rate card discretionary discount percentage
        """
        return pulumi.get(self, "discretionary_discount_percentage")

    @property
    @pulumi.getter(name="isTier")
    def is_tier(self) -> bool:
        """
        Rate card price tier flag
        """
        return pulumi.get(self, "is_tier")

    @property
    @pulumi.getter(name="netUnitPrice")
    def net_unit_price(self) -> str:
        """
        Rate card tier net unit price
        """
        return pulumi.get(self, "net_unit_price")

    @property
    @pulumi.getter(name="overagePrice")
    def overage_price(self) -> str:
        """
        Rate card tier overage price
        """
        return pulumi.get(self, "overage_price")

    @property
    @pulumi.getter
    def products(self) -> Sequence['outputs.GetRatecardsRateCardProductResult']:
        """
        Product description
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="rateCardTiers")
    def rate_card_tiers(self) -> Sequence['outputs.GetRatecardsRateCardRateCardTierResult']:
        """
        List of tiered rate card prices
        """
        return pulumi.get(self, "rate_card_tiers")

    @property
    @pulumi.getter(name="timeEnd")
    def time_end(self) -> str:
        """
        Rate card end date
        """
        return pulumi.get(self, "time_end")

    @property
    @pulumi.getter(name="timeStart")
    def time_start(self) -> str:
        """
        Rate card start date
        """
        return pulumi.get(self, "time_start")


@pulumi.output_type
class GetRatecardsRateCardCurrencyResult(dict):
    def __init__(__self__, *,
                 iso_code: str,
                 name: str,
                 std_precision: str):
        """
        :param str iso_code: Currency Code
        :param str name: Product name
        :param str std_precision: Standard Precision of the Currency
        """
        GetRatecardsRateCardCurrencyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            iso_code=iso_code,
            name=name,
            std_precision=std_precision,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             iso_code: Optional[str] = None,
             name: Optional[str] = None,
             std_precision: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if iso_code is None and 'isoCode' in kwargs:
            iso_code = kwargs['isoCode']
        if iso_code is None:
            raise TypeError("Missing 'iso_code' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if std_precision is None and 'stdPrecision' in kwargs:
            std_precision = kwargs['stdPrecision']
        if std_precision is None:
            raise TypeError("Missing 'std_precision' argument")

        _setter("iso_code", iso_code)
        _setter("name", name)
        _setter("std_precision", std_precision)

    @property
    @pulumi.getter(name="isoCode")
    def iso_code(self) -> str:
        """
        Currency Code
        """
        return pulumi.get(self, "iso_code")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="stdPrecision")
    def std_precision(self) -> str:
        """
        Standard Precision of the Currency
        """
        return pulumi.get(self, "std_precision")


@pulumi.output_type
class GetRatecardsRateCardProductResult(dict):
    def __init__(__self__, *,
                 billing_category: str,
                 name: str,
                 part_number: str,
                 product_category: str,
                 ucm_rate_card_part_type: str,
                 unit_of_measure: str):
        """
        :param str billing_category: Metered service billing category
        :param str name: Product name
        :param str part_number: This param is used to get the rate card(s) filterd by the partNumber
        :param str product_category: Product category
        :param str ucm_rate_card_part_type: Rate card part type of Product
        :param str unit_of_measure: Unit of measure
        """
        GetRatecardsRateCardProductResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            billing_category=billing_category,
            name=name,
            part_number=part_number,
            product_category=product_category,
            ucm_rate_card_part_type=ucm_rate_card_part_type,
            unit_of_measure=unit_of_measure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             billing_category: Optional[str] = None,
             name: Optional[str] = None,
             part_number: Optional[str] = None,
             product_category: Optional[str] = None,
             ucm_rate_card_part_type: Optional[str] = None,
             unit_of_measure: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if billing_category is None and 'billingCategory' in kwargs:
            billing_category = kwargs['billingCategory']
        if billing_category is None:
            raise TypeError("Missing 'billing_category' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if part_number is None and 'partNumber' in kwargs:
            part_number = kwargs['partNumber']
        if part_number is None:
            raise TypeError("Missing 'part_number' argument")
        if product_category is None and 'productCategory' in kwargs:
            product_category = kwargs['productCategory']
        if product_category is None:
            raise TypeError("Missing 'product_category' argument")
        if ucm_rate_card_part_type is None and 'ucmRateCardPartType' in kwargs:
            ucm_rate_card_part_type = kwargs['ucmRateCardPartType']
        if ucm_rate_card_part_type is None:
            raise TypeError("Missing 'ucm_rate_card_part_type' argument")
        if unit_of_measure is None and 'unitOfMeasure' in kwargs:
            unit_of_measure = kwargs['unitOfMeasure']
        if unit_of_measure is None:
            raise TypeError("Missing 'unit_of_measure' argument")

        _setter("billing_category", billing_category)
        _setter("name", name)
        _setter("part_number", part_number)
        _setter("product_category", product_category)
        _setter("ucm_rate_card_part_type", ucm_rate_card_part_type)
        _setter("unit_of_measure", unit_of_measure)

    @property
    @pulumi.getter(name="billingCategory")
    def billing_category(self) -> str:
        """
        Metered service billing category
        """
        return pulumi.get(self, "billing_category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="partNumber")
    def part_number(self) -> str:
        """
        This param is used to get the rate card(s) filterd by the partNumber
        """
        return pulumi.get(self, "part_number")

    @property
    @pulumi.getter(name="productCategory")
    def product_category(self) -> str:
        """
        Product category
        """
        return pulumi.get(self, "product_category")

    @property
    @pulumi.getter(name="ucmRateCardPartType")
    def ucm_rate_card_part_type(self) -> str:
        """
        Rate card part type of Product
        """
        return pulumi.get(self, "ucm_rate_card_part_type")

    @property
    @pulumi.getter(name="unitOfMeasure")
    def unit_of_measure(self) -> str:
        """
        Unit of measure
        """
        return pulumi.get(self, "unit_of_measure")


@pulumi.output_type
class GetRatecardsRateCardRateCardTierResult(dict):
    def __init__(__self__, *,
                 net_unit_price: str,
                 overage_price: str,
                 up_to_quantity: str):
        """
        :param str net_unit_price: Rate card tier net unit price
        :param str overage_price: Rate card tier overage price
        :param str up_to_quantity: Rate card tier quantity range
        """
        GetRatecardsRateCardRateCardTierResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            net_unit_price=net_unit_price,
            overage_price=overage_price,
            up_to_quantity=up_to_quantity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             net_unit_price: Optional[str] = None,
             overage_price: Optional[str] = None,
             up_to_quantity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if net_unit_price is None and 'netUnitPrice' in kwargs:
            net_unit_price = kwargs['netUnitPrice']
        if net_unit_price is None:
            raise TypeError("Missing 'net_unit_price' argument")
        if overage_price is None and 'overagePrice' in kwargs:
            overage_price = kwargs['overagePrice']
        if overage_price is None:
            raise TypeError("Missing 'overage_price' argument")
        if up_to_quantity is None and 'upToQuantity' in kwargs:
            up_to_quantity = kwargs['upToQuantity']
        if up_to_quantity is None:
            raise TypeError("Missing 'up_to_quantity' argument")

        _setter("net_unit_price", net_unit_price)
        _setter("overage_price", overage_price)
        _setter("up_to_quantity", up_to_quantity)

    @property
    @pulumi.getter(name="netUnitPrice")
    def net_unit_price(self) -> str:
        """
        Rate card tier net unit price
        """
        return pulumi.get(self, "net_unit_price")

    @property
    @pulumi.getter(name="overagePrice")
    def overage_price(self) -> str:
        """
        Rate card tier overage price
        """
        return pulumi.get(self, "overage_price")

    @property
    @pulumi.getter(name="upToQuantity")
    def up_to_quantity(self) -> str:
        """
        Rate card tier quantity range
        """
        return pulumi.get(self, "up_to_quantity")


@pulumi.output_type
class GetSubscriptionsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Product name
        """
        GetSubscriptionsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSubscriptionsSubscriptionResult(dict):
    def __init__(__self__, *,
                 currencies: Sequence['outputs.GetSubscriptionsSubscriptionCurrencyResult'],
                 service_name: str,
                 status: str,
                 subscribed_services: Sequence['outputs.GetSubscriptionsSubscriptionSubscribedServiceResult'],
                 time_end: str,
                 time_start: str):
        """
        :param Sequence['GetSubscriptionsSubscriptionCurrencyArgs'] currencies: Currency details
        :param str service_name: Customer friendly service name provided by PRG
        :param str status: Subscribed service status
        :param Sequence['GetSubscriptionsSubscriptionSubscribedServiceArgs'] subscribed_services: List of Subscribed Services of the plan
        :param str time_end: Represents the date when the last service of the subscription ends
        :param str time_start: Represents the date when the first service of the subscription was activated
        """
        GetSubscriptionsSubscriptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            currencies=currencies,
            service_name=service_name,
            status=status,
            subscribed_services=subscribed_services,
            time_end=time_end,
            time_start=time_start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             currencies: Optional[Sequence['outputs.GetSubscriptionsSubscriptionCurrencyResult']] = None,
             service_name: Optional[str] = None,
             status: Optional[str] = None,
             subscribed_services: Optional[Sequence['outputs.GetSubscriptionsSubscriptionSubscribedServiceResult']] = None,
             time_end: Optional[str] = None,
             time_start: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if currencies is None:
            raise TypeError("Missing 'currencies' argument")
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if subscribed_services is None and 'subscribedServices' in kwargs:
            subscribed_services = kwargs['subscribedServices']
        if subscribed_services is None:
            raise TypeError("Missing 'subscribed_services' argument")
        if time_end is None and 'timeEnd' in kwargs:
            time_end = kwargs['timeEnd']
        if time_end is None:
            raise TypeError("Missing 'time_end' argument")
        if time_start is None and 'timeStart' in kwargs:
            time_start = kwargs['timeStart']
        if time_start is None:
            raise TypeError("Missing 'time_start' argument")

        _setter("currencies", currencies)
        _setter("service_name", service_name)
        _setter("status", status)
        _setter("subscribed_services", subscribed_services)
        _setter("time_end", time_end)
        _setter("time_start", time_start)

    @property
    @pulumi.getter
    def currencies(self) -> Sequence['outputs.GetSubscriptionsSubscriptionCurrencyResult']:
        """
        Currency details
        """
        return pulumi.get(self, "currencies")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Customer friendly service name provided by PRG
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Subscribed service status
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="subscribedServices")
    def subscribed_services(self) -> Sequence['outputs.GetSubscriptionsSubscriptionSubscribedServiceResult']:
        """
        List of Subscribed Services of the plan
        """
        return pulumi.get(self, "subscribed_services")

    @property
    @pulumi.getter(name="timeEnd")
    def time_end(self) -> str:
        """
        Represents the date when the last service of the subscription ends
        """
        return pulumi.get(self, "time_end")

    @property
    @pulumi.getter(name="timeStart")
    def time_start(self) -> str:
        """
        Represents the date when the first service of the subscription was activated
        """
        return pulumi.get(self, "time_start")


@pulumi.output_type
class GetSubscriptionsSubscriptionCurrencyResult(dict):
    def __init__(__self__, *,
                 iso_code: str,
                 name: str,
                 std_precision: str):
        """
        :param str iso_code: Currency Code
        :param str name: Product name
        :param str std_precision: Standard Precision of the Currency
        """
        GetSubscriptionsSubscriptionCurrencyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            iso_code=iso_code,
            name=name,
            std_precision=std_precision,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             iso_code: Optional[str] = None,
             name: Optional[str] = None,
             std_precision: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if iso_code is None and 'isoCode' in kwargs:
            iso_code = kwargs['isoCode']
        if iso_code is None:
            raise TypeError("Missing 'iso_code' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if std_precision is None and 'stdPrecision' in kwargs:
            std_precision = kwargs['stdPrecision']
        if std_precision is None:
            raise TypeError("Missing 'std_precision' argument")

        _setter("iso_code", iso_code)
        _setter("name", name)
        _setter("std_precision", std_precision)

    @property
    @pulumi.getter(name="isoCode")
    def iso_code(self) -> str:
        """
        Currency Code
        """
        return pulumi.get(self, "iso_code")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="stdPrecision")
    def std_precision(self) -> str:
        """
        Standard Precision of the Currency
        """
        return pulumi.get(self, "std_precision")


@pulumi.output_type
class GetSubscriptionsSubscriptionSubscribedServiceResult(dict):
    def __init__(__self__, *,
                 booking_opty_number: str,
                 commitment_services: Sequence['outputs.GetSubscriptionsSubscriptionSubscribedServiceCommitmentServiceResult'],
                 csi: str,
                 data_center_region: str,
                 funded_allocation_value: str,
                 id: str,
                 is_intent_to_pay: bool,
                 net_unit_price: str,
                 operation_type: str,
                 order_number: str,
                 partner_transaction_type: str,
                 pricing_model: str,
                 products: Sequence['outputs.GetSubscriptionsSubscriptionSubscribedServiceProductResult'],
                 program_type: str,
                 promo_type: str,
                 quantity: str,
                 status: str,
                 term_value: str,
                 term_value_uom: str,
                 time_end: str,
                 time_start: str,
                 total_value: str):
        """
        :param str booking_opty_number: Booking Opportunity Number of Subscribed Service
        :param Sequence['GetSubscriptionsSubscriptionSubscribedServiceCommitmentServiceArgs'] commitment_services: List of Commitment services of a line
        :param str csi: Subscribed service CSI number
        :param str data_center_region: Subscribed service data center region
        :param str funded_allocation_value: Funded Allocation line value example: 12000.00
        :param str id: SPM internal Subscribed Service ID
        :param bool is_intent_to_pay: Subscribed service intent to pay flag
        :param str net_unit_price: Subscribed service net unit price
        :param str operation_type: Subscribed service operation type
        :param str order_number: Sales Order Number associated to the subscribed service
        :param str partner_transaction_type: This field contains the name of the partner to which the subscription belongs - depending on which the invoicing may differ
        :param str pricing_model: Subscribed service pricing model
        :param Sequence['GetSubscriptionsSubscriptionSubscribedServiceProductArgs'] products: Product description
        :param str program_type: Subscribed service program type
        :param str promo_type: Subscribed service promotion type
        :param str quantity: Subscribed service quantity
        :param str status: Subscribed service status
        :param str term_value: Term value in Months
        :param str term_value_uom: Term value UOM
        :param str time_end: Represents the date when the last service of the subscription ends
        :param str time_start: Represents the date when the first service of the subscription was activated
        :param str total_value: Subscribed service total value
        """
        GetSubscriptionsSubscriptionSubscribedServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            booking_opty_number=booking_opty_number,
            commitment_services=commitment_services,
            csi=csi,
            data_center_region=data_center_region,
            funded_allocation_value=funded_allocation_value,
            id=id,
            is_intent_to_pay=is_intent_to_pay,
            net_unit_price=net_unit_price,
            operation_type=operation_type,
            order_number=order_number,
            partner_transaction_type=partner_transaction_type,
            pricing_model=pricing_model,
            products=products,
            program_type=program_type,
            promo_type=promo_type,
            quantity=quantity,
            status=status,
            term_value=term_value,
            term_value_uom=term_value_uom,
            time_end=time_end,
            time_start=time_start,
            total_value=total_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             booking_opty_number: Optional[str] = None,
             commitment_services: Optional[Sequence['outputs.GetSubscriptionsSubscriptionSubscribedServiceCommitmentServiceResult']] = None,
             csi: Optional[str] = None,
             data_center_region: Optional[str] = None,
             funded_allocation_value: Optional[str] = None,
             id: Optional[str] = None,
             is_intent_to_pay: Optional[bool] = None,
             net_unit_price: Optional[str] = None,
             operation_type: Optional[str] = None,
             order_number: Optional[str] = None,
             partner_transaction_type: Optional[str] = None,
             pricing_model: Optional[str] = None,
             products: Optional[Sequence['outputs.GetSubscriptionsSubscriptionSubscribedServiceProductResult']] = None,
             program_type: Optional[str] = None,
             promo_type: Optional[str] = None,
             quantity: Optional[str] = None,
             status: Optional[str] = None,
             term_value: Optional[str] = None,
             term_value_uom: Optional[str] = None,
             time_end: Optional[str] = None,
             time_start: Optional[str] = None,
             total_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if booking_opty_number is None and 'bookingOptyNumber' in kwargs:
            booking_opty_number = kwargs['bookingOptyNumber']
        if booking_opty_number is None:
            raise TypeError("Missing 'booking_opty_number' argument")
        if commitment_services is None and 'commitmentServices' in kwargs:
            commitment_services = kwargs['commitmentServices']
        if commitment_services is None:
            raise TypeError("Missing 'commitment_services' argument")
        if csi is None:
            raise TypeError("Missing 'csi' argument")
        if data_center_region is None and 'dataCenterRegion' in kwargs:
            data_center_region = kwargs['dataCenterRegion']
        if data_center_region is None:
            raise TypeError("Missing 'data_center_region' argument")
        if funded_allocation_value is None and 'fundedAllocationValue' in kwargs:
            funded_allocation_value = kwargs['fundedAllocationValue']
        if funded_allocation_value is None:
            raise TypeError("Missing 'funded_allocation_value' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_intent_to_pay is None and 'isIntentToPay' in kwargs:
            is_intent_to_pay = kwargs['isIntentToPay']
        if is_intent_to_pay is None:
            raise TypeError("Missing 'is_intent_to_pay' argument")
        if net_unit_price is None and 'netUnitPrice' in kwargs:
            net_unit_price = kwargs['netUnitPrice']
        if net_unit_price is None:
            raise TypeError("Missing 'net_unit_price' argument")
        if operation_type is None and 'operationType' in kwargs:
            operation_type = kwargs['operationType']
        if operation_type is None:
            raise TypeError("Missing 'operation_type' argument")
        if order_number is None and 'orderNumber' in kwargs:
            order_number = kwargs['orderNumber']
        if order_number is None:
            raise TypeError("Missing 'order_number' argument")
        if partner_transaction_type is None and 'partnerTransactionType' in kwargs:
            partner_transaction_type = kwargs['partnerTransactionType']
        if partner_transaction_type is None:
            raise TypeError("Missing 'partner_transaction_type' argument")
        if pricing_model is None and 'pricingModel' in kwargs:
            pricing_model = kwargs['pricingModel']
        if pricing_model is None:
            raise TypeError("Missing 'pricing_model' argument")
        if products is None:
            raise TypeError("Missing 'products' argument")
        if program_type is None and 'programType' in kwargs:
            program_type = kwargs['programType']
        if program_type is None:
            raise TypeError("Missing 'program_type' argument")
        if promo_type is None and 'promoType' in kwargs:
            promo_type = kwargs['promoType']
        if promo_type is None:
            raise TypeError("Missing 'promo_type' argument")
        if quantity is None:
            raise TypeError("Missing 'quantity' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if term_value is None and 'termValue' in kwargs:
            term_value = kwargs['termValue']
        if term_value is None:
            raise TypeError("Missing 'term_value' argument")
        if term_value_uom is None and 'termValueUom' in kwargs:
            term_value_uom = kwargs['termValueUom']
        if term_value_uom is None:
            raise TypeError("Missing 'term_value_uom' argument")
        if time_end is None and 'timeEnd' in kwargs:
            time_end = kwargs['timeEnd']
        if time_end is None:
            raise TypeError("Missing 'time_end' argument")
        if time_start is None and 'timeStart' in kwargs:
            time_start = kwargs['timeStart']
        if time_start is None:
            raise TypeError("Missing 'time_start' argument")
        if total_value is None and 'totalValue' in kwargs:
            total_value = kwargs['totalValue']
        if total_value is None:
            raise TypeError("Missing 'total_value' argument")

        _setter("booking_opty_number", booking_opty_number)
        _setter("commitment_services", commitment_services)
        _setter("csi", csi)
        _setter("data_center_region", data_center_region)
        _setter("funded_allocation_value", funded_allocation_value)
        _setter("id", id)
        _setter("is_intent_to_pay", is_intent_to_pay)
        _setter("net_unit_price", net_unit_price)
        _setter("operation_type", operation_type)
        _setter("order_number", order_number)
        _setter("partner_transaction_type", partner_transaction_type)
        _setter("pricing_model", pricing_model)
        _setter("products", products)
        _setter("program_type", program_type)
        _setter("promo_type", promo_type)
        _setter("quantity", quantity)
        _setter("status", status)
        _setter("term_value", term_value)
        _setter("term_value_uom", term_value_uom)
        _setter("time_end", time_end)
        _setter("time_start", time_start)
        _setter("total_value", total_value)

    @property
    @pulumi.getter(name="bookingOptyNumber")
    def booking_opty_number(self) -> str:
        """
        Booking Opportunity Number of Subscribed Service
        """
        return pulumi.get(self, "booking_opty_number")

    @property
    @pulumi.getter(name="commitmentServices")
    def commitment_services(self) -> Sequence['outputs.GetSubscriptionsSubscriptionSubscribedServiceCommitmentServiceResult']:
        """
        List of Commitment services of a line
        """
        return pulumi.get(self, "commitment_services")

    @property
    @pulumi.getter
    def csi(self) -> str:
        """
        Subscribed service CSI number
        """
        return pulumi.get(self, "csi")

    @property
    @pulumi.getter(name="dataCenterRegion")
    def data_center_region(self) -> str:
        """
        Subscribed service data center region
        """
        return pulumi.get(self, "data_center_region")

    @property
    @pulumi.getter(name="fundedAllocationValue")
    def funded_allocation_value(self) -> str:
        """
        Funded Allocation line value example: 12000.00
        """
        return pulumi.get(self, "funded_allocation_value")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        SPM internal Subscribed Service ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isIntentToPay")
    def is_intent_to_pay(self) -> bool:
        """
        Subscribed service intent to pay flag
        """
        return pulumi.get(self, "is_intent_to_pay")

    @property
    @pulumi.getter(name="netUnitPrice")
    def net_unit_price(self) -> str:
        """
        Subscribed service net unit price
        """
        return pulumi.get(self, "net_unit_price")

    @property
    @pulumi.getter(name="operationType")
    def operation_type(self) -> str:
        """
        Subscribed service operation type
        """
        return pulumi.get(self, "operation_type")

    @property
    @pulumi.getter(name="orderNumber")
    def order_number(self) -> str:
        """
        Sales Order Number associated to the subscribed service
        """
        return pulumi.get(self, "order_number")

    @property
    @pulumi.getter(name="partnerTransactionType")
    def partner_transaction_type(self) -> str:
        """
        This field contains the name of the partner to which the subscription belongs - depending on which the invoicing may differ
        """
        return pulumi.get(self, "partner_transaction_type")

    @property
    @pulumi.getter(name="pricingModel")
    def pricing_model(self) -> str:
        """
        Subscribed service pricing model
        """
        return pulumi.get(self, "pricing_model")

    @property
    @pulumi.getter
    def products(self) -> Sequence['outputs.GetSubscriptionsSubscriptionSubscribedServiceProductResult']:
        """
        Product description
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="programType")
    def program_type(self) -> str:
        """
        Subscribed service program type
        """
        return pulumi.get(self, "program_type")

    @property
    @pulumi.getter(name="promoType")
    def promo_type(self) -> str:
        """
        Subscribed service promotion type
        """
        return pulumi.get(self, "promo_type")

    @property
    @pulumi.getter
    def quantity(self) -> str:
        """
        Subscribed service quantity
        """
        return pulumi.get(self, "quantity")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Subscribed service status
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="termValue")
    def term_value(self) -> str:
        """
        Term value in Months
        """
        return pulumi.get(self, "term_value")

    @property
    @pulumi.getter(name="termValueUom")
    def term_value_uom(self) -> str:
        """
        Term value UOM
        """
        return pulumi.get(self, "term_value_uom")

    @property
    @pulumi.getter(name="timeEnd")
    def time_end(self) -> str:
        """
        Represents the date when the last service of the subscription ends
        """
        return pulumi.get(self, "time_end")

    @property
    @pulumi.getter(name="timeStart")
    def time_start(self) -> str:
        """
        Represents the date when the first service of the subscription was activated
        """
        return pulumi.get(self, "time_start")

    @property
    @pulumi.getter(name="totalValue")
    def total_value(self) -> str:
        """
        Subscribed service total value
        """
        return pulumi.get(self, "total_value")


@pulumi.output_type
class GetSubscriptionsSubscriptionSubscribedServiceCommitmentServiceResult(dict):
    def __init__(__self__, *,
                 available_amount: str,
                 funded_allocation_value: str,
                 line_net_amount: str,
                 quantity: str,
                 time_end: str,
                 time_start: str):
        """
        :param str available_amount: Commitment available amount
        :param str funded_allocation_value: Funded Allocation line value example: 12000.00
        :param str line_net_amount: Commitment line net amount
        :param str quantity: Subscribed service quantity
        :param str time_end: Represents the date when the last service of the subscription ends
        :param str time_start: Represents the date when the first service of the subscription was activated
        """
        GetSubscriptionsSubscriptionSubscribedServiceCommitmentServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_amount=available_amount,
            funded_allocation_value=funded_allocation_value,
            line_net_amount=line_net_amount,
            quantity=quantity,
            time_end=time_end,
            time_start=time_start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_amount: Optional[str] = None,
             funded_allocation_value: Optional[str] = None,
             line_net_amount: Optional[str] = None,
             quantity: Optional[str] = None,
             time_end: Optional[str] = None,
             time_start: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if available_amount is None and 'availableAmount' in kwargs:
            available_amount = kwargs['availableAmount']
        if available_amount is None:
            raise TypeError("Missing 'available_amount' argument")
        if funded_allocation_value is None and 'fundedAllocationValue' in kwargs:
            funded_allocation_value = kwargs['fundedAllocationValue']
        if funded_allocation_value is None:
            raise TypeError("Missing 'funded_allocation_value' argument")
        if line_net_amount is None and 'lineNetAmount' in kwargs:
            line_net_amount = kwargs['lineNetAmount']
        if line_net_amount is None:
            raise TypeError("Missing 'line_net_amount' argument")
        if quantity is None:
            raise TypeError("Missing 'quantity' argument")
        if time_end is None and 'timeEnd' in kwargs:
            time_end = kwargs['timeEnd']
        if time_end is None:
            raise TypeError("Missing 'time_end' argument")
        if time_start is None and 'timeStart' in kwargs:
            time_start = kwargs['timeStart']
        if time_start is None:
            raise TypeError("Missing 'time_start' argument")

        _setter("available_amount", available_amount)
        _setter("funded_allocation_value", funded_allocation_value)
        _setter("line_net_amount", line_net_amount)
        _setter("quantity", quantity)
        _setter("time_end", time_end)
        _setter("time_start", time_start)

    @property
    @pulumi.getter(name="availableAmount")
    def available_amount(self) -> str:
        """
        Commitment available amount
        """
        return pulumi.get(self, "available_amount")

    @property
    @pulumi.getter(name="fundedAllocationValue")
    def funded_allocation_value(self) -> str:
        """
        Funded Allocation line value example: 12000.00
        """
        return pulumi.get(self, "funded_allocation_value")

    @property
    @pulumi.getter(name="lineNetAmount")
    def line_net_amount(self) -> str:
        """
        Commitment line net amount
        """
        return pulumi.get(self, "line_net_amount")

    @property
    @pulumi.getter
    def quantity(self) -> str:
        """
        Subscribed service quantity
        """
        return pulumi.get(self, "quantity")

    @property
    @pulumi.getter(name="timeEnd")
    def time_end(self) -> str:
        """
        Represents the date when the last service of the subscription ends
        """
        return pulumi.get(self, "time_end")

    @property
    @pulumi.getter(name="timeStart")
    def time_start(self) -> str:
        """
        Represents the date when the first service of the subscription was activated
        """
        return pulumi.get(self, "time_start")


@pulumi.output_type
class GetSubscriptionsSubscriptionSubscribedServiceProductResult(dict):
    def __init__(__self__, *,
                 name: str,
                 part_number: str,
                 provisioning_group: str,
                 unit_of_measure: str):
        """
        :param str name: Product name
        :param str part_number: Product part numner
        :param str provisioning_group: Product provisioning group
        :param str unit_of_measure: Unit of measure
        """
        GetSubscriptionsSubscriptionSubscribedServiceProductResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            part_number=part_number,
            provisioning_group=provisioning_group,
            unit_of_measure=unit_of_measure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             part_number: Optional[str] = None,
             provisioning_group: Optional[str] = None,
             unit_of_measure: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if part_number is None and 'partNumber' in kwargs:
            part_number = kwargs['partNumber']
        if part_number is None:
            raise TypeError("Missing 'part_number' argument")
        if provisioning_group is None and 'provisioningGroup' in kwargs:
            provisioning_group = kwargs['provisioningGroup']
        if provisioning_group is None:
            raise TypeError("Missing 'provisioning_group' argument")
        if unit_of_measure is None and 'unitOfMeasure' in kwargs:
            unit_of_measure = kwargs['unitOfMeasure']
        if unit_of_measure is None:
            raise TypeError("Missing 'unit_of_measure' argument")

        _setter("name", name)
        _setter("part_number", part_number)
        _setter("provisioning_group", provisioning_group)
        _setter("unit_of_measure", unit_of_measure)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="partNumber")
    def part_number(self) -> str:
        """
        Product part numner
        """
        return pulumi.get(self, "part_number")

    @property
    @pulumi.getter(name="provisioningGroup")
    def provisioning_group(self) -> str:
        """
        Product provisioning group
        """
        return pulumi.get(self, "provisioning_group")

    @property
    @pulumi.getter(name="unitOfMeasure")
    def unit_of_measure(self) -> str:
        """
        Unit of measure
        """
        return pulumi.get(self, "unit_of_measure")


