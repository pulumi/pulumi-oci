# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'GetCommitmentAggregatedsComputedUsageAggregatedResult',
    'GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageResult',
    'GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageProductResult',
    'GetCommitmentAggregatedsComputedUsageAggregatedParentProductResult',
    'GetCommitmentAggregatedsFilterResult',
    'GetComputedUsageParentProductResult',
    'GetComputedUsageProductResult',
    'GetComputedUsagesComputedUsageResult',
    'GetComputedUsagesComputedUsageParentProductResult',
    'GetComputedUsagesComputedUsageProductResult',
    'GetComputedUsagesFilterResult',
]

@pulumi.output_type
class GetCommitmentAggregatedsComputedUsageAggregatedResult(dict):
    def __init__(__self__, *,
                 aggregated_computed_usages: Sequence['outputs.GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageResult'],
                 currency_code: str,
                 parent_products: Sequence['outputs.GetCommitmentAggregatedsComputedUsageAggregatedParentProductResult'],
                 parent_subscribed_service_id: str,
                 plan_number: str,
                 pricing_model: str,
                 rate_card_id: str,
                 subscription_id: str,
                 time_end: str,
                 time_start: str):
        """
        :param Sequence['GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageArgs'] aggregated_computed_usages: Aggregation of computed usages for the subscribed service.
        :param str currency_code: Currency code
        :param Sequence['GetCommitmentAggregatedsComputedUsageAggregatedParentProductArgs'] parent_products: Product part number for subscribed service line, called parent product.
        :param str parent_subscribed_service_id: Subscribed service line parent id
        :param str plan_number: Subscribed service asociated subscription plan number.
        :param str pricing_model: Subscribed services pricing model
        :param str rate_card_id: Inernal SPM Ratecard Id at line level
        :param str subscription_id: Subscription Id is an identifier associated to the service used for filter the Computed Usage in SPM.
        :param str time_end: Subscribed services contract line end date, expressed in RFC 3339 timestamp format.
        :param str time_start: Subscribed services contract line start date, expressed in RFC 3339 timestamp format.
        """
        GetCommitmentAggregatedsComputedUsageAggregatedResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregated_computed_usages=aggregated_computed_usages,
            currency_code=currency_code,
            parent_products=parent_products,
            parent_subscribed_service_id=parent_subscribed_service_id,
            plan_number=plan_number,
            pricing_model=pricing_model,
            rate_card_id=rate_card_id,
            subscription_id=subscription_id,
            time_end=time_end,
            time_start=time_start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregated_computed_usages: Optional[Sequence['outputs.GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageResult']] = None,
             currency_code: Optional[str] = None,
             parent_products: Optional[Sequence['outputs.GetCommitmentAggregatedsComputedUsageAggregatedParentProductResult']] = None,
             parent_subscribed_service_id: Optional[str] = None,
             plan_number: Optional[str] = None,
             pricing_model: Optional[str] = None,
             rate_card_id: Optional[str] = None,
             subscription_id: Optional[str] = None,
             time_end: Optional[str] = None,
             time_start: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aggregated_computed_usages is None and 'aggregatedComputedUsages' in kwargs:
            aggregated_computed_usages = kwargs['aggregatedComputedUsages']
        if aggregated_computed_usages is None:
            raise TypeError("Missing 'aggregated_computed_usages' argument")
        if currency_code is None and 'currencyCode' in kwargs:
            currency_code = kwargs['currencyCode']
        if currency_code is None:
            raise TypeError("Missing 'currency_code' argument")
        if parent_products is None and 'parentProducts' in kwargs:
            parent_products = kwargs['parentProducts']
        if parent_products is None:
            raise TypeError("Missing 'parent_products' argument")
        if parent_subscribed_service_id is None and 'parentSubscribedServiceId' in kwargs:
            parent_subscribed_service_id = kwargs['parentSubscribedServiceId']
        if parent_subscribed_service_id is None:
            raise TypeError("Missing 'parent_subscribed_service_id' argument")
        if plan_number is None and 'planNumber' in kwargs:
            plan_number = kwargs['planNumber']
        if plan_number is None:
            raise TypeError("Missing 'plan_number' argument")
        if pricing_model is None and 'pricingModel' in kwargs:
            pricing_model = kwargs['pricingModel']
        if pricing_model is None:
            raise TypeError("Missing 'pricing_model' argument")
        if rate_card_id is None and 'rateCardId' in kwargs:
            rate_card_id = kwargs['rateCardId']
        if rate_card_id is None:
            raise TypeError("Missing 'rate_card_id' argument")
        if subscription_id is None and 'subscriptionId' in kwargs:
            subscription_id = kwargs['subscriptionId']
        if subscription_id is None:
            raise TypeError("Missing 'subscription_id' argument")
        if time_end is None and 'timeEnd' in kwargs:
            time_end = kwargs['timeEnd']
        if time_end is None:
            raise TypeError("Missing 'time_end' argument")
        if time_start is None and 'timeStart' in kwargs:
            time_start = kwargs['timeStart']
        if time_start is None:
            raise TypeError("Missing 'time_start' argument")

        _setter("aggregated_computed_usages", aggregated_computed_usages)
        _setter("currency_code", currency_code)
        _setter("parent_products", parent_products)
        _setter("parent_subscribed_service_id", parent_subscribed_service_id)
        _setter("plan_number", plan_number)
        _setter("pricing_model", pricing_model)
        _setter("rate_card_id", rate_card_id)
        _setter("subscription_id", subscription_id)
        _setter("time_end", time_end)
        _setter("time_start", time_start)

    @property
    @pulumi.getter(name="aggregatedComputedUsages")
    def aggregated_computed_usages(self) -> Sequence['outputs.GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageResult']:
        """
        Aggregation of computed usages for the subscribed service.
        """
        return pulumi.get(self, "aggregated_computed_usages")

    @property
    @pulumi.getter(name="currencyCode")
    def currency_code(self) -> str:
        """
        Currency code
        """
        return pulumi.get(self, "currency_code")

    @property
    @pulumi.getter(name="parentProducts")
    def parent_products(self) -> Sequence['outputs.GetCommitmentAggregatedsComputedUsageAggregatedParentProductResult']:
        """
        Product part number for subscribed service line, called parent product.
        """
        return pulumi.get(self, "parent_products")

    @property
    @pulumi.getter(name="parentSubscribedServiceId")
    def parent_subscribed_service_id(self) -> str:
        """
        Subscribed service line parent id
        """
        return pulumi.get(self, "parent_subscribed_service_id")

    @property
    @pulumi.getter(name="planNumber")
    def plan_number(self) -> str:
        """
        Subscribed service asociated subscription plan number.
        """
        return pulumi.get(self, "plan_number")

    @property
    @pulumi.getter(name="pricingModel")
    def pricing_model(self) -> str:
        """
        Subscribed services pricing model
        """
        return pulumi.get(self, "pricing_model")

    @property
    @pulumi.getter(name="rateCardId")
    def rate_card_id(self) -> str:
        """
        Inernal SPM Ratecard Id at line level
        """
        return pulumi.get(self, "rate_card_id")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        Subscription Id is an identifier associated to the service used for filter the Computed Usage in SPM.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="timeEnd")
    def time_end(self) -> str:
        """
        Subscribed services contract line end date, expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_end")

    @property
    @pulumi.getter(name="timeStart")
    def time_start(self) -> str:
        """
        Subscribed services contract line start date, expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_start")


@pulumi.output_type
class GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageResult(dict):
    def __init__(__self__, *,
                 cost: str,
                 cost_unrounded: str,
                 data_center: str,
                 net_unit_price: str,
                 products: Sequence['outputs.GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageProductResult'],
                 quantity: str,
                 time_metered_on: str,
                 type: str):
        """
        :param str cost: Sum of Computed Line Amount rounded
        :param str cost_unrounded: Sum of Computed Line Amount unrounded
        :param str data_center: Data Center Attribute as sent by MQS to SPM.
        :param str net_unit_price: Net Unit Price for the product in consideration.
        :param Sequence['GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageProductArgs'] products: Product description
        :param str quantity: Total Quantity that was used for computation
        :param str time_metered_on: Metered Service date , expressed in RFC 3339 timestamp format.
        :param str type: Usage compute type in SPM.
        """
        GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cost=cost,
            cost_unrounded=cost_unrounded,
            data_center=data_center,
            net_unit_price=net_unit_price,
            products=products,
            quantity=quantity,
            time_metered_on=time_metered_on,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cost: Optional[str] = None,
             cost_unrounded: Optional[str] = None,
             data_center: Optional[str] = None,
             net_unit_price: Optional[str] = None,
             products: Optional[Sequence['outputs.GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageProductResult']] = None,
             quantity: Optional[str] = None,
             time_metered_on: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cost is None:
            raise TypeError("Missing 'cost' argument")
        if cost_unrounded is None and 'costUnrounded' in kwargs:
            cost_unrounded = kwargs['costUnrounded']
        if cost_unrounded is None:
            raise TypeError("Missing 'cost_unrounded' argument")
        if data_center is None and 'dataCenter' in kwargs:
            data_center = kwargs['dataCenter']
        if data_center is None:
            raise TypeError("Missing 'data_center' argument")
        if net_unit_price is None and 'netUnitPrice' in kwargs:
            net_unit_price = kwargs['netUnitPrice']
        if net_unit_price is None:
            raise TypeError("Missing 'net_unit_price' argument")
        if products is None:
            raise TypeError("Missing 'products' argument")
        if quantity is None:
            raise TypeError("Missing 'quantity' argument")
        if time_metered_on is None and 'timeMeteredOn' in kwargs:
            time_metered_on = kwargs['timeMeteredOn']
        if time_metered_on is None:
            raise TypeError("Missing 'time_metered_on' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("cost", cost)
        _setter("cost_unrounded", cost_unrounded)
        _setter("data_center", data_center)
        _setter("net_unit_price", net_unit_price)
        _setter("products", products)
        _setter("quantity", quantity)
        _setter("time_metered_on", time_metered_on)
        _setter("type", type)

    @property
    @pulumi.getter
    def cost(self) -> str:
        """
        Sum of Computed Line Amount rounded
        """
        return pulumi.get(self, "cost")

    @property
    @pulumi.getter(name="costUnrounded")
    def cost_unrounded(self) -> str:
        """
        Sum of Computed Line Amount unrounded
        """
        return pulumi.get(self, "cost_unrounded")

    @property
    @pulumi.getter(name="dataCenter")
    def data_center(self) -> str:
        """
        Data Center Attribute as sent by MQS to SPM.
        """
        return pulumi.get(self, "data_center")

    @property
    @pulumi.getter(name="netUnitPrice")
    def net_unit_price(self) -> str:
        """
        Net Unit Price for the product in consideration.
        """
        return pulumi.get(self, "net_unit_price")

    @property
    @pulumi.getter
    def products(self) -> Sequence['outputs.GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageProductResult']:
        """
        Product description
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter
    def quantity(self) -> str:
        """
        Total Quantity that was used for computation
        """
        return pulumi.get(self, "quantity")

    @property
    @pulumi.getter(name="timeMeteredOn")
    def time_metered_on(self) -> str:
        """
        Metered Service date , expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_metered_on")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Usage compute type in SPM.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageProductResult(dict):
    def __init__(__self__, *,
                 billing_category: str,
                 name: str,
                 part_number: str,
                 product_category: str,
                 provisioning_group: str,
                 ucm_rate_card_part_type: str,
                 unit_of_measure: str):
        """
        :param str billing_category: Metered service billing category
        :param str name: Product name
        :param str part_number: Product part number
        :param str product_category: Product category
        :param str provisioning_group: Product provisioning group
        :param str ucm_rate_card_part_type: Rate card part type of Product
        :param str unit_of_measure: Unit of Measure
        """
        GetCommitmentAggregatedsComputedUsageAggregatedAggregatedComputedUsageProductResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            billing_category=billing_category,
            name=name,
            part_number=part_number,
            product_category=product_category,
            provisioning_group=provisioning_group,
            ucm_rate_card_part_type=ucm_rate_card_part_type,
            unit_of_measure=unit_of_measure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             billing_category: Optional[str] = None,
             name: Optional[str] = None,
             part_number: Optional[str] = None,
             product_category: Optional[str] = None,
             provisioning_group: Optional[str] = None,
             ucm_rate_card_part_type: Optional[str] = None,
             unit_of_measure: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if billing_category is None and 'billingCategory' in kwargs:
            billing_category = kwargs['billingCategory']
        if billing_category is None:
            raise TypeError("Missing 'billing_category' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if part_number is None and 'partNumber' in kwargs:
            part_number = kwargs['partNumber']
        if part_number is None:
            raise TypeError("Missing 'part_number' argument")
        if product_category is None and 'productCategory' in kwargs:
            product_category = kwargs['productCategory']
        if product_category is None:
            raise TypeError("Missing 'product_category' argument")
        if provisioning_group is None and 'provisioningGroup' in kwargs:
            provisioning_group = kwargs['provisioningGroup']
        if provisioning_group is None:
            raise TypeError("Missing 'provisioning_group' argument")
        if ucm_rate_card_part_type is None and 'ucmRateCardPartType' in kwargs:
            ucm_rate_card_part_type = kwargs['ucmRateCardPartType']
        if ucm_rate_card_part_type is None:
            raise TypeError("Missing 'ucm_rate_card_part_type' argument")
        if unit_of_measure is None and 'unitOfMeasure' in kwargs:
            unit_of_measure = kwargs['unitOfMeasure']
        if unit_of_measure is None:
            raise TypeError("Missing 'unit_of_measure' argument")

        _setter("billing_category", billing_category)
        _setter("name", name)
        _setter("part_number", part_number)
        _setter("product_category", product_category)
        _setter("provisioning_group", provisioning_group)
        _setter("ucm_rate_card_part_type", ucm_rate_card_part_type)
        _setter("unit_of_measure", unit_of_measure)

    @property
    @pulumi.getter(name="billingCategory")
    def billing_category(self) -> str:
        """
        Metered service billing category
        """
        return pulumi.get(self, "billing_category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="partNumber")
    def part_number(self) -> str:
        """
        Product part number
        """
        return pulumi.get(self, "part_number")

    @property
    @pulumi.getter(name="productCategory")
    def product_category(self) -> str:
        """
        Product category
        """
        return pulumi.get(self, "product_category")

    @property
    @pulumi.getter(name="provisioningGroup")
    def provisioning_group(self) -> str:
        """
        Product provisioning group
        """
        return pulumi.get(self, "provisioning_group")

    @property
    @pulumi.getter(name="ucmRateCardPartType")
    def ucm_rate_card_part_type(self) -> str:
        """
        Rate card part type of Product
        """
        return pulumi.get(self, "ucm_rate_card_part_type")

    @property
    @pulumi.getter(name="unitOfMeasure")
    def unit_of_measure(self) -> str:
        """
        Unit of Measure
        """
        return pulumi.get(self, "unit_of_measure")


@pulumi.output_type
class GetCommitmentAggregatedsComputedUsageAggregatedParentProductResult(dict):
    def __init__(__self__, *,
                 billing_category: str,
                 name: str,
                 part_number: str,
                 product_category: str,
                 provisioning_group: str,
                 ucm_rate_card_part_type: str,
                 unit_of_measure: str):
        """
        :param str billing_category: Metered service billing category
        :param str name: Product name
        :param str part_number: Product part number
        :param str product_category: Product category
        :param str provisioning_group: Product provisioning group
        :param str ucm_rate_card_part_type: Rate card part type of Product
        :param str unit_of_measure: Unit of Measure
        """
        GetCommitmentAggregatedsComputedUsageAggregatedParentProductResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            billing_category=billing_category,
            name=name,
            part_number=part_number,
            product_category=product_category,
            provisioning_group=provisioning_group,
            ucm_rate_card_part_type=ucm_rate_card_part_type,
            unit_of_measure=unit_of_measure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             billing_category: Optional[str] = None,
             name: Optional[str] = None,
             part_number: Optional[str] = None,
             product_category: Optional[str] = None,
             provisioning_group: Optional[str] = None,
             ucm_rate_card_part_type: Optional[str] = None,
             unit_of_measure: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if billing_category is None and 'billingCategory' in kwargs:
            billing_category = kwargs['billingCategory']
        if billing_category is None:
            raise TypeError("Missing 'billing_category' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if part_number is None and 'partNumber' in kwargs:
            part_number = kwargs['partNumber']
        if part_number is None:
            raise TypeError("Missing 'part_number' argument")
        if product_category is None and 'productCategory' in kwargs:
            product_category = kwargs['productCategory']
        if product_category is None:
            raise TypeError("Missing 'product_category' argument")
        if provisioning_group is None and 'provisioningGroup' in kwargs:
            provisioning_group = kwargs['provisioningGroup']
        if provisioning_group is None:
            raise TypeError("Missing 'provisioning_group' argument")
        if ucm_rate_card_part_type is None and 'ucmRateCardPartType' in kwargs:
            ucm_rate_card_part_type = kwargs['ucmRateCardPartType']
        if ucm_rate_card_part_type is None:
            raise TypeError("Missing 'ucm_rate_card_part_type' argument")
        if unit_of_measure is None and 'unitOfMeasure' in kwargs:
            unit_of_measure = kwargs['unitOfMeasure']
        if unit_of_measure is None:
            raise TypeError("Missing 'unit_of_measure' argument")

        _setter("billing_category", billing_category)
        _setter("name", name)
        _setter("part_number", part_number)
        _setter("product_category", product_category)
        _setter("provisioning_group", provisioning_group)
        _setter("ucm_rate_card_part_type", ucm_rate_card_part_type)
        _setter("unit_of_measure", unit_of_measure)

    @property
    @pulumi.getter(name="billingCategory")
    def billing_category(self) -> str:
        """
        Metered service billing category
        """
        return pulumi.get(self, "billing_category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="partNumber")
    def part_number(self) -> str:
        """
        Product part number
        """
        return pulumi.get(self, "part_number")

    @property
    @pulumi.getter(name="productCategory")
    def product_category(self) -> str:
        """
        Product category
        """
        return pulumi.get(self, "product_category")

    @property
    @pulumi.getter(name="provisioningGroup")
    def provisioning_group(self) -> str:
        """
        Product provisioning group
        """
        return pulumi.get(self, "provisioning_group")

    @property
    @pulumi.getter(name="ucmRateCardPartType")
    def ucm_rate_card_part_type(self) -> str:
        """
        Rate card part type of Product
        """
        return pulumi.get(self, "ucm_rate_card_part_type")

    @property
    @pulumi.getter(name="unitOfMeasure")
    def unit_of_measure(self) -> str:
        """
        Unit of Measure
        """
        return pulumi.get(self, "unit_of_measure")


@pulumi.output_type
class GetCommitmentAggregatedsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Product name
        """
        GetCommitmentAggregatedsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetComputedUsageParentProductResult(dict):
    def __init__(__self__, *,
                 billing_category: str,
                 name: str,
                 part_number: str,
                 product_category: str,
                 provisioning_group: str,
                 ucm_rate_card_part_type: str,
                 unit_of_measure: str):
        """
        :param str billing_category: Metered service billing category
        :param str name: Product name
        :param str part_number: Product part number
        :param str product_category: Product category
        :param str provisioning_group: Product provisioning group
        :param str ucm_rate_card_part_type: Rate card part type of Product
        :param str unit_of_measure: Unit of Messure
        """
        GetComputedUsageParentProductResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            billing_category=billing_category,
            name=name,
            part_number=part_number,
            product_category=product_category,
            provisioning_group=provisioning_group,
            ucm_rate_card_part_type=ucm_rate_card_part_type,
            unit_of_measure=unit_of_measure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             billing_category: Optional[str] = None,
             name: Optional[str] = None,
             part_number: Optional[str] = None,
             product_category: Optional[str] = None,
             provisioning_group: Optional[str] = None,
             ucm_rate_card_part_type: Optional[str] = None,
             unit_of_measure: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if billing_category is None and 'billingCategory' in kwargs:
            billing_category = kwargs['billingCategory']
        if billing_category is None:
            raise TypeError("Missing 'billing_category' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if part_number is None and 'partNumber' in kwargs:
            part_number = kwargs['partNumber']
        if part_number is None:
            raise TypeError("Missing 'part_number' argument")
        if product_category is None and 'productCategory' in kwargs:
            product_category = kwargs['productCategory']
        if product_category is None:
            raise TypeError("Missing 'product_category' argument")
        if provisioning_group is None and 'provisioningGroup' in kwargs:
            provisioning_group = kwargs['provisioningGroup']
        if provisioning_group is None:
            raise TypeError("Missing 'provisioning_group' argument")
        if ucm_rate_card_part_type is None and 'ucmRateCardPartType' in kwargs:
            ucm_rate_card_part_type = kwargs['ucmRateCardPartType']
        if ucm_rate_card_part_type is None:
            raise TypeError("Missing 'ucm_rate_card_part_type' argument")
        if unit_of_measure is None and 'unitOfMeasure' in kwargs:
            unit_of_measure = kwargs['unitOfMeasure']
        if unit_of_measure is None:
            raise TypeError("Missing 'unit_of_measure' argument")

        _setter("billing_category", billing_category)
        _setter("name", name)
        _setter("part_number", part_number)
        _setter("product_category", product_category)
        _setter("provisioning_group", provisioning_group)
        _setter("ucm_rate_card_part_type", ucm_rate_card_part_type)
        _setter("unit_of_measure", unit_of_measure)

    @property
    @pulumi.getter(name="billingCategory")
    def billing_category(self) -> str:
        """
        Metered service billing category
        """
        return pulumi.get(self, "billing_category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="partNumber")
    def part_number(self) -> str:
        """
        Product part number
        """
        return pulumi.get(self, "part_number")

    @property
    @pulumi.getter(name="productCategory")
    def product_category(self) -> str:
        """
        Product category
        """
        return pulumi.get(self, "product_category")

    @property
    @pulumi.getter(name="provisioningGroup")
    def provisioning_group(self) -> str:
        """
        Product provisioning group
        """
        return pulumi.get(self, "provisioning_group")

    @property
    @pulumi.getter(name="ucmRateCardPartType")
    def ucm_rate_card_part_type(self) -> str:
        """
        Rate card part type of Product
        """
        return pulumi.get(self, "ucm_rate_card_part_type")

    @property
    @pulumi.getter(name="unitOfMeasure")
    def unit_of_measure(self) -> str:
        """
        Unit of Messure
        """
        return pulumi.get(self, "unit_of_measure")


@pulumi.output_type
class GetComputedUsageProductResult(dict):
    def __init__(__self__, *,
                 billing_category: str,
                 name: str,
                 part_number: str,
                 product_category: str,
                 provisioning_group: str,
                 ucm_rate_card_part_type: str,
                 unit_of_measure: str):
        """
        :param str billing_category: Metered service billing category
        :param str name: Product name
        :param str part_number: Product part number
        :param str product_category: Product category
        :param str provisioning_group: Product provisioning group
        :param str ucm_rate_card_part_type: Rate card part type of Product
        :param str unit_of_measure: Unit of Messure
        """
        GetComputedUsageProductResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            billing_category=billing_category,
            name=name,
            part_number=part_number,
            product_category=product_category,
            provisioning_group=provisioning_group,
            ucm_rate_card_part_type=ucm_rate_card_part_type,
            unit_of_measure=unit_of_measure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             billing_category: Optional[str] = None,
             name: Optional[str] = None,
             part_number: Optional[str] = None,
             product_category: Optional[str] = None,
             provisioning_group: Optional[str] = None,
             ucm_rate_card_part_type: Optional[str] = None,
             unit_of_measure: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if billing_category is None and 'billingCategory' in kwargs:
            billing_category = kwargs['billingCategory']
        if billing_category is None:
            raise TypeError("Missing 'billing_category' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if part_number is None and 'partNumber' in kwargs:
            part_number = kwargs['partNumber']
        if part_number is None:
            raise TypeError("Missing 'part_number' argument")
        if product_category is None and 'productCategory' in kwargs:
            product_category = kwargs['productCategory']
        if product_category is None:
            raise TypeError("Missing 'product_category' argument")
        if provisioning_group is None and 'provisioningGroup' in kwargs:
            provisioning_group = kwargs['provisioningGroup']
        if provisioning_group is None:
            raise TypeError("Missing 'provisioning_group' argument")
        if ucm_rate_card_part_type is None and 'ucmRateCardPartType' in kwargs:
            ucm_rate_card_part_type = kwargs['ucmRateCardPartType']
        if ucm_rate_card_part_type is None:
            raise TypeError("Missing 'ucm_rate_card_part_type' argument")
        if unit_of_measure is None and 'unitOfMeasure' in kwargs:
            unit_of_measure = kwargs['unitOfMeasure']
        if unit_of_measure is None:
            raise TypeError("Missing 'unit_of_measure' argument")

        _setter("billing_category", billing_category)
        _setter("name", name)
        _setter("part_number", part_number)
        _setter("product_category", product_category)
        _setter("provisioning_group", provisioning_group)
        _setter("ucm_rate_card_part_type", ucm_rate_card_part_type)
        _setter("unit_of_measure", unit_of_measure)

    @property
    @pulumi.getter(name="billingCategory")
    def billing_category(self) -> str:
        """
        Metered service billing category
        """
        return pulumi.get(self, "billing_category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="partNumber")
    def part_number(self) -> str:
        """
        Product part number
        """
        return pulumi.get(self, "part_number")

    @property
    @pulumi.getter(name="productCategory")
    def product_category(self) -> str:
        """
        Product category
        """
        return pulumi.get(self, "product_category")

    @property
    @pulumi.getter(name="provisioningGroup")
    def provisioning_group(self) -> str:
        """
        Product provisioning group
        """
        return pulumi.get(self, "provisioning_group")

    @property
    @pulumi.getter(name="ucmRateCardPartType")
    def ucm_rate_card_part_type(self) -> str:
        """
        Rate card part type of Product
        """
        return pulumi.get(self, "ucm_rate_card_part_type")

    @property
    @pulumi.getter(name="unitOfMeasure")
    def unit_of_measure(self) -> str:
        """
        Unit of Messure
        """
        return pulumi.get(self, "unit_of_measure")


@pulumi.output_type
class GetComputedUsagesComputedUsageResult(dict):
    def __init__(__self__, *,
                 commitment_service_id: str,
                 compute_source: str,
                 computed_usage_id: str,
                 cost: str,
                 cost_rounded: str,
                 currency_code: str,
                 data_center: str,
                 id: str,
                 is_invoiced: bool,
                 mqs_message_id: str,
                 net_unit_price: str,
                 original_usage_number: str,
                 parent_products: Sequence['outputs.GetComputedUsagesComputedUsageParentProductResult'],
                 parent_subscribed_service_id: str,
                 plan_number: str,
                 products: Sequence['outputs.GetComputedUsagesComputedUsageProductResult'],
                 quantity: str,
                 rate_card_id: str,
                 rate_card_tierd_id: str,
                 time_created: str,
                 time_metered_on: str,
                 time_of_arrival: str,
                 time_updated: str,
                 type: str,
                 unit_of_measure: str,
                 usage_number: str):
        """
        :param str commitment_service_id: Subscribed service commitmentId.
        :param str compute_source: SPM Internal compute records source .
        :param str cost: Computed Line Amount not rounded
        :param str cost_rounded: Computed Line Amount rounded.
        :param str currency_code: Currency code
        :param str data_center: Data Center Attribute as sent by MQS to SPM.
        :param str id: SPM Internal computed usage Id , 32 character string
        :param bool is_invoiced: Invoicing status for the aggregated compute usage
        :param str mqs_message_id: MQS Identfier send to SPM , SPM does not transform this attribute and is received as is.
        :param str net_unit_price: Net Unit Price for the product in consideration, price actual.
        :param str original_usage_number: SPM Internal Original usage Line number identifier in SPM coming from Metered Services entity.
        :param Sequence['GetComputedUsagesComputedUsageParentProductArgs'] parent_products: Product part number for subscribed service line, called parent product.
        :param str parent_subscribed_service_id: Subscribed service line parent id
        :param str plan_number: Subscription plan number
        :param Sequence['GetComputedUsagesComputedUsageProductArgs'] products: Product description
        :param str quantity: Total Quantity that was used for computation
        :param str rate_card_id: Ratecard Id at subscribed service level
        :param str rate_card_tierd_id: References the tier in the ratecard for that usage (OCI will be using the same reference to cross-reference for correctness on the usage csv report), comes from Entity OBSCNTR_IPT_PRODUCTTIER.
        :param str time_created: Computed Usage created time, expressed in RFC 3339 timestamp format.
        :param str time_metered_on: Metered Service date, expressed in RFC 3339 timestamp format.
        :param str time_of_arrival: Usae computation date, expressed in RFC 3339 timestamp format.
        :param str time_updated: Computed Usage updated time, expressed in RFC 3339 timestamp format.
        :param str type: Usage compute type in SPM.
        :param str unit_of_measure: Unit of Messure
        :param str usage_number: SPM Internal usage Line number identifier in SPM coming from Metered Services entity.
        """
        GetComputedUsagesComputedUsageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commitment_service_id=commitment_service_id,
            compute_source=compute_source,
            computed_usage_id=computed_usage_id,
            cost=cost,
            cost_rounded=cost_rounded,
            currency_code=currency_code,
            data_center=data_center,
            id=id,
            is_invoiced=is_invoiced,
            mqs_message_id=mqs_message_id,
            net_unit_price=net_unit_price,
            original_usage_number=original_usage_number,
            parent_products=parent_products,
            parent_subscribed_service_id=parent_subscribed_service_id,
            plan_number=plan_number,
            products=products,
            quantity=quantity,
            rate_card_id=rate_card_id,
            rate_card_tierd_id=rate_card_tierd_id,
            time_created=time_created,
            time_metered_on=time_metered_on,
            time_of_arrival=time_of_arrival,
            time_updated=time_updated,
            type=type,
            unit_of_measure=unit_of_measure,
            usage_number=usage_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commitment_service_id: Optional[str] = None,
             compute_source: Optional[str] = None,
             computed_usage_id: Optional[str] = None,
             cost: Optional[str] = None,
             cost_rounded: Optional[str] = None,
             currency_code: Optional[str] = None,
             data_center: Optional[str] = None,
             id: Optional[str] = None,
             is_invoiced: Optional[bool] = None,
             mqs_message_id: Optional[str] = None,
             net_unit_price: Optional[str] = None,
             original_usage_number: Optional[str] = None,
             parent_products: Optional[Sequence['outputs.GetComputedUsagesComputedUsageParentProductResult']] = None,
             parent_subscribed_service_id: Optional[str] = None,
             plan_number: Optional[str] = None,
             products: Optional[Sequence['outputs.GetComputedUsagesComputedUsageProductResult']] = None,
             quantity: Optional[str] = None,
             rate_card_id: Optional[str] = None,
             rate_card_tierd_id: Optional[str] = None,
             time_created: Optional[str] = None,
             time_metered_on: Optional[str] = None,
             time_of_arrival: Optional[str] = None,
             time_updated: Optional[str] = None,
             type: Optional[str] = None,
             unit_of_measure: Optional[str] = None,
             usage_number: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commitment_service_id is None and 'commitmentServiceId' in kwargs:
            commitment_service_id = kwargs['commitmentServiceId']
        if commitment_service_id is None:
            raise TypeError("Missing 'commitment_service_id' argument")
        if compute_source is None and 'computeSource' in kwargs:
            compute_source = kwargs['computeSource']
        if compute_source is None:
            raise TypeError("Missing 'compute_source' argument")
        if computed_usage_id is None and 'computedUsageId' in kwargs:
            computed_usage_id = kwargs['computedUsageId']
        if computed_usage_id is None:
            raise TypeError("Missing 'computed_usage_id' argument")
        if cost is None:
            raise TypeError("Missing 'cost' argument")
        if cost_rounded is None and 'costRounded' in kwargs:
            cost_rounded = kwargs['costRounded']
        if cost_rounded is None:
            raise TypeError("Missing 'cost_rounded' argument")
        if currency_code is None and 'currencyCode' in kwargs:
            currency_code = kwargs['currencyCode']
        if currency_code is None:
            raise TypeError("Missing 'currency_code' argument")
        if data_center is None and 'dataCenter' in kwargs:
            data_center = kwargs['dataCenter']
        if data_center is None:
            raise TypeError("Missing 'data_center' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_invoiced is None and 'isInvoiced' in kwargs:
            is_invoiced = kwargs['isInvoiced']
        if is_invoiced is None:
            raise TypeError("Missing 'is_invoiced' argument")
        if mqs_message_id is None and 'mqsMessageId' in kwargs:
            mqs_message_id = kwargs['mqsMessageId']
        if mqs_message_id is None:
            raise TypeError("Missing 'mqs_message_id' argument")
        if net_unit_price is None and 'netUnitPrice' in kwargs:
            net_unit_price = kwargs['netUnitPrice']
        if net_unit_price is None:
            raise TypeError("Missing 'net_unit_price' argument")
        if original_usage_number is None and 'originalUsageNumber' in kwargs:
            original_usage_number = kwargs['originalUsageNumber']
        if original_usage_number is None:
            raise TypeError("Missing 'original_usage_number' argument")
        if parent_products is None and 'parentProducts' in kwargs:
            parent_products = kwargs['parentProducts']
        if parent_products is None:
            raise TypeError("Missing 'parent_products' argument")
        if parent_subscribed_service_id is None and 'parentSubscribedServiceId' in kwargs:
            parent_subscribed_service_id = kwargs['parentSubscribedServiceId']
        if parent_subscribed_service_id is None:
            raise TypeError("Missing 'parent_subscribed_service_id' argument")
        if plan_number is None and 'planNumber' in kwargs:
            plan_number = kwargs['planNumber']
        if plan_number is None:
            raise TypeError("Missing 'plan_number' argument")
        if products is None:
            raise TypeError("Missing 'products' argument")
        if quantity is None:
            raise TypeError("Missing 'quantity' argument")
        if rate_card_id is None and 'rateCardId' in kwargs:
            rate_card_id = kwargs['rateCardId']
        if rate_card_id is None:
            raise TypeError("Missing 'rate_card_id' argument")
        if rate_card_tierd_id is None and 'rateCardTierdId' in kwargs:
            rate_card_tierd_id = kwargs['rateCardTierdId']
        if rate_card_tierd_id is None:
            raise TypeError("Missing 'rate_card_tierd_id' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_metered_on is None and 'timeMeteredOn' in kwargs:
            time_metered_on = kwargs['timeMeteredOn']
        if time_metered_on is None:
            raise TypeError("Missing 'time_metered_on' argument")
        if time_of_arrival is None and 'timeOfArrival' in kwargs:
            time_of_arrival = kwargs['timeOfArrival']
        if time_of_arrival is None:
            raise TypeError("Missing 'time_of_arrival' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if unit_of_measure is None and 'unitOfMeasure' in kwargs:
            unit_of_measure = kwargs['unitOfMeasure']
        if unit_of_measure is None:
            raise TypeError("Missing 'unit_of_measure' argument")
        if usage_number is None and 'usageNumber' in kwargs:
            usage_number = kwargs['usageNumber']
        if usage_number is None:
            raise TypeError("Missing 'usage_number' argument")

        _setter("commitment_service_id", commitment_service_id)
        _setter("compute_source", compute_source)
        _setter("computed_usage_id", computed_usage_id)
        _setter("cost", cost)
        _setter("cost_rounded", cost_rounded)
        _setter("currency_code", currency_code)
        _setter("data_center", data_center)
        _setter("id", id)
        _setter("is_invoiced", is_invoiced)
        _setter("mqs_message_id", mqs_message_id)
        _setter("net_unit_price", net_unit_price)
        _setter("original_usage_number", original_usage_number)
        _setter("parent_products", parent_products)
        _setter("parent_subscribed_service_id", parent_subscribed_service_id)
        _setter("plan_number", plan_number)
        _setter("products", products)
        _setter("quantity", quantity)
        _setter("rate_card_id", rate_card_id)
        _setter("rate_card_tierd_id", rate_card_tierd_id)
        _setter("time_created", time_created)
        _setter("time_metered_on", time_metered_on)
        _setter("time_of_arrival", time_of_arrival)
        _setter("time_updated", time_updated)
        _setter("type", type)
        _setter("unit_of_measure", unit_of_measure)
        _setter("usage_number", usage_number)

    @property
    @pulumi.getter(name="commitmentServiceId")
    def commitment_service_id(self) -> str:
        """
        Subscribed service commitmentId.
        """
        return pulumi.get(self, "commitment_service_id")

    @property
    @pulumi.getter(name="computeSource")
    def compute_source(self) -> str:
        """
        SPM Internal compute records source .
        """
        return pulumi.get(self, "compute_source")

    @property
    @pulumi.getter(name="computedUsageId")
    def computed_usage_id(self) -> str:
        return pulumi.get(self, "computed_usage_id")

    @property
    @pulumi.getter
    def cost(self) -> str:
        """
        Computed Line Amount not rounded
        """
        return pulumi.get(self, "cost")

    @property
    @pulumi.getter(name="costRounded")
    def cost_rounded(self) -> str:
        """
        Computed Line Amount rounded.
        """
        return pulumi.get(self, "cost_rounded")

    @property
    @pulumi.getter(name="currencyCode")
    def currency_code(self) -> str:
        """
        Currency code
        """
        return pulumi.get(self, "currency_code")

    @property
    @pulumi.getter(name="dataCenter")
    def data_center(self) -> str:
        """
        Data Center Attribute as sent by MQS to SPM.
        """
        return pulumi.get(self, "data_center")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        SPM Internal computed usage Id , 32 character string
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isInvoiced")
    def is_invoiced(self) -> bool:
        """
        Invoicing status for the aggregated compute usage
        """
        return pulumi.get(self, "is_invoiced")

    @property
    @pulumi.getter(name="mqsMessageId")
    def mqs_message_id(self) -> str:
        """
        MQS Identfier send to SPM , SPM does not transform this attribute and is received as is.
        """
        return pulumi.get(self, "mqs_message_id")

    @property
    @pulumi.getter(name="netUnitPrice")
    def net_unit_price(self) -> str:
        """
        Net Unit Price for the product in consideration, price actual.
        """
        return pulumi.get(self, "net_unit_price")

    @property
    @pulumi.getter(name="originalUsageNumber")
    def original_usage_number(self) -> str:
        """
        SPM Internal Original usage Line number identifier in SPM coming from Metered Services entity.
        """
        return pulumi.get(self, "original_usage_number")

    @property
    @pulumi.getter(name="parentProducts")
    def parent_products(self) -> Sequence['outputs.GetComputedUsagesComputedUsageParentProductResult']:
        """
        Product part number for subscribed service line, called parent product.
        """
        return pulumi.get(self, "parent_products")

    @property
    @pulumi.getter(name="parentSubscribedServiceId")
    def parent_subscribed_service_id(self) -> str:
        """
        Subscribed service line parent id
        """
        return pulumi.get(self, "parent_subscribed_service_id")

    @property
    @pulumi.getter(name="planNumber")
    def plan_number(self) -> str:
        """
        Subscription plan number
        """
        return pulumi.get(self, "plan_number")

    @property
    @pulumi.getter
    def products(self) -> Sequence['outputs.GetComputedUsagesComputedUsageProductResult']:
        """
        Product description
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter
    def quantity(self) -> str:
        """
        Total Quantity that was used for computation
        """
        return pulumi.get(self, "quantity")

    @property
    @pulumi.getter(name="rateCardId")
    def rate_card_id(self) -> str:
        """
        Ratecard Id at subscribed service level
        """
        return pulumi.get(self, "rate_card_id")

    @property
    @pulumi.getter(name="rateCardTierdId")
    def rate_card_tierd_id(self) -> str:
        """
        References the tier in the ratecard for that usage (OCI will be using the same reference to cross-reference for correctness on the usage csv report), comes from Entity OBSCNTR_IPT_PRODUCTTIER.
        """
        return pulumi.get(self, "rate_card_tierd_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        Computed Usage created time, expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeMeteredOn")
    def time_metered_on(self) -> str:
        """
        Metered Service date, expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_metered_on")

    @property
    @pulumi.getter(name="timeOfArrival")
    def time_of_arrival(self) -> str:
        """
        Usae computation date, expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_of_arrival")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        Computed Usage updated time, expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Usage compute type in SPM.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="unitOfMeasure")
    def unit_of_measure(self) -> str:
        """
        Unit of Messure
        """
        return pulumi.get(self, "unit_of_measure")

    @property
    @pulumi.getter(name="usageNumber")
    def usage_number(self) -> str:
        """
        SPM Internal usage Line number identifier in SPM coming from Metered Services entity.
        """
        return pulumi.get(self, "usage_number")


@pulumi.output_type
class GetComputedUsagesComputedUsageParentProductResult(dict):
    def __init__(__self__, *,
                 billing_category: str,
                 name: str,
                 part_number: str,
                 product_category: str,
                 provisioning_group: str,
                 ucm_rate_card_part_type: str,
                 unit_of_measure: str):
        """
        :param str billing_category: Metered service billing category
        :param str name: Product name
        :param str part_number: Product part number
        :param str product_category: Product category
        :param str provisioning_group: Product provisioning group
        :param str ucm_rate_card_part_type: Rate card part type of Product
        :param str unit_of_measure: Unit of Messure
        """
        GetComputedUsagesComputedUsageParentProductResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            billing_category=billing_category,
            name=name,
            part_number=part_number,
            product_category=product_category,
            provisioning_group=provisioning_group,
            ucm_rate_card_part_type=ucm_rate_card_part_type,
            unit_of_measure=unit_of_measure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             billing_category: Optional[str] = None,
             name: Optional[str] = None,
             part_number: Optional[str] = None,
             product_category: Optional[str] = None,
             provisioning_group: Optional[str] = None,
             ucm_rate_card_part_type: Optional[str] = None,
             unit_of_measure: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if billing_category is None and 'billingCategory' in kwargs:
            billing_category = kwargs['billingCategory']
        if billing_category is None:
            raise TypeError("Missing 'billing_category' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if part_number is None and 'partNumber' in kwargs:
            part_number = kwargs['partNumber']
        if part_number is None:
            raise TypeError("Missing 'part_number' argument")
        if product_category is None and 'productCategory' in kwargs:
            product_category = kwargs['productCategory']
        if product_category is None:
            raise TypeError("Missing 'product_category' argument")
        if provisioning_group is None and 'provisioningGroup' in kwargs:
            provisioning_group = kwargs['provisioningGroup']
        if provisioning_group is None:
            raise TypeError("Missing 'provisioning_group' argument")
        if ucm_rate_card_part_type is None and 'ucmRateCardPartType' in kwargs:
            ucm_rate_card_part_type = kwargs['ucmRateCardPartType']
        if ucm_rate_card_part_type is None:
            raise TypeError("Missing 'ucm_rate_card_part_type' argument")
        if unit_of_measure is None and 'unitOfMeasure' in kwargs:
            unit_of_measure = kwargs['unitOfMeasure']
        if unit_of_measure is None:
            raise TypeError("Missing 'unit_of_measure' argument")

        _setter("billing_category", billing_category)
        _setter("name", name)
        _setter("part_number", part_number)
        _setter("product_category", product_category)
        _setter("provisioning_group", provisioning_group)
        _setter("ucm_rate_card_part_type", ucm_rate_card_part_type)
        _setter("unit_of_measure", unit_of_measure)

    @property
    @pulumi.getter(name="billingCategory")
    def billing_category(self) -> str:
        """
        Metered service billing category
        """
        return pulumi.get(self, "billing_category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="partNumber")
    def part_number(self) -> str:
        """
        Product part number
        """
        return pulumi.get(self, "part_number")

    @property
    @pulumi.getter(name="productCategory")
    def product_category(self) -> str:
        """
        Product category
        """
        return pulumi.get(self, "product_category")

    @property
    @pulumi.getter(name="provisioningGroup")
    def provisioning_group(self) -> str:
        """
        Product provisioning group
        """
        return pulumi.get(self, "provisioning_group")

    @property
    @pulumi.getter(name="ucmRateCardPartType")
    def ucm_rate_card_part_type(self) -> str:
        """
        Rate card part type of Product
        """
        return pulumi.get(self, "ucm_rate_card_part_type")

    @property
    @pulumi.getter(name="unitOfMeasure")
    def unit_of_measure(self) -> str:
        """
        Unit of Messure
        """
        return pulumi.get(self, "unit_of_measure")


@pulumi.output_type
class GetComputedUsagesComputedUsageProductResult(dict):
    def __init__(__self__, *,
                 billing_category: str,
                 name: str,
                 part_number: str,
                 product_category: str,
                 provisioning_group: str,
                 ucm_rate_card_part_type: str,
                 unit_of_measure: str):
        """
        :param str billing_category: Metered service billing category
        :param str name: Product name
        :param str part_number: Product part number
        :param str product_category: Product category
        :param str provisioning_group: Product provisioning group
        :param str ucm_rate_card_part_type: Rate card part type of Product
        :param str unit_of_measure: Unit of Messure
        """
        GetComputedUsagesComputedUsageProductResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            billing_category=billing_category,
            name=name,
            part_number=part_number,
            product_category=product_category,
            provisioning_group=provisioning_group,
            ucm_rate_card_part_type=ucm_rate_card_part_type,
            unit_of_measure=unit_of_measure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             billing_category: Optional[str] = None,
             name: Optional[str] = None,
             part_number: Optional[str] = None,
             product_category: Optional[str] = None,
             provisioning_group: Optional[str] = None,
             ucm_rate_card_part_type: Optional[str] = None,
             unit_of_measure: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if billing_category is None and 'billingCategory' in kwargs:
            billing_category = kwargs['billingCategory']
        if billing_category is None:
            raise TypeError("Missing 'billing_category' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if part_number is None and 'partNumber' in kwargs:
            part_number = kwargs['partNumber']
        if part_number is None:
            raise TypeError("Missing 'part_number' argument")
        if product_category is None and 'productCategory' in kwargs:
            product_category = kwargs['productCategory']
        if product_category is None:
            raise TypeError("Missing 'product_category' argument")
        if provisioning_group is None and 'provisioningGroup' in kwargs:
            provisioning_group = kwargs['provisioningGroup']
        if provisioning_group is None:
            raise TypeError("Missing 'provisioning_group' argument")
        if ucm_rate_card_part_type is None and 'ucmRateCardPartType' in kwargs:
            ucm_rate_card_part_type = kwargs['ucmRateCardPartType']
        if ucm_rate_card_part_type is None:
            raise TypeError("Missing 'ucm_rate_card_part_type' argument")
        if unit_of_measure is None and 'unitOfMeasure' in kwargs:
            unit_of_measure = kwargs['unitOfMeasure']
        if unit_of_measure is None:
            raise TypeError("Missing 'unit_of_measure' argument")

        _setter("billing_category", billing_category)
        _setter("name", name)
        _setter("part_number", part_number)
        _setter("product_category", product_category)
        _setter("provisioning_group", provisioning_group)
        _setter("ucm_rate_card_part_type", ucm_rate_card_part_type)
        _setter("unit_of_measure", unit_of_measure)

    @property
    @pulumi.getter(name="billingCategory")
    def billing_category(self) -> str:
        """
        Metered service billing category
        """
        return pulumi.get(self, "billing_category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="partNumber")
    def part_number(self) -> str:
        """
        Product part number
        """
        return pulumi.get(self, "part_number")

    @property
    @pulumi.getter(name="productCategory")
    def product_category(self) -> str:
        """
        Product category
        """
        return pulumi.get(self, "product_category")

    @property
    @pulumi.getter(name="provisioningGroup")
    def provisioning_group(self) -> str:
        """
        Product provisioning group
        """
        return pulumi.get(self, "provisioning_group")

    @property
    @pulumi.getter(name="ucmRateCardPartType")
    def ucm_rate_card_part_type(self) -> str:
        """
        Rate card part type of Product
        """
        return pulumi.get(self, "ucm_rate_card_part_type")

    @property
    @pulumi.getter(name="unitOfMeasure")
    def unit_of_measure(self) -> str:
        """
        Unit of Messure
        """
        return pulumi.get(self, "unit_of_measure")


@pulumi.output_type
class GetComputedUsagesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Product name
        """
        GetComputedUsagesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Product name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


