# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'QueueCapabilityArgs',
    'QueueCapabilityArgsDict',
    'GetConsumerGroupsFilterArgs',
    'GetConsumerGroupsFilterArgsDict',
    'GetQueuesFilterArgs',
    'GetQueuesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class QueueCapabilityArgsDict(TypedDict):
        is_primary_consumer_group_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Specifies if the primary consumer group should be automatically enabled after adding the capability.
        """
        primary_consumer_group_dead_letter_queue_delivery_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The number of times a message can be delivered to a consumer before being moved to the dead letter queue.  A value of 0 indicates that the DLQ is not used. If the value isn't set, it will be using the value defined at the queue level.
        """
        primary_consumer_group_display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of the primary consumer group. If omitted, it will be named "Primary Consumer Group".
        """
        primary_consumer_group_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        The primary consumer group cannot have any filter hence this field will always be empty. An empty value means that all messages will be available in the primary consumer group.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of the capability. Could be CONSUMER_GROUPS and/or LARGE_MESSAGES
        """
elif False:
    QueueCapabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueCapabilityArgs:
    def __init__(__self__, *,
                 is_primary_consumer_group_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 primary_consumer_group_dead_letter_queue_delivery_count: Optional[pulumi.Input[_builtins.int]] = None,
                 primary_consumer_group_display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 primary_consumer_group_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_primary_consumer_group_enabled: (Updatable) Specifies if the primary consumer group should be automatically enabled after adding the capability.
        :param pulumi.Input[_builtins.int] primary_consumer_group_dead_letter_queue_delivery_count: (Updatable) The number of times a message can be delivered to a consumer before being moved to the dead letter queue.  A value of 0 indicates that the DLQ is not used. If the value isn't set, it will be using the value defined at the queue level.
        :param pulumi.Input[_builtins.str] primary_consumer_group_display_name: (Updatable) Name of the primary consumer group. If omitted, it will be named "Primary Consumer Group".
        :param pulumi.Input[_builtins.str] primary_consumer_group_filter: The primary consumer group cannot have any filter hence this field will always be empty. An empty value means that all messages will be available in the primary consumer group.
        :param pulumi.Input[_builtins.str] type: (Updatable) The type of the capability. Could be CONSUMER_GROUPS and/or LARGE_MESSAGES
        """
        if is_primary_consumer_group_enabled is not None:
            pulumi.set(__self__, "is_primary_consumer_group_enabled", is_primary_consumer_group_enabled)
        if primary_consumer_group_dead_letter_queue_delivery_count is not None:
            pulumi.set(__self__, "primary_consumer_group_dead_letter_queue_delivery_count", primary_consumer_group_dead_letter_queue_delivery_count)
        if primary_consumer_group_display_name is not None:
            pulumi.set(__self__, "primary_consumer_group_display_name", primary_consumer_group_display_name)
        if primary_consumer_group_filter is not None:
            pulumi.set(__self__, "primary_consumer_group_filter", primary_consumer_group_filter)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="isPrimaryConsumerGroupEnabled")
    def is_primary_consumer_group_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Specifies if the primary consumer group should be automatically enabled after adding the capability.
        """
        return pulumi.get(self, "is_primary_consumer_group_enabled")

    @is_primary_consumer_group_enabled.setter
    def is_primary_consumer_group_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_primary_consumer_group_enabled", value)

    @_builtins.property
    @pulumi.getter(name="primaryConsumerGroupDeadLetterQueueDeliveryCount")
    def primary_consumer_group_dead_letter_queue_delivery_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The number of times a message can be delivered to a consumer before being moved to the dead letter queue.  A value of 0 indicates that the DLQ is not used. If the value isn't set, it will be using the value defined at the queue level.
        """
        return pulumi.get(self, "primary_consumer_group_dead_letter_queue_delivery_count")

    @primary_consumer_group_dead_letter_queue_delivery_count.setter
    def primary_consumer_group_dead_letter_queue_delivery_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "primary_consumer_group_dead_letter_queue_delivery_count", value)

    @_builtins.property
    @pulumi.getter(name="primaryConsumerGroupDisplayName")
    def primary_consumer_group_display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of the primary consumer group. If omitted, it will be named "Primary Consumer Group".
        """
        return pulumi.get(self, "primary_consumer_group_display_name")

    @primary_consumer_group_display_name.setter
    def primary_consumer_group_display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_consumer_group_display_name", value)

    @_builtins.property
    @pulumi.getter(name="primaryConsumerGroupFilter")
    def primary_consumer_group_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The primary consumer group cannot have any filter hence this field will always be empty. An empty value means that all messages will be available in the primary consumer group.
        """
        return pulumi.get(self, "primary_consumer_group_filter")

    @primary_consumer_group_filter.setter
    def primary_consumer_group_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_consumer_group_filter", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of the capability. Could be CONSUMER_GROUPS and/or LARGE_MESSAGES
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetConsumerGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetConsumerGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConsumerGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetQueuesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetQueuesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetQueuesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


