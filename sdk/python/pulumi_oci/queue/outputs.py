# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'QueueCapability',
    'GetConsumerGroupsConsumerGroupCollectionResult',
    'GetConsumerGroupsConsumerGroupCollectionItemResult',
    'GetConsumerGroupsFilterResult',
    'GetQueueCapabilityResult',
    'GetQueuesFilterResult',
    'GetQueuesQueueCollectionResult',
    'GetQueuesQueueCollectionItemResult',
]

@pulumi.output_type
class QueueCapability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPrimaryConsumerGroupEnabled":
            suggest = "is_primary_consumer_group_enabled"
        elif key == "primaryConsumerGroupDeadLetterQueueDeliveryCount":
            suggest = "primary_consumer_group_dead_letter_queue_delivery_count"
        elif key == "primaryConsumerGroupDisplayName":
            suggest = "primary_consumer_group_display_name"
        elif key == "primaryConsumerGroupFilter":
            suggest = "primary_consumer_group_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueCapability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueCapability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueCapability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_primary_consumer_group_enabled: Optional[_builtins.bool] = None,
                 primary_consumer_group_dead_letter_queue_delivery_count: Optional[_builtins.int] = None,
                 primary_consumer_group_display_name: Optional[_builtins.str] = None,
                 primary_consumer_group_filter: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool is_primary_consumer_group_enabled: (Updatable) Specifies if the primary consumer group should be automatically enabled after adding the capability.
        :param _builtins.int primary_consumer_group_dead_letter_queue_delivery_count: (Updatable) The number of times a message can be delivered to a consumer before being moved to the dead letter queue.  A value of 0 indicates that the DLQ is not used. If the value isn't set, it will be using the value defined at the queue level.
        :param _builtins.str primary_consumer_group_display_name: (Updatable) Name of the primary consumer group. If omitted, it will be named "Primary Consumer Group".
        :param _builtins.str primary_consumer_group_filter: The primary consumer group cannot have any filter hence this field will always be empty. An empty value means that all messages will be available in the primary consumer group.
        :param _builtins.str type: (Updatable) The type of the capability. Could be CONSUMER_GROUPS and/or LARGE_MESSAGES
        """
        if is_primary_consumer_group_enabled is not None:
            pulumi.set(__self__, "is_primary_consumer_group_enabled", is_primary_consumer_group_enabled)
        if primary_consumer_group_dead_letter_queue_delivery_count is not None:
            pulumi.set(__self__, "primary_consumer_group_dead_letter_queue_delivery_count", primary_consumer_group_dead_letter_queue_delivery_count)
        if primary_consumer_group_display_name is not None:
            pulumi.set(__self__, "primary_consumer_group_display_name", primary_consumer_group_display_name)
        if primary_consumer_group_filter is not None:
            pulumi.set(__self__, "primary_consumer_group_filter", primary_consumer_group_filter)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="isPrimaryConsumerGroupEnabled")
    def is_primary_consumer_group_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Specifies if the primary consumer group should be automatically enabled after adding the capability.
        """
        return pulumi.get(self, "is_primary_consumer_group_enabled")

    @_builtins.property
    @pulumi.getter(name="primaryConsumerGroupDeadLetterQueueDeliveryCount")
    def primary_consumer_group_dead_letter_queue_delivery_count(self) -> Optional[_builtins.int]:
        """
        (Updatable) The number of times a message can be delivered to a consumer before being moved to the dead letter queue.  A value of 0 indicates that the DLQ is not used. If the value isn't set, it will be using the value defined at the queue level.
        """
        return pulumi.get(self, "primary_consumer_group_dead_letter_queue_delivery_count")

    @_builtins.property
    @pulumi.getter(name="primaryConsumerGroupDisplayName")
    def primary_consumer_group_display_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) Name of the primary consumer group. If omitted, it will be named "Primary Consumer Group".
        """
        return pulumi.get(self, "primary_consumer_group_display_name")

    @_builtins.property
    @pulumi.getter(name="primaryConsumerGroupFilter")
    def primary_consumer_group_filter(self) -> Optional[_builtins.str]:
        """
        The primary consumer group cannot have any filter hence this field will always be empty. An empty value means that all messages will be available in the primary consumer group.
        """
        return pulumi.get(self, "primary_consumer_group_filter")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        (Updatable) The type of the capability. Could be CONSUMER_GROUPS and/or LARGE_MESSAGES
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetConsumerGroupsConsumerGroupCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetConsumerGroupsConsumerGroupCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetConsumerGroupsConsumerGroupCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetConsumerGroupsConsumerGroupCollectionItemResult(dict):
    def __init__(__self__, *,
                 consumer_group_filter: _builtins.str,
                 dead_letter_queue_delivery_count: _builtins.int,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_enabled: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 queue_id: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str consumer_group_filter: The filter used by the consumer group. Only messages matching the filter will be available by consumers of the consumer group. An empty value means that all messages will be available in the group. The primary consumer group cannot have any filter.
        :param _builtins.int dead_letter_queue_delivery_count: The number of times a message can be delivered to a consumer before being moved to the dead letter queue.  A value of 0 indicates that the DLQ is not used. If the value isn't set, it will be using the value defined at the queue level.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: The unique consumer group identifier.
        :param _builtins.str lifecycle_details: Any additional details about the current state of the consumer group.
        :param _builtins.str queue_id: The unique queue identifier.
        :param _builtins.str state: A filter to return only resources their lifecycleState matches the given lifecycleState.
        :param Mapping[str, _builtins.str] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param _builtins.str time_created: The time that the consumer group was created, expressed in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) timestamp format.  Example: `2018-04-20T00:00:07.405Z`
        :param _builtins.str time_updated: The time that the consumer group was updated, expressed in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) timestamp format.  Example: `2018-04-20T00:00:07.405Z`
        """
        pulumi.set(__self__, "consumer_group_filter", consumer_group_filter)
        pulumi.set(__self__, "dead_letter_queue_delivery_count", dead_letter_queue_delivery_count)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="consumerGroupFilter")
    def consumer_group_filter(self) -> _builtins.str:
        """
        The filter used by the consumer group. Only messages matching the filter will be available by consumers of the consumer group. An empty value means that all messages will be available in the group. The primary consumer group cannot have any filter.
        """
        return pulumi.get(self, "consumer_group_filter")

    @_builtins.property
    @pulumi.getter(name="deadLetterQueueDeliveryCount")
    def dead_letter_queue_delivery_count(self) -> _builtins.int:
        """
        The number of times a message can be delivered to a consumer before being moved to the dead letter queue.  A value of 0 indicates that the DLQ is not used. If the value isn't set, it will be using the value defined at the queue level.
        """
        return pulumi.get(self, "dead_letter_queue_delivery_count")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique consumer group identifier.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Any additional details about the current state of the consumer group.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> _builtins.str:
        """
        The unique queue identifier.
        """
        return pulumi.get(self, "queue_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources their lifecycleState matches the given lifecycleState.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time that the consumer group was created, expressed in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) timestamp format.  Example: `2018-04-20T00:00:07.405Z`
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time that the consumer group was updated, expressed in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) timestamp format.  Example: `2018-04-20T00:00:07.405Z`
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetConsumerGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetQueueCapabilityResult(dict):
    def __init__(__self__, *,
                 is_primary_consumer_group_enabled: _builtins.bool,
                 primary_consumer_group_dead_letter_queue_delivery_count: _builtins.int,
                 primary_consumer_group_display_name: _builtins.str,
                 primary_consumer_group_filter: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.bool is_primary_consumer_group_enabled: (Applicable when type=CONSUMER_GROUPS) Specifies if the primary consumer group should be automatically enabled after adding the capability.
        :param _builtins.int primary_consumer_group_dead_letter_queue_delivery_count: (Applicable when type=CONSUMER_GROUPS) The number of times a message can be delivered to a consumer before being moved to the dead letter queue.  A value of 0 indicates that the DLQ is not used. If the value isn't set, it will be using the value defined at the queue level.
        :param _builtins.str primary_consumer_group_display_name: (Applicable when type=CONSUMER_GROUPS) Name of the primary consumer group. If omitted, it will be named "Primary Consumer Group".
        :param _builtins.str primary_consumer_group_filter: (Applicable when type=CONSUMER_GROUPS) The primary consumer group cannot have any filter hence this field will always be empty. An empty value means that all messages will be available in the primary consumer group.
        :param _builtins.str type: The type of the capability. Could be CONSUMER_GROUPS and/or LARGE_MESSAGES
        """
        pulumi.set(__self__, "is_primary_consumer_group_enabled", is_primary_consumer_group_enabled)
        pulumi.set(__self__, "primary_consumer_group_dead_letter_queue_delivery_count", primary_consumer_group_dead_letter_queue_delivery_count)
        pulumi.set(__self__, "primary_consumer_group_display_name", primary_consumer_group_display_name)
        pulumi.set(__self__, "primary_consumer_group_filter", primary_consumer_group_filter)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="isPrimaryConsumerGroupEnabled")
    def is_primary_consumer_group_enabled(self) -> _builtins.bool:
        """
        (Applicable when type=CONSUMER_GROUPS) Specifies if the primary consumer group should be automatically enabled after adding the capability.
        """
        return pulumi.get(self, "is_primary_consumer_group_enabled")

    @_builtins.property
    @pulumi.getter(name="primaryConsumerGroupDeadLetterQueueDeliveryCount")
    def primary_consumer_group_dead_letter_queue_delivery_count(self) -> _builtins.int:
        """
        (Applicable when type=CONSUMER_GROUPS) The number of times a message can be delivered to a consumer before being moved to the dead letter queue.  A value of 0 indicates that the DLQ is not used. If the value isn't set, it will be using the value defined at the queue level.
        """
        return pulumi.get(self, "primary_consumer_group_dead_letter_queue_delivery_count")

    @_builtins.property
    @pulumi.getter(name="primaryConsumerGroupDisplayName")
    def primary_consumer_group_display_name(self) -> _builtins.str:
        """
        (Applicable when type=CONSUMER_GROUPS) Name of the primary consumer group. If omitted, it will be named "Primary Consumer Group".
        """
        return pulumi.get(self, "primary_consumer_group_display_name")

    @_builtins.property
    @pulumi.getter(name="primaryConsumerGroupFilter")
    def primary_consumer_group_filter(self) -> _builtins.str:
        """
        (Applicable when type=CONSUMER_GROUPS) The primary consumer group cannot have any filter hence this field will always be empty. An empty value means that all messages will be available in the primary consumer group.
        """
        return pulumi.get(self, "primary_consumer_group_filter")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the capability. Could be CONSUMER_GROUPS and/or LARGE_MESSAGES
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetQueuesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetQueuesQueueCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetQueuesQueueCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetQueuesQueueCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetQueuesQueueCollectionItemResult(dict):
    def __init__(__self__, *,
                 capabilities: Sequence[_builtins.str],
                 channel_consumption_limit: _builtins.int,
                 compartment_id: _builtins.str,
                 custom_encryption_key_id: _builtins.str,
                 dead_letter_queue_delivery_count: _builtins.int,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 messages_endpoint: _builtins.str,
                 purge_trigger: _builtins.int,
                 purge_type: _builtins.str,
                 retention_in_seconds: _builtins.int,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 timeout_in_seconds: _builtins.int,
                 visibility_in_seconds: _builtins.int):
        """
        :param Sequence[_builtins.str] capabilities: The list of capabilities enabled on the queue
        :param _builtins.int channel_consumption_limit: The percentage of allocated queue resources that can be consumed by a single channel. For example, if a queue has a storage limit of 2Gb, and a single channel consumption limit is 0.1 (10%), that means data size of a single channel  can't exceed 200Mb. Consumption limit of 100% (default) means that a single channel can consume up-to all allocated queue's resources.
        :param _builtins.str compartment_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment in which to list resources.
        :param _builtins.str custom_encryption_key_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the custom encryption key to be used to encrypt messages content.
        :param _builtins.int dead_letter_queue_delivery_count: The number of times a message can be delivered to a consumer before being moved to the dead letter queue. A value of 0 indicates that the DLQ is not used.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: The unique queue identifier.
        :param _builtins.str lifecycle_details: Any additional details about the current state of the queue.
        :param _builtins.str messages_endpoint: The endpoint to use to consume or publish messages in the queue.
        :param _builtins.int retention_in_seconds: The retention period of the messages in the queue, in seconds.
        :param _builtins.str state: A filter to return only resources their lifecycleState matches the given lifecycleState.
        :param Mapping[str, _builtins.str] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param _builtins.str time_created: The time that the queue was created, expressed in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) timestamp format.  Example: `2018-04-20T00:00:07.405Z`
        :param _builtins.str time_updated: The time that the queue was updated, expressed in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) timestamp format.  Example: `2018-04-20T00:00:07.405Z`
        :param _builtins.int timeout_in_seconds: The default polling timeout of the messages in the queue, in seconds.
        :param _builtins.int visibility_in_seconds: The default visibility timeout of the messages consumed from the queue, in seconds.
        """
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "channel_consumption_limit", channel_consumption_limit)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "custom_encryption_key_id", custom_encryption_key_id)
        pulumi.set(__self__, "dead_letter_queue_delivery_count", dead_letter_queue_delivery_count)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "messages_endpoint", messages_endpoint)
        pulumi.set(__self__, "purge_trigger", purge_trigger)
        pulumi.set(__self__, "purge_type", purge_type)
        pulumi.set(__self__, "retention_in_seconds", retention_in_seconds)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        pulumi.set(__self__, "visibility_in_seconds", visibility_in_seconds)

    @_builtins.property
    @pulumi.getter
    def capabilities(self) -> Sequence[_builtins.str]:
        """
        The list of capabilities enabled on the queue
        """
        return pulumi.get(self, "capabilities")

    @_builtins.property
    @pulumi.getter(name="channelConsumptionLimit")
    def channel_consumption_limit(self) -> _builtins.int:
        """
        The percentage of allocated queue resources that can be consumed by a single channel. For example, if a queue has a storage limit of 2Gb, and a single channel consumption limit is 0.1 (10%), that means data size of a single channel  can't exceed 200Mb. Consumption limit of 100% (default) means that a single channel can consume up-to all allocated queue's resources.
        """
        return pulumi.get(self, "channel_consumption_limit")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="customEncryptionKeyId")
    def custom_encryption_key_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the custom encryption key to be used to encrypt messages content.
        """
        return pulumi.get(self, "custom_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="deadLetterQueueDeliveryCount")
    def dead_letter_queue_delivery_count(self) -> _builtins.int:
        """
        The number of times a message can be delivered to a consumer before being moved to the dead letter queue. A value of 0 indicates that the DLQ is not used.
        """
        return pulumi.get(self, "dead_letter_queue_delivery_count")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique queue identifier.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Any additional details about the current state of the queue.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="messagesEndpoint")
    def messages_endpoint(self) -> _builtins.str:
        """
        The endpoint to use to consume or publish messages in the queue.
        """
        return pulumi.get(self, "messages_endpoint")

    @_builtins.property
    @pulumi.getter(name="purgeTrigger")
    def purge_trigger(self) -> _builtins.int:
        return pulumi.get(self, "purge_trigger")

    @_builtins.property
    @pulumi.getter(name="purgeType")
    def purge_type(self) -> _builtins.str:
        return pulumi.get(self, "purge_type")

    @_builtins.property
    @pulumi.getter(name="retentionInSeconds")
    def retention_in_seconds(self) -> _builtins.int:
        """
        The retention period of the messages in the queue, in seconds.
        """
        return pulumi.get(self, "retention_in_seconds")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources their lifecycleState matches the given lifecycleState.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time that the queue was created, expressed in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) timestamp format.  Example: `2018-04-20T00:00:07.405Z`
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time that the queue was updated, expressed in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) timestamp format.  Example: `2018-04-20T00:00:07.405Z`
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> _builtins.int:
        """
        The default polling timeout of the messages in the queue, in seconds.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @_builtins.property
    @pulumi.getter(name="visibilityInSeconds")
    def visibility_in_seconds(self) -> _builtins.int:
        """
        The default visibility timeout of the messages consumed from the queue, in seconds.
        """
        return pulumi.get(self, "visibility_in_seconds")


