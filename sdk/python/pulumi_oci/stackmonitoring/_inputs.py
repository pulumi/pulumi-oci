# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConfigAdditionalConfigurationsArgs',
    'ConfigAdditionalConfigurationsArgsDict',
    'ConfigDynamicGroupArgs',
    'ConfigDynamicGroupArgsDict',
    'ConfigUserGroupArgs',
    'ConfigUserGroupArgsDict',
    'DiscoveryJobDiscoveryDetailsArgs',
    'DiscoveryJobDiscoveryDetailsArgsDict',
    'DiscoveryJobDiscoveryDetailsCredentialsArgs',
    'DiscoveryJobDiscoveryDetailsCredentialsArgsDict',
    'DiscoveryJobDiscoveryDetailsCredentialsItemArgs',
    'DiscoveryJobDiscoveryDetailsCredentialsItemArgsDict',
    'DiscoveryJobDiscoveryDetailsCredentialsItemPropertiesArgs',
    'DiscoveryJobDiscoveryDetailsCredentialsItemPropertiesArgsDict',
    'DiscoveryJobDiscoveryDetailsPropertiesArgs',
    'DiscoveryJobDiscoveryDetailsPropertiesArgsDict',
    'DiscoveryJobDiscoveryDetailsTagsArgs',
    'DiscoveryJobDiscoveryDetailsTagsArgsDict',
    'MaintenanceWindowResourceArgs',
    'MaintenanceWindowResourceArgsDict',
    'MaintenanceWindowResourcesDetailArgs',
    'MaintenanceWindowResourcesDetailArgsDict',
    'MaintenanceWindowScheduleArgs',
    'MaintenanceWindowScheduleArgsDict',
    'MetricExtensionEnabledOnResourceArgs',
    'MetricExtensionEnabledOnResourceArgsDict',
    'MetricExtensionMetricListArgs',
    'MetricExtensionMetricListArgsDict',
    'MetricExtensionQueryPropertiesArgs',
    'MetricExtensionQueryPropertiesArgsDict',
    'MetricExtensionQueryPropertiesInParamDetailArgs',
    'MetricExtensionQueryPropertiesInParamDetailArgsDict',
    'MetricExtensionQueryPropertiesOutParamDetailsArgs',
    'MetricExtensionQueryPropertiesOutParamDetailsArgsDict',
    'MetricExtensionQueryPropertiesScriptDetailsArgs',
    'MetricExtensionQueryPropertiesScriptDetailsArgsDict',
    'MetricExtensionQueryPropertiesSqlDetailsArgs',
    'MetricExtensionQueryPropertiesSqlDetailsArgsDict',
    'MonitoredResourceAdditionalAliasArgs',
    'MonitoredResourceAdditionalAliasArgsDict',
    'MonitoredResourceAdditionalAliasCredentialArgs',
    'MonitoredResourceAdditionalAliasCredentialArgsDict',
    'MonitoredResourceAdditionalCredentialArgs',
    'MonitoredResourceAdditionalCredentialArgsDict',
    'MonitoredResourceAdditionalCredentialPropertyArgs',
    'MonitoredResourceAdditionalCredentialPropertyArgsDict',
    'MonitoredResourceAliasesArgs',
    'MonitoredResourceAliasesArgsDict',
    'MonitoredResourceAliasesCredentialArgs',
    'MonitoredResourceAliasesCredentialArgsDict',
    'MonitoredResourceCredentialsArgs',
    'MonitoredResourceCredentialsArgsDict',
    'MonitoredResourceCredentialsPropertyArgs',
    'MonitoredResourceCredentialsPropertyArgsDict',
    'MonitoredResourceDatabaseConnectionDetailsArgs',
    'MonitoredResourceDatabaseConnectionDetailsArgsDict',
    'MonitoredResourcePropertyArgs',
    'MonitoredResourcePropertyArgsDict',
    'MonitoredResourceTaskTaskDetailsArgs',
    'MonitoredResourceTaskTaskDetailsArgsDict',
    'MonitoredResourceTaskTaskDetailsReceiverPropertiesArgs',
    'MonitoredResourceTaskTaskDetailsReceiverPropertiesArgsDict',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationArgs',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationArgsDict',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationAvailabilityMetricsConfigArgs',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationAvailabilityMetricsConfigArgsDict',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigArgs',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigArgsDict',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigCollectdResourceNameConfigArgs',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigCollectdResourceNameConfigArgsDict',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigHandlerPropertyArgs',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigHandlerPropertyArgsDict',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricMappingArgs',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricMappingArgsDict',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricNameConfigArgs',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricNameConfigArgsDict',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigTelegrafResourceNameConfigArgs',
    'MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigTelegrafResourceNameConfigArgsDict',
    'MonitoredResourceTypeAvailabilityMetricsConfigArgs',
    'MonitoredResourceTypeAvailabilityMetricsConfigArgsDict',
    'MonitoredResourceTypeHandlerConfigArgs',
    'MonitoredResourceTypeHandlerConfigArgsDict',
    'MonitoredResourceTypeHandlerConfigCollectdResourceNameConfigArgs',
    'MonitoredResourceTypeHandlerConfigCollectdResourceNameConfigArgsDict',
    'MonitoredResourceTypeHandlerConfigHandlerPropertyArgs',
    'MonitoredResourceTypeHandlerConfigHandlerPropertyArgsDict',
    'MonitoredResourceTypeHandlerConfigMetricMappingArgs',
    'MonitoredResourceTypeHandlerConfigMetricMappingArgsDict',
    'MonitoredResourceTypeHandlerConfigMetricNameConfigArgs',
    'MonitoredResourceTypeHandlerConfigMetricNameConfigArgsDict',
    'MonitoredResourceTypeHandlerConfigTelegrafResourceNameConfigArgs',
    'MonitoredResourceTypeHandlerConfigTelegrafResourceNameConfigArgsDict',
    'MonitoredResourceTypeMetadataArgs',
    'MonitoredResourceTypeMetadataArgsDict',
    'MonitoredResourceTypeMetadataUniquePropertySetArgs',
    'MonitoredResourceTypeMetadataUniquePropertySetArgsDict',
    'MonitoredResourcesAssociateMonitoredResourceDestinationResourceDetailArgs',
    'MonitoredResourcesAssociateMonitoredResourceDestinationResourceDetailArgsDict',
    'MonitoredResourcesAssociateMonitoredResourceSourceResourceDetailArgs',
    'MonitoredResourcesAssociateMonitoredResourceSourceResourceDetailArgsDict',
    'MonitoredResourcesListMemberItemArgs',
    'MonitoredResourcesListMemberItemArgsDict',
    'MonitoredResourcesSearchAssociationItemArgs',
    'MonitoredResourcesSearchAssociationItemArgsDict',
    'MonitoredResourcesSearchAssociationItemDestinationResourceDetailArgs',
    'MonitoredResourcesSearchAssociationItemDestinationResourceDetailArgsDict',
    'MonitoredResourcesSearchAssociationItemSourceResourceDetailArgs',
    'MonitoredResourcesSearchAssociationItemSourceResourceDetailArgsDict',
    'MonitoredResourcesSearchItemArgs',
    'MonitoredResourcesSearchItemArgsDict',
    'MonitoredResourcesSearchItemPropertyArgs',
    'MonitoredResourcesSearchItemPropertyArgsDict',
    'MonitoringTemplateAlarmConditionConditionArgs',
    'MonitoringTemplateAlarmConditionConditionArgsDict',
    'MonitoringTemplateMemberArgs',
    'MonitoringTemplateMemberArgsDict',
    'ProcessSetSpecificationArgs',
    'ProcessSetSpecificationArgsDict',
    'ProcessSetSpecificationItemArgs',
    'ProcessSetSpecificationItemArgsDict',
    'GetBaselineableMetricsEvaluateItemArgs',
    'GetBaselineableMetricsEvaluateItemArgsDict',
    'GetBaselineableMetricsEvaluateItemDataPointArgs',
    'GetBaselineableMetricsEvaluateItemDataPointArgsDict',
    'GetBaselineableMetricsEvaluateItemEvaluationDataPointArgs',
    'GetBaselineableMetricsEvaluateItemEvaluationDataPointArgsDict',
    'GetBaselineableMetricsEvaluateItemTrainingDataPointArgs',
    'GetBaselineableMetricsEvaluateItemTrainingDataPointArgsDict',
    'GetBaselineableMetricsFilterArgs',
    'GetBaselineableMetricsFilterArgsDict',
    'GetConfigsFilterArgs',
    'GetConfigsFilterArgsDict',
    'GetDefinedMonitoringTemplatesFilterArgs',
    'GetDefinedMonitoringTemplatesFilterArgsDict',
    'GetDiscoveryJobLogsFilterArgs',
    'GetDiscoveryJobLogsFilterArgsDict',
    'GetDiscoveryJobsFilterArgs',
    'GetDiscoveryJobsFilterArgsDict',
    'GetMaintenanceWindowsFilterArgs',
    'GetMaintenanceWindowsFilterArgsDict',
    'GetMetricExtensionsFilterArgs',
    'GetMetricExtensionsFilterArgsDict',
    'GetMonitoredResourceTasksFilterArgs',
    'GetMonitoredResourceTasksFilterArgsDict',
    'GetMonitoredResourceTypesFilterArgs',
    'GetMonitoredResourceTypesFilterArgsDict',
    'GetMonitoredResourcesFilterArgs',
    'GetMonitoredResourcesFilterArgsDict',
    'GetMonitoringTemplateAlarmConditionsFilterArgs',
    'GetMonitoringTemplateAlarmConditionsFilterArgsDict',
    'GetMonitoringTemplatesFilterArgs',
    'GetMonitoringTemplatesFilterArgsDict',
    'GetProcessSetsFilterArgs',
    'GetProcessSetsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ConfigAdditionalConfigurationsArgsDict(TypedDict):
        properties_map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Key/Value pair of Property
        """
elif False:
    ConfigAdditionalConfigurationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigAdditionalConfigurationsArgs:
    def __init__(__self__, *,
                 properties_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties_map: (Updatable) Key/Value pair of Property
        """
        if properties_map is not None:
            pulumi.set(__self__, "properties_map", properties_map)

    @_builtins.property
    @pulumi.getter(name="propertiesMap")
    def properties_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Key/Value pair of Property
        """
        return pulumi.get(self, "properties_map")

    @properties_map.setter
    def properties_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties_map", value)


if not MYPY:
    class ConfigDynamicGroupArgsDict(TypedDict):
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Identity domain name
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of dynamic Group
        """
        stack_monitoring_assignment: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Assignment of dynamic group in context of Stack Monitoring service. It describes the purpose of dynamic groups in Stack Monitoring.
        """
elif False:
    ConfigDynamicGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigDynamicGroupArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 stack_monitoring_assignment: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] domain: (Updatable) Identity domain name
        :param pulumi.Input[_builtins.str] name: (Updatable) Name of dynamic Group
        :param pulumi.Input[_builtins.str] stack_monitoring_assignment: (Updatable) Assignment of dynamic group in context of Stack Monitoring service. It describes the purpose of dynamic groups in Stack Monitoring.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stack_monitoring_assignment is not None:
            pulumi.set(__self__, "stack_monitoring_assignment", stack_monitoring_assignment)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Identity domain name
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of dynamic Group
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="stackMonitoringAssignment")
    def stack_monitoring_assignment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Assignment of dynamic group in context of Stack Monitoring service. It describes the purpose of dynamic groups in Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_assignment")

    @stack_monitoring_assignment.setter
    def stack_monitoring_assignment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stack_monitoring_assignment", value)


if not MYPY:
    class ConfigUserGroupArgsDict(TypedDict):
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Identity domain name
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of user Group
        """
        stack_monitoring_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Role assigned to user group in context of Stack Monitoring service. Access role can be for example: ADMINISTRATOR, OPERATOR, VIEWER, any other access role
        """
elif False:
    ConfigUserGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigUserGroupArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 stack_monitoring_role: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] domain: (Updatable) Identity domain name
        :param pulumi.Input[_builtins.str] name: (Updatable) Name of user Group
        :param pulumi.Input[_builtins.str] stack_monitoring_role: (Updatable) Role assigned to user group in context of Stack Monitoring service. Access role can be for example: ADMINISTRATOR, OPERATOR, VIEWER, any other access role
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stack_monitoring_role is not None:
            pulumi.set(__self__, "stack_monitoring_role", stack_monitoring_role)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Identity domain name
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of user Group
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="stackMonitoringRole")
    def stack_monitoring_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Role assigned to user group in context of Stack Monitoring service. Access role can be for example: ADMINISTRATOR, OPERATOR, VIEWER, any other access role
        """
        return pulumi.get(self, "stack_monitoring_role")

    @stack_monitoring_role.setter
    def stack_monitoring_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stack_monitoring_role", value)


if not MYPY:
    class DiscoveryJobDiscoveryDetailsArgsDict(TypedDict):
        agent_id: pulumi.Input[_builtins.str]
        """
        The OCID of Management Agent
        """
        properties: pulumi.Input['DiscoveryJobDiscoveryDetailsPropertiesArgsDict']
        """
        Property Details
        """
        resource_name: pulumi.Input[_builtins.str]
        """
        The Name of resource type
        """
        resource_type: pulumi.Input[_builtins.str]
        """
        Resource Type.
        """
        credentials: NotRequired[pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsArgsDict']]
        """
        List of DiscoveryJob Credential Details.
        """
        license: NotRequired[pulumi.Input[_builtins.str]]
        """
        License edition of the monitored resource.
        """
        tags: NotRequired[pulumi.Input['DiscoveryJobDiscoveryDetailsTagsArgsDict']]
        """
        Property Details
        """
elif False:
    DiscoveryJobDiscoveryDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveryJobDiscoveryDetailsArgs:
    def __init__(__self__, *,
                 agent_id: pulumi.Input[_builtins.str],
                 properties: pulumi.Input['DiscoveryJobDiscoveryDetailsPropertiesArgs'],
                 resource_name: pulumi.Input[_builtins.str],
                 resource_type: pulumi.Input[_builtins.str],
                 credentials: Optional[pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsArgs']] = None,
                 license: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input['DiscoveryJobDiscoveryDetailsTagsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] agent_id: The OCID of Management Agent
        :param pulumi.Input['DiscoveryJobDiscoveryDetailsPropertiesArgs'] properties: Property Details
        :param pulumi.Input[_builtins.str] resource_name: The Name of resource type
        :param pulumi.Input[_builtins.str] resource_type: Resource Type.
        :param pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsArgs'] credentials: List of DiscoveryJob Credential Details.
        :param pulumi.Input[_builtins.str] license: License edition of the monitored resource.
        :param pulumi.Input['DiscoveryJobDiscoveryDetailsTagsArgs'] tags: Property Details
        """
        pulumi.set(__self__, "agent_id", agent_id)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "resource_type", resource_type)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if license is not None:
            pulumi.set(__self__, "license", license)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> pulumi.Input[_builtins.str]:
        """
        The OCID of Management Agent
        """
        return pulumi.get(self, "agent_id")

    @agent_id.setter
    def agent_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent_id", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> pulumi.Input['DiscoveryJobDiscoveryDetailsPropertiesArgs']:
        """
        Property Details
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: pulumi.Input['DiscoveryJobDiscoveryDetailsPropertiesArgs']):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[_builtins.str]:
        """
        The Name of resource type
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[_builtins.str]:
        """
        Resource Type.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsArgs']]:
        """
        List of DiscoveryJob Credential Details.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def license(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License edition of the monitored resource.
        """
        return pulumi.get(self, "license")

    @license.setter
    def license(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['DiscoveryJobDiscoveryDetailsTagsArgs']]:
        """
        Property Details
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['DiscoveryJobDiscoveryDetailsTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class DiscoveryJobDiscoveryDetailsCredentialsArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsItemArgsDict']]]
        """
        List of DiscoveryJob credentials.
        """
elif False:
    DiscoveryJobDiscoveryDetailsCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveryJobDiscoveryDetailsCredentialsArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsItemArgs']]] items: List of DiscoveryJob credentials.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsItemArgs']]]:
        """
        List of DiscoveryJob credentials.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DiscoveryJobDiscoveryDetailsCredentialsItemArgsDict(TypedDict):
        credential_name: pulumi.Input[_builtins.str]
        """
        Name of Credential
        """
        credential_type: pulumi.Input[_builtins.str]
        """
        Name of Credential Type
        """
        properties: pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsItemPropertiesArgsDict']
        """
        Property Details
        """
elif False:
    DiscoveryJobDiscoveryDetailsCredentialsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveryJobDiscoveryDetailsCredentialsItemArgs:
    def __init__(__self__, *,
                 credential_name: pulumi.Input[_builtins.str],
                 credential_type: pulumi.Input[_builtins.str],
                 properties: pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsItemPropertiesArgs']):
        """
        :param pulumi.Input[_builtins.str] credential_name: Name of Credential
        :param pulumi.Input[_builtins.str] credential_type: Name of Credential Type
        :param pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsItemPropertiesArgs'] properties: Property Details
        """
        pulumi.set(__self__, "credential_name", credential_name)
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of Credential
        """
        return pulumi.get(self, "credential_name")

    @credential_name.setter
    def credential_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credential_name", value)

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> pulumi.Input[_builtins.str]:
        """
        Name of Credential Type
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credential_type", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsItemPropertiesArgs']:
        """
        Property Details
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: pulumi.Input['DiscoveryJobDiscoveryDetailsCredentialsItemPropertiesArgs']):
        pulumi.set(self, "properties", value)


if not MYPY:
    class DiscoveryJobDiscoveryDetailsCredentialsItemPropertiesArgsDict(TypedDict):
        properties_map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key/Value pair of Property
        """
elif False:
    DiscoveryJobDiscoveryDetailsCredentialsItemPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveryJobDiscoveryDetailsCredentialsItemPropertiesArgs:
    def __init__(__self__, *,
                 properties_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties_map: Key/Value pair of Property
        """
        if properties_map is not None:
            pulumi.set(__self__, "properties_map", properties_map)

    @_builtins.property
    @pulumi.getter(name="propertiesMap")
    def properties_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key/Value pair of Property
        """
        return pulumi.get(self, "properties_map")

    @properties_map.setter
    def properties_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties_map", value)


if not MYPY:
    class DiscoveryJobDiscoveryDetailsPropertiesArgsDict(TypedDict):
        properties_map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key/Value pair of Property
        """
elif False:
    DiscoveryJobDiscoveryDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveryJobDiscoveryDetailsPropertiesArgs:
    def __init__(__self__, *,
                 properties_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties_map: Key/Value pair of Property
        """
        if properties_map is not None:
            pulumi.set(__self__, "properties_map", properties_map)

    @_builtins.property
    @pulumi.getter(name="propertiesMap")
    def properties_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key/Value pair of Property
        """
        return pulumi.get(self, "properties_map")

    @properties_map.setter
    def properties_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties_map", value)


if not MYPY:
    class DiscoveryJobDiscoveryDetailsTagsArgsDict(TypedDict):
        properties_map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key/Value pair of Property
        """
elif False:
    DiscoveryJobDiscoveryDetailsTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveryJobDiscoveryDetailsTagsArgs:
    def __init__(__self__, *,
                 properties_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties_map: Key/Value pair of Property
        """
        if properties_map is not None:
            pulumi.set(__self__, "properties_map", properties_map)

    @_builtins.property
    @pulumi.getter(name="propertiesMap")
    def properties_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key/Value pair of Property
        """
        return pulumi.get(self, "properties_map")

    @properties_map.setter
    def properties_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties_map", value)


if not MYPY:
    class MaintenanceWindowResourceArgsDict(TypedDict):
        resource_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of monitored resource part of the Maintenance window.
        """
        are_members_included: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Flag to indicate if the members of the resource has to be include in the Maintenance Window.
        """
elif False:
    MaintenanceWindowResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowResourceArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[_builtins.str],
                 are_members_included: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] resource_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of monitored resource part of the Maintenance window.
        :param pulumi.Input[_builtins.bool] are_members_included: (Updatable) Flag to indicate if the members of the resource has to be include in the Maintenance Window.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        if are_members_included is not None:
            pulumi.set(__self__, "are_members_included", are_members_included)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of monitored resource part of the Maintenance window.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="areMembersIncluded")
    def are_members_included(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Flag to indicate if the members of the resource has to be include in the Maintenance Window.
        """
        return pulumi.get(self, "are_members_included")

    @are_members_included.setter
    def are_members_included(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "are_members_included", value)


if not MYPY:
    class MaintenanceWindowResourcesDetailArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maintenance Window name.
        """
        number_of_members: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of members of the resource
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of monitored resource part of the Maintenance window.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the monitored resource
        """
elif False:
    MaintenanceWindowResourcesDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowResourcesDetailArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 number_of_members: Optional[pulumi.Input[_builtins.int]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Maintenance Window name.
        :param pulumi.Input[_builtins.int] number_of_members: Number of members of the resource
        :param pulumi.Input[_builtins.str] resource_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of monitored resource part of the Maintenance window.
        :param pulumi.Input[_builtins.str] type: Type of the monitored resource
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number_of_members is not None:
            pulumi.set(__self__, "number_of_members", number_of_members)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maintenance Window name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="numberOfMembers")
    def number_of_members(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of members of the resource
        """
        return pulumi.get(self, "number_of_members")

    @number_of_members.setter
    def number_of_members(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number_of_members", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of monitored resource part of the Maintenance window.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the monitored resource
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MaintenanceWindowScheduleArgsDict(TypedDict):
        schedule_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Property to identify the type of the Maintenance Window.
        """
        maintenance_window_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Duration time of each recurrence of each Maintenance Window. It must be specified as a string in ISO 8601 extended format.
        """
        maintenance_window_recurrences: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A RFC5545 formatted recurrence string which represents the Maintenance Window Recurrence. Please refer this for details:https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10 FREQ: Frequency of the Maintenance Window. The supported values are: DAILY and WEEKLY. BYDAY: Comma separated days for Weekly Maintenance Window. BYHOUR: Specifies the start hour of each recurrence after `timeMaintenanceWindowStart` value. BYMINUTE: Specifies the start minute of each reccurrence after `timeMaintenanceWindowStart` value. The default value is 00 BYSECOND: Specifies the start second of each reccurrence after `timeMaintenanceWindowStart` value. The default value is 00 Other Rules are not supported.
        """
        time_maintenance_window_end: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Start time of Maintenance window. A RFC3339 formatted datetime string
        """
        time_maintenance_window_start: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Start time of Maintenance window. A RFC3339 formatted datetime string 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    MaintenanceWindowScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowScheduleArgs:
    def __init__(__self__, *,
                 schedule_type: pulumi.Input[_builtins.str],
                 maintenance_window_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 maintenance_window_recurrences: Optional[pulumi.Input[_builtins.str]] = None,
                 time_maintenance_window_end: Optional[pulumi.Input[_builtins.str]] = None,
                 time_maintenance_window_start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] schedule_type: (Updatable) Property to identify the type of the Maintenance Window.
        :param pulumi.Input[_builtins.str] maintenance_window_duration: (Updatable) Duration time of each recurrence of each Maintenance Window. It must be specified as a string in ISO 8601 extended format.
        :param pulumi.Input[_builtins.str] maintenance_window_recurrences: (Updatable) A RFC5545 formatted recurrence string which represents the Maintenance Window Recurrence. Please refer this for details:https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10 FREQ: Frequency of the Maintenance Window. The supported values are: DAILY and WEEKLY. BYDAY: Comma separated days for Weekly Maintenance Window. BYHOUR: Specifies the start hour of each recurrence after `timeMaintenanceWindowStart` value. BYMINUTE: Specifies the start minute of each reccurrence after `timeMaintenanceWindowStart` value. The default value is 00 BYSECOND: Specifies the start second of each reccurrence after `timeMaintenanceWindowStart` value. The default value is 00 Other Rules are not supported.
        :param pulumi.Input[_builtins.str] time_maintenance_window_end: (Updatable) Start time of Maintenance window. A RFC3339 formatted datetime string
        :param pulumi.Input[_builtins.str] time_maintenance_window_start: (Updatable) Start time of Maintenance window. A RFC3339 formatted datetime string 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "schedule_type", schedule_type)
        if maintenance_window_duration is not None:
            pulumi.set(__self__, "maintenance_window_duration", maintenance_window_duration)
        if maintenance_window_recurrences is not None:
            pulumi.set(__self__, "maintenance_window_recurrences", maintenance_window_recurrences)
        if time_maintenance_window_end is not None:
            pulumi.set(__self__, "time_maintenance_window_end", time_maintenance_window_end)
        if time_maintenance_window_start is not None:
            pulumi.set(__self__, "time_maintenance_window_start", time_maintenance_window_start)

    @_builtins.property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Property to identify the type of the Maintenance Window.
        """
        return pulumi.get(self, "schedule_type")

    @schedule_type.setter
    def schedule_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schedule_type", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowDuration")
    def maintenance_window_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Duration time of each recurrence of each Maintenance Window. It must be specified as a string in ISO 8601 extended format.
        """
        return pulumi.get(self, "maintenance_window_duration")

    @maintenance_window_duration.setter
    def maintenance_window_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maintenance_window_duration", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowRecurrences")
    def maintenance_window_recurrences(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A RFC5545 formatted recurrence string which represents the Maintenance Window Recurrence. Please refer this for details:https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10 FREQ: Frequency of the Maintenance Window. The supported values are: DAILY and WEEKLY. BYDAY: Comma separated days for Weekly Maintenance Window. BYHOUR: Specifies the start hour of each recurrence after `timeMaintenanceWindowStart` value. BYMINUTE: Specifies the start minute of each reccurrence after `timeMaintenanceWindowStart` value. The default value is 00 BYSECOND: Specifies the start second of each reccurrence after `timeMaintenanceWindowStart` value. The default value is 00 Other Rules are not supported.
        """
        return pulumi.get(self, "maintenance_window_recurrences")

    @maintenance_window_recurrences.setter
    def maintenance_window_recurrences(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maintenance_window_recurrences", value)

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceWindowEnd")
    def time_maintenance_window_end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Start time of Maintenance window. A RFC3339 formatted datetime string
        """
        return pulumi.get(self, "time_maintenance_window_end")

    @time_maintenance_window_end.setter
    def time_maintenance_window_end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_maintenance_window_end", value)

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceWindowStart")
    def time_maintenance_window_start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Start time of Maintenance window. A RFC3339 formatted datetime string 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "time_maintenance_window_start")

    @time_maintenance_window_start.setter
    def time_maintenance_window_start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_maintenance_window_start", value)


if not MYPY:
    class MetricExtensionEnabledOnResourceArgsDict(TypedDict):
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the resource on which Metric Extension is enabled
        """
elif False:
    MetricExtensionEnabledOnResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricExtensionEnabledOnResourceArgs:
    def __init__(__self__, *,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] resource_id: The OCID of the resource on which Metric Extension is enabled
        """
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the resource on which Metric Extension is enabled
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class MetricExtensionMetricListArgsDict(TypedDict):
        data_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Data type of value of this metric
        """
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the metric.
        """
        compute_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Compute Expression to calculate the value of this metric
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Display name of the metric.
        """
        is_dimension: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Current metric need to be included as dimension or not
        """
        is_hidden: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Flag to marks whether a metric has to be uploaded or not. When isHidden = false > Metric is uploaded, isHidden = true > Metric is NOT uploaded
        """
        metric_category: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Metric category
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Unit of metric value
        """
elif False:
    MetricExtensionMetricListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricExtensionMetricListArgs:
    def __init__(__self__, *,
                 data_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 compute_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_dimension: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_hidden: Optional[pulumi.Input[_builtins.bool]] = None,
                 metric_category: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] data_type: (Updatable) Data type of value of this metric
        :param pulumi.Input[_builtins.str] name: (Updatable) Name of the metric.
        :param pulumi.Input[_builtins.str] compute_expression: (Updatable) Compute Expression to calculate the value of this metric
        :param pulumi.Input[_builtins.str] display_name: (Updatable) Display name of the metric.
        :param pulumi.Input[_builtins.bool] is_dimension: (Updatable) Current metric need to be included as dimension or not
        :param pulumi.Input[_builtins.bool] is_hidden: (Updatable) Flag to marks whether a metric has to be uploaded or not. When isHidden = false > Metric is uploaded, isHidden = true > Metric is NOT uploaded
        :param pulumi.Input[_builtins.str] metric_category: (Updatable) Metric category
        :param pulumi.Input[_builtins.str] unit: (Updatable) Unit of metric value
        """
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "name", name)
        if compute_expression is not None:
            pulumi.set(__self__, "compute_expression", compute_expression)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if is_dimension is not None:
            pulumi.set(__self__, "is_dimension", is_dimension)
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if metric_category is not None:
            pulumi.set(__self__, "metric_category", metric_category)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Data type of value of this metric
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the metric.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="computeExpression")
    def compute_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Compute Expression to calculate the value of this metric
        """
        return pulumi.get(self, "compute_expression")

    @compute_expression.setter
    def compute_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compute_expression", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Display name of the metric.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="isDimension")
    def is_dimension(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Current metric need to be included as dimension or not
        """
        return pulumi.get(self, "is_dimension")

    @is_dimension.setter
    def is_dimension(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_dimension", value)

    @_builtins.property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Flag to marks whether a metric has to be uploaded or not. When isHidden = false > Metric is uploaded, isHidden = true > Metric is NOT uploaded
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_hidden", value)

    @_builtins.property
    @pulumi.getter(name="metricCategory")
    def metric_category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Metric category
        """
        return pulumi.get(self, "metric_category")

    @metric_category.setter
    def metric_category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_category", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Unit of metric value
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class MetricExtensionQueryPropertiesArgsDict(TypedDict):
        collection_method: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of possible collection methods.
        """
        arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Arguments required by either command or script
        """
        auto_row_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Prefix for an auto generated metric, in case multiple rows with non unique key values are returned
        """
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OS command to execute without arguments
        """
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Character used to delimit multiple metric values in single line of output
        """
        identity_metric: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Semi-colon separated list of key properties from Managed Bean ObjectName to be used as key metrics
        """
        in_param_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricExtensionQueryPropertiesInParamDetailArgsDict']]]]
        """
        (Updatable) List of values and position of PL/SQL procedure IN parameters
        """
        is_metric_service_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Indicates if Metric Service is enabled on server domain
        """
        jmx_attributes: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) List of JMX attributes or Metric Service Table columns separated by semi-colon
        """
        managed_bean_query: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) JMX Managed Bean Query or Metric Service Table name
        """
        out_param_details: NotRequired[pulumi.Input['MetricExtensionQueryPropertiesOutParamDetailsArgsDict']]
        """
        (Updatable) Position and SQL Type of PL/SQL OUT parameter
        """
        protocol_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Supported protocol of resources to be associated with this metric extension. This is optional and defaults to HTTPS, which uses secure connection to the URL
        """
        response_content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Type of content response given by the http(s) URL
        """
        script_details: NotRequired[pulumi.Input['MetricExtensionQueryPropertiesScriptDetailsArgsDict']]
        """
        (Updatable) Script details applicable to any OS Command/HTTP based Metric Extension which needs to run a script to collect data. For removing it during OS Command based Metric Extension update, set its "content" property to an empty string. In that case, "name" property value is ignored.
        """
        sql_details: NotRequired[pulumi.Input['MetricExtensionQueryPropertiesSqlDetailsArgsDict']]
        """
        (Updatable) Details of Sql content which needs to execute to collect Metric Extension data
        """
        sql_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Type of SQL data collection method i.e. either a Statement or SQL Script File
        """
        starts_with: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) String prefix used to identify metric output of the OS Command
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Http(s) end point URL
        """
elif False:
    MetricExtensionQueryPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricExtensionQueryPropertiesArgs:
    def __init__(__self__, *,
                 collection_method: pulumi.Input[_builtins.str],
                 arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 auto_row_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_metric: Optional[pulumi.Input[_builtins.str]] = None,
                 in_param_details: Optional[pulumi.Input[Sequence[pulumi.Input['MetricExtensionQueryPropertiesInParamDetailArgs']]]] = None,
                 is_metric_service_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 jmx_attributes: Optional[pulumi.Input[_builtins.str]] = None,
                 managed_bean_query: Optional[pulumi.Input[_builtins.str]] = None,
                 out_param_details: Optional[pulumi.Input['MetricExtensionQueryPropertiesOutParamDetailsArgs']] = None,
                 protocol_type: Optional[pulumi.Input[_builtins.str]] = None,
                 response_content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 script_details: Optional[pulumi.Input['MetricExtensionQueryPropertiesScriptDetailsArgs']] = None,
                 sql_details: Optional[pulumi.Input['MetricExtensionQueryPropertiesSqlDetailsArgs']] = None,
                 sql_type: Optional[pulumi.Input[_builtins.str]] = None,
                 starts_with: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] collection_method: (Updatable) Type of possible collection methods.
        :param pulumi.Input[_builtins.str] arguments: (Updatable) Arguments required by either command or script
        :param pulumi.Input[_builtins.str] auto_row_prefix: (Updatable) Prefix for an auto generated metric, in case multiple rows with non unique key values are returned
        :param pulumi.Input[_builtins.str] command: (Updatable) OS command to execute without arguments
        :param pulumi.Input[_builtins.str] delimiter: (Updatable) Character used to delimit multiple metric values in single line of output
        :param pulumi.Input[_builtins.str] identity_metric: (Updatable) Semi-colon separated list of key properties from Managed Bean ObjectName to be used as key metrics
        :param pulumi.Input[Sequence[pulumi.Input['MetricExtensionQueryPropertiesInParamDetailArgs']]] in_param_details: (Updatable) List of values and position of PL/SQL procedure IN parameters
        :param pulumi.Input[_builtins.bool] is_metric_service_enabled: (Updatable) Indicates if Metric Service is enabled on server domain
        :param pulumi.Input[_builtins.str] jmx_attributes: (Updatable) List of JMX attributes or Metric Service Table columns separated by semi-colon
        :param pulumi.Input[_builtins.str] managed_bean_query: (Updatable) JMX Managed Bean Query or Metric Service Table name
        :param pulumi.Input['MetricExtensionQueryPropertiesOutParamDetailsArgs'] out_param_details: (Updatable) Position and SQL Type of PL/SQL OUT parameter
        :param pulumi.Input[_builtins.str] protocol_type: (Updatable) Supported protocol of resources to be associated with this metric extension. This is optional and defaults to HTTPS, which uses secure connection to the URL
        :param pulumi.Input[_builtins.str] response_content_type: (Updatable) Type of content response given by the http(s) URL
        :param pulumi.Input['MetricExtensionQueryPropertiesScriptDetailsArgs'] script_details: (Updatable) Script details applicable to any OS Command/HTTP based Metric Extension which needs to run a script to collect data. For removing it during OS Command based Metric Extension update, set its "content" property to an empty string. In that case, "name" property value is ignored.
        :param pulumi.Input['MetricExtensionQueryPropertiesSqlDetailsArgs'] sql_details: (Updatable) Details of Sql content which needs to execute to collect Metric Extension data
        :param pulumi.Input[_builtins.str] sql_type: (Updatable) Type of SQL data collection method i.e. either a Statement or SQL Script File
        :param pulumi.Input[_builtins.str] starts_with: (Updatable) String prefix used to identify metric output of the OS Command
        :param pulumi.Input[_builtins.str] url: (Updatable) Http(s) end point URL
        """
        pulumi.set(__self__, "collection_method", collection_method)
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if auto_row_prefix is not None:
            pulumi.set(__self__, "auto_row_prefix", auto_row_prefix)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if identity_metric is not None:
            pulumi.set(__self__, "identity_metric", identity_metric)
        if in_param_details is not None:
            pulumi.set(__self__, "in_param_details", in_param_details)
        if is_metric_service_enabled is not None:
            pulumi.set(__self__, "is_metric_service_enabled", is_metric_service_enabled)
        if jmx_attributes is not None:
            pulumi.set(__self__, "jmx_attributes", jmx_attributes)
        if managed_bean_query is not None:
            pulumi.set(__self__, "managed_bean_query", managed_bean_query)
        if out_param_details is not None:
            pulumi.set(__self__, "out_param_details", out_param_details)
        if protocol_type is not None:
            pulumi.set(__self__, "protocol_type", protocol_type)
        if response_content_type is not None:
            pulumi.set(__self__, "response_content_type", response_content_type)
        if script_details is not None:
            pulumi.set(__self__, "script_details", script_details)
        if sql_details is not None:
            pulumi.set(__self__, "sql_details", sql_details)
        if sql_type is not None:
            pulumi.set(__self__, "sql_type", sql_type)
        if starts_with is not None:
            pulumi.set(__self__, "starts_with", starts_with)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="collectionMethod")
    def collection_method(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of possible collection methods.
        """
        return pulumi.get(self, "collection_method")

    @collection_method.setter
    def collection_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collection_method", value)

    @_builtins.property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Arguments required by either command or script
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "arguments", value)

    @_builtins.property
    @pulumi.getter(name="autoRowPrefix")
    def auto_row_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Prefix for an auto generated metric, in case multiple rows with non unique key values are returned
        """
        return pulumi.get(self, "auto_row_prefix")

    @auto_row_prefix.setter
    def auto_row_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auto_row_prefix", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OS command to execute without arguments
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Character used to delimit multiple metric values in single line of output
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="identityMetric")
    def identity_metric(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Semi-colon separated list of key properties from Managed Bean ObjectName to be used as key metrics
        """
        return pulumi.get(self, "identity_metric")

    @identity_metric.setter
    def identity_metric(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_metric", value)

    @_builtins.property
    @pulumi.getter(name="inParamDetails")
    def in_param_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricExtensionQueryPropertiesInParamDetailArgs']]]]:
        """
        (Updatable) List of values and position of PL/SQL procedure IN parameters
        """
        return pulumi.get(self, "in_param_details")

    @in_param_details.setter
    def in_param_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricExtensionQueryPropertiesInParamDetailArgs']]]]):
        pulumi.set(self, "in_param_details", value)

    @_builtins.property
    @pulumi.getter(name="isMetricServiceEnabled")
    def is_metric_service_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Indicates if Metric Service is enabled on server domain
        """
        return pulumi.get(self, "is_metric_service_enabled")

    @is_metric_service_enabled.setter
    def is_metric_service_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_metric_service_enabled", value)

    @_builtins.property
    @pulumi.getter(name="jmxAttributes")
    def jmx_attributes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) List of JMX attributes or Metric Service Table columns separated by semi-colon
        """
        return pulumi.get(self, "jmx_attributes")

    @jmx_attributes.setter
    def jmx_attributes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jmx_attributes", value)

    @_builtins.property
    @pulumi.getter(name="managedBeanQuery")
    def managed_bean_query(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) JMX Managed Bean Query or Metric Service Table name
        """
        return pulumi.get(self, "managed_bean_query")

    @managed_bean_query.setter
    def managed_bean_query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "managed_bean_query", value)

    @_builtins.property
    @pulumi.getter(name="outParamDetails")
    def out_param_details(self) -> Optional[pulumi.Input['MetricExtensionQueryPropertiesOutParamDetailsArgs']]:
        """
        (Updatable) Position and SQL Type of PL/SQL OUT parameter
        """
        return pulumi.get(self, "out_param_details")

    @out_param_details.setter
    def out_param_details(self, value: Optional[pulumi.Input['MetricExtensionQueryPropertiesOutParamDetailsArgs']]):
        pulumi.set(self, "out_param_details", value)

    @_builtins.property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Supported protocol of resources to be associated with this metric extension. This is optional and defaults to HTTPS, which uses secure connection to the URL
        """
        return pulumi.get(self, "protocol_type")

    @protocol_type.setter
    def protocol_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol_type", value)

    @_builtins.property
    @pulumi.getter(name="responseContentType")
    def response_content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Type of content response given by the http(s) URL
        """
        return pulumi.get(self, "response_content_type")

    @response_content_type.setter
    def response_content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_content_type", value)

    @_builtins.property
    @pulumi.getter(name="scriptDetails")
    def script_details(self) -> Optional[pulumi.Input['MetricExtensionQueryPropertiesScriptDetailsArgs']]:
        """
        (Updatable) Script details applicable to any OS Command/HTTP based Metric Extension which needs to run a script to collect data. For removing it during OS Command based Metric Extension update, set its "content" property to an empty string. In that case, "name" property value is ignored.
        """
        return pulumi.get(self, "script_details")

    @script_details.setter
    def script_details(self, value: Optional[pulumi.Input['MetricExtensionQueryPropertiesScriptDetailsArgs']]):
        pulumi.set(self, "script_details", value)

    @_builtins.property
    @pulumi.getter(name="sqlDetails")
    def sql_details(self) -> Optional[pulumi.Input['MetricExtensionQueryPropertiesSqlDetailsArgs']]:
        """
        (Updatable) Details of Sql content which needs to execute to collect Metric Extension data
        """
        return pulumi.get(self, "sql_details")

    @sql_details.setter
    def sql_details(self, value: Optional[pulumi.Input['MetricExtensionQueryPropertiesSqlDetailsArgs']]):
        pulumi.set(self, "sql_details", value)

    @_builtins.property
    @pulumi.getter(name="sqlType")
    def sql_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Type of SQL data collection method i.e. either a Statement or SQL Script File
        """
        return pulumi.get(self, "sql_type")

    @sql_type.setter
    def sql_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sql_type", value)

    @_builtins.property
    @pulumi.getter(name="startsWith")
    def starts_with(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) String prefix used to identify metric output of the OS Command
        """
        return pulumi.get(self, "starts_with")

    @starts_with.setter
    def starts_with(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "starts_with", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Http(s) end point URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class MetricExtensionQueryPropertiesInParamDetailArgsDict(TypedDict):
        in_param_position: pulumi.Input[_builtins.int]
        """
        (Updatable) Position of IN parameter
        """
        in_param_value: pulumi.Input[_builtins.str]
        """
        (Updatable) Value of IN parameter
        """
elif False:
    MetricExtensionQueryPropertiesInParamDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricExtensionQueryPropertiesInParamDetailArgs:
    def __init__(__self__, *,
                 in_param_position: pulumi.Input[_builtins.int],
                 in_param_value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] in_param_position: (Updatable) Position of IN parameter
        :param pulumi.Input[_builtins.str] in_param_value: (Updatable) Value of IN parameter
        """
        pulumi.set(__self__, "in_param_position", in_param_position)
        pulumi.set(__self__, "in_param_value", in_param_value)

    @_builtins.property
    @pulumi.getter(name="inParamPosition")
    def in_param_position(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Position of IN parameter
        """
        return pulumi.get(self, "in_param_position")

    @in_param_position.setter
    def in_param_position(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "in_param_position", value)

    @_builtins.property
    @pulumi.getter(name="inParamValue")
    def in_param_value(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Value of IN parameter
        """
        return pulumi.get(self, "in_param_value")

    @in_param_value.setter
    def in_param_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "in_param_value", value)


if not MYPY:
    class MetricExtensionQueryPropertiesOutParamDetailsArgsDict(TypedDict):
        out_param_position: pulumi.Input[_builtins.int]
        """
        (Updatable) Position of PL/SQL procedure OUT parameter. The value of this property is ignored during update, if "outParamType" is set to NO_OUT_PARAM value.
        """
        out_param_type: pulumi.Input[_builtins.str]
        """
        (Updatable) SQL Type of PL/SQL procedure OUT parameter. During the update, to completely remove the out parameter, use the value NO_OUT_PARAM. In that case, the value of "outParamPosition" will be ignored.
        """
        out_param_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of the Out Parameter
        """
elif False:
    MetricExtensionQueryPropertiesOutParamDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricExtensionQueryPropertiesOutParamDetailsArgs:
    def __init__(__self__, *,
                 out_param_position: pulumi.Input[_builtins.int],
                 out_param_type: pulumi.Input[_builtins.str],
                 out_param_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] out_param_position: (Updatable) Position of PL/SQL procedure OUT parameter. The value of this property is ignored during update, if "outParamType" is set to NO_OUT_PARAM value.
        :param pulumi.Input[_builtins.str] out_param_type: (Updatable) SQL Type of PL/SQL procedure OUT parameter. During the update, to completely remove the out parameter, use the value NO_OUT_PARAM. In that case, the value of "outParamPosition" will be ignored.
        :param pulumi.Input[_builtins.str] out_param_name: (Updatable) Name of the Out Parameter
        """
        pulumi.set(__self__, "out_param_position", out_param_position)
        pulumi.set(__self__, "out_param_type", out_param_type)
        if out_param_name is not None:
            pulumi.set(__self__, "out_param_name", out_param_name)

    @_builtins.property
    @pulumi.getter(name="outParamPosition")
    def out_param_position(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Position of PL/SQL procedure OUT parameter. The value of this property is ignored during update, if "outParamType" is set to NO_OUT_PARAM value.
        """
        return pulumi.get(self, "out_param_position")

    @out_param_position.setter
    def out_param_position(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "out_param_position", value)

    @_builtins.property
    @pulumi.getter(name="outParamType")
    def out_param_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) SQL Type of PL/SQL procedure OUT parameter. During the update, to completely remove the out parameter, use the value NO_OUT_PARAM. In that case, the value of "outParamPosition" will be ignored.
        """
        return pulumi.get(self, "out_param_type")

    @out_param_type.setter
    def out_param_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "out_param_type", value)

    @_builtins.property
    @pulumi.getter(name="outParamName")
    def out_param_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of the Out Parameter
        """
        return pulumi.get(self, "out_param_name")

    @out_param_name.setter
    def out_param_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "out_param_name", value)


if not MYPY:
    class MetricExtensionQueryPropertiesScriptDetailsArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        (Updatable) Content of the script/JavaScript file as base64 encoded string
        """
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the script file
        """
elif False:
    MetricExtensionQueryPropertiesScriptDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricExtensionQueryPropertiesScriptDetailsArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] content: (Updatable) Content of the script/JavaScript file as base64 encoded string
        :param pulumi.Input[_builtins.str] name: (Updatable) Name of the script file
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Content of the script/JavaScript file as base64 encoded string
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the script file
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MetricExtensionQueryPropertiesSqlDetailsArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        (Updatable) Sql statement or script file content as base64 encoded string
        """
        script_file_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) If a script needs to be executed, then provide file name of the script
        """
elif False:
    MetricExtensionQueryPropertiesSqlDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricExtensionQueryPropertiesSqlDetailsArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 script_file_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: (Updatable) Sql statement or script file content as base64 encoded string
        :param pulumi.Input[_builtins.str] script_file_name: (Updatable) If a script needs to be executed, then provide file name of the script
        """
        pulumi.set(__self__, "content", content)
        if script_file_name is not None:
            pulumi.set(__self__, "script_file_name", script_file_name)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Sql statement or script file content as base64 encoded string
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="scriptFileName")
    def script_file_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) If a script needs to be executed, then provide file name of the script
        """
        return pulumi.get(self, "script_file_name")

    @script_file_name.setter
    def script_file_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "script_file_name", value)


if not MYPY:
    class MonitoredResourceAdditionalAliasArgsDict(TypedDict):
        credential: pulumi.Input['MonitoredResourceAdditionalAliasCredentialArgsDict']
        """
        (Updatable) Monitored Resource Alias Reference Source Credential.
        """
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the alias, within the context of the source.
        """
        source: pulumi.Input[_builtins.str]
        """
        (Updatable) The source type and source name combination,delimited with (.) separator. Example: {source type}.{source name} and source type max char limit is 63.
        """
elif False:
    MonitoredResourceAdditionalAliasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceAdditionalAliasArgs:
    def __init__(__self__, *,
                 credential: pulumi.Input['MonitoredResourceAdditionalAliasCredentialArgs'],
                 name: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['MonitoredResourceAdditionalAliasCredentialArgs'] credential: (Updatable) Monitored Resource Alias Reference Source Credential.
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the alias, within the context of the source.
        :param pulumi.Input[_builtins.str] source: (Updatable) The source type and source name combination,delimited with (.) separator. Example: {source type}.{source name} and source type max char limit is 63.
        """
        pulumi.set(__self__, "credential", credential)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def credential(self) -> pulumi.Input['MonitoredResourceAdditionalAliasCredentialArgs']:
        """
        (Updatable) Monitored Resource Alias Reference Source Credential.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: pulumi.Input['MonitoredResourceAdditionalAliasCredentialArgs']):
        pulumi.set(self, "credential", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the alias, within the context of the source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The source type and source name combination,delimited with (.) separator. Example: {source type}.{source name} and source type max char limit is 63.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class MonitoredResourceAdditionalAliasCredentialArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the pre-existing source credential which alias cred should point to. This should refer to the pre-existing source attribute which is bound to credential name.
        """
        service: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the service owning the credential.  Example: stack-monitoring or dbmgmt
        """
        source: pulumi.Input[_builtins.str]
        """
        (Updatable) The source type and source name combination,delimited with (.) separator. This refers to the pre-existing source which alias cred should point to. Ex. {source type}.{source name} and source type max char limit is 63.
        """
elif False:
    MonitoredResourceAdditionalAliasCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceAdditionalAliasCredentialArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 service: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the pre-existing source credential which alias cred should point to. This should refer to the pre-existing source attribute which is bound to credential name.
        :param pulumi.Input[_builtins.str] service: (Updatable) The name of the service owning the credential.  Example: stack-monitoring or dbmgmt
        :param pulumi.Input[_builtins.str] source: (Updatable) The source type and source name combination,delimited with (.) separator. This refers to the pre-existing source which alias cred should point to. Ex. {source type}.{source name} and source type max char limit is 63.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the pre-existing source credential which alias cred should point to. This should refer to the pre-existing source attribute which is bound to credential name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the service owning the credential.  Example: stack-monitoring or dbmgmt
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The source type and source name combination,delimited with (.) separator. This refers to the pre-existing source which alias cred should point to. Ex. {source type}.{source name} and source type max char limit is 63.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class MonitoredResourceAdditionalCredentialArgsDict(TypedDict):
        credential_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Type of credentials specified in the credentials element. Three possible values - EXISTING, PLAINTEXT and ENCRYPTED.
        * EXISTING  - Credential is already stored in agent and only credential name need to be passed for existing credential.
        * PLAINTEXT - The credential properties will have credentials in plain text format.
        * ENCRYPTED - The credential properties will have credentials stored in vault in encrypted format using KMS client which uses master key for encryption. The same master key will be used to decrypt the credentials before passing on to the management agent.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The user-specified textual description of the credential.
        """
        key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The master key should be created in Oracle Cloud Infrastructure Vault owned by the client of this API.  The user should have permission to access the vault key.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the credential, within the context of the source.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceAdditionalCredentialPropertyArgsDict']]]]
        """
        (Updatable) The credential properties list. Credential property values will be either  in plain text format or encrypted for encrypted credentials.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The source type and source name combination, delimited with (.) separator. {source type}.{source name} and source type max char limit is 63.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of the credential ( ex. JMXCreds,DBCreds).
        """
elif False:
    MonitoredResourceAdditionalCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceAdditionalCredentialArgs:
    def __init__(__self__, *,
                 credential_type: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceAdditionalCredentialPropertyArgs']]]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] credential_type: (Updatable) Type of credentials specified in the credentials element. Three possible values - EXISTING, PLAINTEXT and ENCRYPTED.
               * EXISTING  - Credential is already stored in agent and only credential name need to be passed for existing credential.
               * PLAINTEXT - The credential properties will have credentials in plain text format.
               * ENCRYPTED - The credential properties will have credentials stored in vault in encrypted format using KMS client which uses master key for encryption. The same master key will be used to decrypt the credentials before passing on to the management agent.
        :param pulumi.Input[_builtins.str] description: (Updatable) The user-specified textual description of the credential.
        :param pulumi.Input[_builtins.str] key_id: (Updatable) The master key should be created in Oracle Cloud Infrastructure Vault owned by the client of this API.  The user should have permission to access the vault key.
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the credential, within the context of the source.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceAdditionalCredentialPropertyArgs']]] properties: (Updatable) The credential properties list. Credential property values will be either  in plain text format or encrypted for encrypted credentials.
        :param pulumi.Input[_builtins.str] source: (Updatable) The source type and source name combination, delimited with (.) separator. {source type}.{source name} and source type max char limit is 63.
        :param pulumi.Input[_builtins.str] type: (Updatable) The type of the credential ( ex. JMXCreds,DBCreds).
        """
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Type of credentials specified in the credentials element. Three possible values - EXISTING, PLAINTEXT and ENCRYPTED.
        * EXISTING  - Credential is already stored in agent and only credential name need to be passed for existing credential.
        * PLAINTEXT - The credential properties will have credentials in plain text format.
        * ENCRYPTED - The credential properties will have credentials stored in vault in encrypted format using KMS client which uses master key for encryption. The same master key will be used to decrypt the credentials before passing on to the management agent.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "credential_type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The user-specified textual description of the credential.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The master key should be created in Oracle Cloud Infrastructure Vault owned by the client of this API.  The user should have permission to access the vault key.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the credential, within the context of the source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceAdditionalCredentialPropertyArgs']]]]:
        """
        (Updatable) The credential properties list. Credential property values will be either  in plain text format or encrypted for encrypted credentials.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceAdditionalCredentialPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The source type and source name combination, delimited with (.) separator. {source type}.{source name} and source type max char limit is 63.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of the credential ( ex. JMXCreds,DBCreds).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MonitoredResourceAdditionalCredentialPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the credential property, should confirm with names of properties of this credential's type.  Example: For JMXCreds type, credential property name for weblogic user is 'Username'.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The value of the credential property name. Example: For JMXCreds type, credential property value for 'Username' property is 'weblogic'.
        """
elif False:
    MonitoredResourceAdditionalCredentialPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceAdditionalCredentialPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the credential property, should confirm with names of properties of this credential's type.  Example: For JMXCreds type, credential property name for weblogic user is 'Username'.
        :param pulumi.Input[_builtins.str] value: (Updatable) The value of the credential property name. Example: For JMXCreds type, credential property value for 'Username' property is 'weblogic'.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the credential property, should confirm with names of properties of this credential's type.  Example: For JMXCreds type, credential property name for weblogic user is 'Username'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The value of the credential property name. Example: For JMXCreds type, credential property value for 'Username' property is 'weblogic'.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MonitoredResourceAliasesArgsDict(TypedDict):
        credential: pulumi.Input['MonitoredResourceAliasesCredentialArgsDict']
        """
        (Updatable) Monitored Resource Alias Reference Source Credential.
        """
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the alias, within the context of the source.
        """
        source: pulumi.Input[_builtins.str]
        """
        (Updatable) The source type and source name combination,delimited with (.) separator. Example: {source type}.{source name} and source type max char limit is 63.
        """
elif False:
    MonitoredResourceAliasesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceAliasesArgs:
    def __init__(__self__, *,
                 credential: pulumi.Input['MonitoredResourceAliasesCredentialArgs'],
                 name: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['MonitoredResourceAliasesCredentialArgs'] credential: (Updatable) Monitored Resource Alias Reference Source Credential.
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the alias, within the context of the source.
        :param pulumi.Input[_builtins.str] source: (Updatable) The source type and source name combination,delimited with (.) separator. Example: {source type}.{source name} and source type max char limit is 63.
        """
        pulumi.set(__self__, "credential", credential)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def credential(self) -> pulumi.Input['MonitoredResourceAliasesCredentialArgs']:
        """
        (Updatable) Monitored Resource Alias Reference Source Credential.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: pulumi.Input['MonitoredResourceAliasesCredentialArgs']):
        pulumi.set(self, "credential", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the alias, within the context of the source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The source type and source name combination,delimited with (.) separator. Example: {source type}.{source name} and source type max char limit is 63.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class MonitoredResourceAliasesCredentialArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the pre-existing source credential which alias cred should point to. This should refer to the pre-existing source attribute which is bound to credential name.
        """
        service: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the service owning the credential.  Example: stack-monitoring or dbmgmt
        """
        source: pulumi.Input[_builtins.str]
        """
        (Updatable) The source type and source name combination,delimited with (.) separator. This refers to the pre-existing source which alias cred should point to. Ex. {source type}.{source name} and source type max char limit is 63.
        """
elif False:
    MonitoredResourceAliasesCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceAliasesCredentialArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 service: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the pre-existing source credential which alias cred should point to. This should refer to the pre-existing source attribute which is bound to credential name.
        :param pulumi.Input[_builtins.str] service: (Updatable) The name of the service owning the credential.  Example: stack-monitoring or dbmgmt
        :param pulumi.Input[_builtins.str] source: (Updatable) The source type and source name combination,delimited with (.) separator. This refers to the pre-existing source which alias cred should point to. Ex. {source type}.{source name} and source type max char limit is 63.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the pre-existing source credential which alias cred should point to. This should refer to the pre-existing source attribute which is bound to credential name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the service owning the credential.  Example: stack-monitoring or dbmgmt
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The source type and source name combination,delimited with (.) separator. This refers to the pre-existing source which alias cred should point to. Ex. {source type}.{source name} and source type max char limit is 63.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class MonitoredResourceCredentialsArgsDict(TypedDict):
        credential_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Type of credentials specified in the credentials element. Three possible values - EXISTING, PLAINTEXT and ENCRYPTED.
        * EXISTING  - Credential is already stored in agent and only credential name need to be passed for existing credential.
        * PLAINTEXT - The credential properties will have credentials in plain text format.
        * ENCRYPTED - The credential properties will have credentials stored in vault in encrypted format using KMS client which uses master key for encryption. The same master key will be used to decrypt the credentials before passing on to the management agent.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The user-specified textual description of the credential.
        """
        key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The master key should be created in Oracle Cloud Infrastructure Vault owned by the client of this API.  The user should have permission to access the vault key.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the credential, within the context of the source.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceCredentialsPropertyArgsDict']]]]
        """
        (Updatable) The credential properties list. Credential property values will be either  in plain text format or encrypted for encrypted credentials.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The source type and source name combination, delimited with (.) separator. {source type}.{source name} and source type max char limit is 63.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of the credential ( ex. JMXCreds,DBCreds).
        """
elif False:
    MonitoredResourceCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceCredentialsArgs:
    def __init__(__self__, *,
                 credential_type: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceCredentialsPropertyArgs']]]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] credential_type: (Updatable) Type of credentials specified in the credentials element. Three possible values - EXISTING, PLAINTEXT and ENCRYPTED.
               * EXISTING  - Credential is already stored in agent and only credential name need to be passed for existing credential.
               * PLAINTEXT - The credential properties will have credentials in plain text format.
               * ENCRYPTED - The credential properties will have credentials stored in vault in encrypted format using KMS client which uses master key for encryption. The same master key will be used to decrypt the credentials before passing on to the management agent.
        :param pulumi.Input[_builtins.str] description: (Updatable) The user-specified textual description of the credential.
        :param pulumi.Input[_builtins.str] key_id: (Updatable) The master key should be created in Oracle Cloud Infrastructure Vault owned by the client of this API.  The user should have permission to access the vault key.
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the credential, within the context of the source.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceCredentialsPropertyArgs']]] properties: (Updatable) The credential properties list. Credential property values will be either  in plain text format or encrypted for encrypted credentials.
        :param pulumi.Input[_builtins.str] source: (Updatable) The source type and source name combination, delimited with (.) separator. {source type}.{source name} and source type max char limit is 63.
        :param pulumi.Input[_builtins.str] type: (Updatable) The type of the credential ( ex. JMXCreds,DBCreds).
        """
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Type of credentials specified in the credentials element. Three possible values - EXISTING, PLAINTEXT and ENCRYPTED.
        * EXISTING  - Credential is already stored in agent and only credential name need to be passed for existing credential.
        * PLAINTEXT - The credential properties will have credentials in plain text format.
        * ENCRYPTED - The credential properties will have credentials stored in vault in encrypted format using KMS client which uses master key for encryption. The same master key will be used to decrypt the credentials before passing on to the management agent.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "credential_type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The user-specified textual description of the credential.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The master key should be created in Oracle Cloud Infrastructure Vault owned by the client of this API.  The user should have permission to access the vault key.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the credential, within the context of the source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceCredentialsPropertyArgs']]]]:
        """
        (Updatable) The credential properties list. Credential property values will be either  in plain text format or encrypted for encrypted credentials.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceCredentialsPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The source type and source name combination, delimited with (.) separator. {source type}.{source name} and source type max char limit is 63.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of the credential ( ex. JMXCreds,DBCreds).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MonitoredResourceCredentialsPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the credential property, should confirm with names of properties of this credential's type.  Example: For JMXCreds type, credential property name for weblogic user is 'Username'.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The value of the credential property name. Example: For JMXCreds type, credential property value for 'Username' property is 'weblogic'.
        """
elif False:
    MonitoredResourceCredentialsPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceCredentialsPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the credential property, should confirm with names of properties of this credential's type.  Example: For JMXCreds type, credential property name for weblogic user is 'Username'.
        :param pulumi.Input[_builtins.str] value: (Updatable) The value of the credential property name. Example: For JMXCreds type, credential property value for 'Username' property is 'weblogic'.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the credential property, should confirm with names of properties of this credential's type.  Example: For JMXCreds type, credential property name for weblogic user is 'Username'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The value of the credential property name. Example: For JMXCreds type, credential property value for 'Username' property is 'weblogic'.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MonitoredResourceDatabaseConnectionDetailsArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        (Updatable) Listener Port number used for connection requests.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        (Updatable) Protocol used in DB connection string when connecting to external database service.
        """
        service_name: pulumi.Input[_builtins.str]
        """
        (Updatable) Service name used for connection requests.
        """
        connector_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Database connector Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        db_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) dbId of the database.
        """
        db_unique_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) UniqueName used for database connection requests.
        """
        ssl_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) SSL Secret Identifier for TCPS connector in Oracle Cloud Infrastructure Vault[OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
elif False:
    MonitoredResourceDatabaseConnectionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceDatabaseConnectionDetailsArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 service_name: pulumi.Input[_builtins.str],
                 connector_id: Optional[pulumi.Input[_builtins.str]] = None,
                 db_id: Optional[pulumi.Input[_builtins.str]] = None,
                 db_unique_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_secret_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] port: (Updatable) Listener Port number used for connection requests.
        :param pulumi.Input[_builtins.str] protocol: (Updatable) Protocol used in DB connection string when connecting to external database service.
        :param pulumi.Input[_builtins.str] service_name: (Updatable) Service name used for connection requests.
        :param pulumi.Input[_builtins.str] connector_id: (Updatable) Database connector Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[_builtins.str] db_id: (Updatable) dbId of the database.
        :param pulumi.Input[_builtins.str] db_unique_name: (Updatable) UniqueName used for database connection requests.
        :param pulumi.Input[_builtins.str] ssl_secret_id: (Updatable) SSL Secret Identifier for TCPS connector in Oracle Cloud Infrastructure Vault[OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "service_name", service_name)
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if db_id is not None:
            pulumi.set(__self__, "db_id", db_id)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if ssl_secret_id is not None:
            pulumi.set(__self__, "ssl_secret_id", ssl_secret_id)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Listener Port number used for connection requests.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Protocol used in DB connection string when connecting to external database service.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Service name used for connection requests.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_name", value)

    @_builtins.property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Database connector Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connector_id", value)

    @_builtins.property
    @pulumi.getter(name="dbId")
    def db_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) dbId of the database.
        """
        return pulumi.get(self, "db_id")

    @db_id.setter
    def db_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_id", value)

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) UniqueName used for database connection requests.
        """
        return pulumi.get(self, "db_unique_name")

    @db_unique_name.setter
    def db_unique_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_unique_name", value)

    @_builtins.property
    @pulumi.getter(name="sslSecretId")
    def ssl_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) SSL Secret Identifier for TCPS connector in Oracle Cloud Infrastructure Vault[OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "ssl_secret_id")

    @ssl_secret_id.setter
    def ssl_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_secret_id", value)


if not MYPY:
    class MonitoredResourcePropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Property Name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Property Value.
        """
elif False:
    MonitoredResourcePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourcePropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) Property Name.
        :param pulumi.Input[_builtins.str] value: (Updatable) Property Value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Property Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Property Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MonitoredResourceTaskTaskDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Task type.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        agent_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Management Agent Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        availability_proxy_metric_collection_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metrics collection interval in seconds used when calculating the availability of the  resource based on metrics specified using the property 'availabilityProxyMetrics'.
        """
        availability_proxy_metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of metrics to be used to calculate the availability of the resource. Resource is considered to be up if at least one of the specified metrics is available for  the resource during the specified interval using the property  'availabilityProxyMetricCollectionInterval'. If no metrics are specified, availability will not be calculated for the resource.
        """
        console_path_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The console path prefix to use for providing service home url page navigation.  For example if the prefix provided is 'security/bastion/bastions', the URL used for navigation will be https://<cloudhostname>/security/bastion/bastions/<resourceOcid>. If not provided, service home page link  will not be shown in the stack monitoring home page.
        """
        external_id_mapping: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external resource identifier property in the metric dimensions.  Resources imported will be using this property value for external id.
        """
        handler_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the handler.
        """
        is_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True to enable the receiver and false to disable the receiver on the agent.
        """
        lifecycle_status_mappings_for_up_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Lifecycle states of the external resource which reflects the status of the resource being up.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name space to be used for Oracle Cloud Infrastructure Native service resources discovery.
        """
        receiver_properties: NotRequired[pulumi.Input['MonitoredResourceTaskTaskDetailsReceiverPropertiesArgsDict']]
        """
        Properties for agent receiver.
        """
        resource_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource group to use while fetching metrics from telemetry. If not specified, resource group will be skipped in the list metrics request.
        """
        resource_name_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource name filter. Resources matching with the resource name filter will be imported. Regular expressions will be accepted.
        """
        resource_name_mapping: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource name property in the metric dimensions.  Resources imported will be using this property value for resource name.
        """
        resource_type_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource type filter. Resources matching with the resource type filter will be imported. Regular expressions will be accepted.
        """
        resource_type_mapping: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource type property in the metric dimensions.  Resources imported will be using this property value for resource type. If not specified, namespace will be used for resource type.
        """
        resource_types_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationArgsDict']]]]
        """
        A collection of resource type configuration details. User can provide  availability proxy metrics list for resource types along with the  telegraf/collectd handler configuration for the resource types.
        """
        service_base_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base URL of the Oracle Cloud Infrastructure service to which the resource belongs to. Also this property is applicable only when source is OCI_TELEMETRY_NATIVE.
        """
        should_use_metrics_flow_for_status: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag to indicate whether status is calculated using metrics or  LifeCycleState attribute of the resource in Oracle Cloud Infrastructure service.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source from where the metrics pushed to telemetry. Possible values:
        * OCI_TELEMETRY_NATIVE      - The metrics are pushed to telemetry from Oracle Cloud Infrastructure Native Services.
        * OCI_TELEMETRY_PROMETHEUS  - The metrics are pushed to telemetry from Prometheus.
        * OCI_TELEMETRY_TELEGRAF    - The metrics are pushed to telemetry from Telegraf receiver.
        * OCI_TELEMETRY_COLLECTD    - The metrics are pushed to telemetry from CollectD receiver.
        """
elif False:
    MonitoredResourceTaskTaskDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTaskTaskDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 agent_id: Optional[pulumi.Input[_builtins.str]] = None,
                 availability_proxy_metric_collection_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 availability_proxy_metrics: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 console_path_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id_mapping: Optional[pulumi.Input[_builtins.str]] = None,
                 handler_type: Optional[pulumi.Input[_builtins.str]] = None,
                 is_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 lifecycle_status_mappings_for_up_statuses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 receiver_properties: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsReceiverPropertiesArgs']] = None,
                 resource_group: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_name_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_name_mapping: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type_mapping: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_types_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationArgs']]]] = None,
                 service_base_url: Optional[pulumi.Input[_builtins.str]] = None,
                 should_use_metrics_flow_for_status: Optional[pulumi.Input[_builtins.bool]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Task type.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] agent_id: Management Agent Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[_builtins.int] availability_proxy_metric_collection_interval: Metrics collection interval in seconds used when calculating the availability of the  resource based on metrics specified using the property 'availabilityProxyMetrics'.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] availability_proxy_metrics: List of metrics to be used to calculate the availability of the resource. Resource is considered to be up if at least one of the specified metrics is available for  the resource during the specified interval using the property  'availabilityProxyMetricCollectionInterval'. If no metrics are specified, availability will not be calculated for the resource.
        :param pulumi.Input[_builtins.str] console_path_prefix: The console path prefix to use for providing service home url page navigation.  For example if the prefix provided is 'security/bastion/bastions', the URL used for navigation will be https://<cloudhostname>/security/bastion/bastions/<resourceOcid>. If not provided, service home page link  will not be shown in the stack monitoring home page.
        :param pulumi.Input[_builtins.str] external_id_mapping: The external resource identifier property in the metric dimensions.  Resources imported will be using this property value for external id.
        :param pulumi.Input[_builtins.str] handler_type: Type of the handler.
        :param pulumi.Input[_builtins.bool] is_enable: True to enable the receiver and false to disable the receiver on the agent.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] lifecycle_status_mappings_for_up_statuses: Lifecycle states of the external resource which reflects the status of the resource being up.
        :param pulumi.Input[_builtins.str] namespace: Name space to be used for Oracle Cloud Infrastructure Native service resources discovery.
        :param pulumi.Input['MonitoredResourceTaskTaskDetailsReceiverPropertiesArgs'] receiver_properties: Properties for agent receiver.
        :param pulumi.Input[_builtins.str] resource_group: The resource group to use while fetching metrics from telemetry. If not specified, resource group will be skipped in the list metrics request.
        :param pulumi.Input[_builtins.str] resource_name_filter: The resource name filter. Resources matching with the resource name filter will be imported. Regular expressions will be accepted.
        :param pulumi.Input[_builtins.str] resource_name_mapping: The resource name property in the metric dimensions.  Resources imported will be using this property value for resource name.
        :param pulumi.Input[_builtins.str] resource_type_filter: The resource type filter. Resources matching with the resource type filter will be imported. Regular expressions will be accepted.
        :param pulumi.Input[_builtins.str] resource_type_mapping: The resource type property in the metric dimensions.  Resources imported will be using this property value for resource type. If not specified, namespace will be used for resource type.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationArgs']]] resource_types_configurations: A collection of resource type configuration details. User can provide  availability proxy metrics list for resource types along with the  telegraf/collectd handler configuration for the resource types.
        :param pulumi.Input[_builtins.str] service_base_url: The base URL of the Oracle Cloud Infrastructure service to which the resource belongs to. Also this property is applicable only when source is OCI_TELEMETRY_NATIVE.
        :param pulumi.Input[_builtins.bool] should_use_metrics_flow_for_status: Flag to indicate whether status is calculated using metrics or  LifeCycleState attribute of the resource in Oracle Cloud Infrastructure service.
        :param pulumi.Input[_builtins.str] source: Source from where the metrics pushed to telemetry. Possible values:
               * OCI_TELEMETRY_NATIVE      - The metrics are pushed to telemetry from Oracle Cloud Infrastructure Native Services.
               * OCI_TELEMETRY_PROMETHEUS  - The metrics are pushed to telemetry from Prometheus.
               * OCI_TELEMETRY_TELEGRAF    - The metrics are pushed to telemetry from Telegraf receiver.
               * OCI_TELEMETRY_COLLECTD    - The metrics are pushed to telemetry from CollectD receiver.
        """
        pulumi.set(__self__, "type", type)
        if agent_id is not None:
            pulumi.set(__self__, "agent_id", agent_id)
        if availability_proxy_metric_collection_interval is not None:
            pulumi.set(__self__, "availability_proxy_metric_collection_interval", availability_proxy_metric_collection_interval)
        if availability_proxy_metrics is not None:
            pulumi.set(__self__, "availability_proxy_metrics", availability_proxy_metrics)
        if console_path_prefix is not None:
            pulumi.set(__self__, "console_path_prefix", console_path_prefix)
        if external_id_mapping is not None:
            pulumi.set(__self__, "external_id_mapping", external_id_mapping)
        if handler_type is not None:
            pulumi.set(__self__, "handler_type", handler_type)
        if is_enable is not None:
            pulumi.set(__self__, "is_enable", is_enable)
        if lifecycle_status_mappings_for_up_statuses is not None:
            pulumi.set(__self__, "lifecycle_status_mappings_for_up_statuses", lifecycle_status_mappings_for_up_statuses)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if receiver_properties is not None:
            pulumi.set(__self__, "receiver_properties", receiver_properties)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_name_filter is not None:
            pulumi.set(__self__, "resource_name_filter", resource_name_filter)
        if resource_name_mapping is not None:
            pulumi.set(__self__, "resource_name_mapping", resource_name_mapping)
        if resource_type_filter is not None:
            pulumi.set(__self__, "resource_type_filter", resource_type_filter)
        if resource_type_mapping is not None:
            pulumi.set(__self__, "resource_type_mapping", resource_type_mapping)
        if resource_types_configurations is not None:
            pulumi.set(__self__, "resource_types_configurations", resource_types_configurations)
        if service_base_url is not None:
            pulumi.set(__self__, "service_base_url", service_base_url)
        if should_use_metrics_flow_for_status is not None:
            pulumi.set(__self__, "should_use_metrics_flow_for_status", should_use_metrics_flow_for_status)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Task type.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Management Agent Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "agent_id")

    @agent_id.setter
    def agent_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_id", value)

    @_builtins.property
    @pulumi.getter(name="availabilityProxyMetricCollectionInterval")
    def availability_proxy_metric_collection_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metrics collection interval in seconds used when calculating the availability of the  resource based on metrics specified using the property 'availabilityProxyMetrics'.
        """
        return pulumi.get(self, "availability_proxy_metric_collection_interval")

    @availability_proxy_metric_collection_interval.setter
    def availability_proxy_metric_collection_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "availability_proxy_metric_collection_interval", value)

    @_builtins.property
    @pulumi.getter(name="availabilityProxyMetrics")
    def availability_proxy_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of metrics to be used to calculate the availability of the resource. Resource is considered to be up if at least one of the specified metrics is available for  the resource during the specified interval using the property  'availabilityProxyMetricCollectionInterval'. If no metrics are specified, availability will not be calculated for the resource.
        """
        return pulumi.get(self, "availability_proxy_metrics")

    @availability_proxy_metrics.setter
    def availability_proxy_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "availability_proxy_metrics", value)

    @_builtins.property
    @pulumi.getter(name="consolePathPrefix")
    def console_path_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The console path prefix to use for providing service home url page navigation.  For example if the prefix provided is 'security/bastion/bastions', the URL used for navigation will be https://<cloudhostname>/security/bastion/bastions/<resourceOcid>. If not provided, service home page link  will not be shown in the stack monitoring home page.
        """
        return pulumi.get(self, "console_path_prefix")

    @console_path_prefix.setter
    def console_path_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "console_path_prefix", value)

    @_builtins.property
    @pulumi.getter(name="externalIdMapping")
    def external_id_mapping(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external resource identifier property in the metric dimensions.  Resources imported will be using this property value for external id.
        """
        return pulumi.get(self, "external_id_mapping")

    @external_id_mapping.setter
    def external_id_mapping(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id_mapping", value)

    @_builtins.property
    @pulumi.getter(name="handlerType")
    def handler_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the handler.
        """
        return pulumi.get(self, "handler_type")

    @handler_type.setter
    def handler_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "handler_type", value)

    @_builtins.property
    @pulumi.getter(name="isEnable")
    def is_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True to enable the receiver and false to disable the receiver on the agent.
        """
        return pulumi.get(self, "is_enable")

    @is_enable.setter
    def is_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enable", value)

    @_builtins.property
    @pulumi.getter(name="lifecycleStatusMappingsForUpStatuses")
    def lifecycle_status_mappings_for_up_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Lifecycle states of the external resource which reflects the status of the resource being up.
        """
        return pulumi.get(self, "lifecycle_status_mappings_for_up_statuses")

    @lifecycle_status_mappings_for_up_statuses.setter
    def lifecycle_status_mappings_for_up_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "lifecycle_status_mappings_for_up_statuses", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name space to be used for Oracle Cloud Infrastructure Native service resources discovery.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="receiverProperties")
    def receiver_properties(self) -> Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsReceiverPropertiesArgs']]:
        """
        Properties for agent receiver.
        """
        return pulumi.get(self, "receiver_properties")

    @receiver_properties.setter
    def receiver_properties(self, value: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsReceiverPropertiesArgs']]):
        pulumi.set(self, "receiver_properties", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource group to use while fetching metrics from telemetry. If not specified, resource group will be skipped in the list metrics request.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group", value)

    @_builtins.property
    @pulumi.getter(name="resourceNameFilter")
    def resource_name_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource name filter. Resources matching with the resource name filter will be imported. Regular expressions will be accepted.
        """
        return pulumi.get(self, "resource_name_filter")

    @resource_name_filter.setter
    def resource_name_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_name_filter", value)

    @_builtins.property
    @pulumi.getter(name="resourceNameMapping")
    def resource_name_mapping(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource name property in the metric dimensions.  Resources imported will be using this property value for resource name.
        """
        return pulumi.get(self, "resource_name_mapping")

    @resource_name_mapping.setter
    def resource_name_mapping(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_name_mapping", value)

    @_builtins.property
    @pulumi.getter(name="resourceTypeFilter")
    def resource_type_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource type filter. Resources matching with the resource type filter will be imported. Regular expressions will be accepted.
        """
        return pulumi.get(self, "resource_type_filter")

    @resource_type_filter.setter
    def resource_type_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type_filter", value)

    @_builtins.property
    @pulumi.getter(name="resourceTypeMapping")
    def resource_type_mapping(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource type property in the metric dimensions.  Resources imported will be using this property value for resource type. If not specified, namespace will be used for resource type.
        """
        return pulumi.get(self, "resource_type_mapping")

    @resource_type_mapping.setter
    def resource_type_mapping(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type_mapping", value)

    @_builtins.property
    @pulumi.getter(name="resourceTypesConfigurations")
    def resource_types_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationArgs']]]]:
        """
        A collection of resource type configuration details. User can provide  availability proxy metrics list for resource types along with the  telegraf/collectd handler configuration for the resource types.
        """
        return pulumi.get(self, "resource_types_configurations")

    @resource_types_configurations.setter
    def resource_types_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationArgs']]]]):
        pulumi.set(self, "resource_types_configurations", value)

    @_builtins.property
    @pulumi.getter(name="serviceBaseUrl")
    def service_base_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base URL of the Oracle Cloud Infrastructure service to which the resource belongs to. Also this property is applicable only when source is OCI_TELEMETRY_NATIVE.
        """
        return pulumi.get(self, "service_base_url")

    @service_base_url.setter
    def service_base_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_base_url", value)

    @_builtins.property
    @pulumi.getter(name="shouldUseMetricsFlowForStatus")
    def should_use_metrics_flow_for_status(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag to indicate whether status is calculated using metrics or  LifeCycleState attribute of the resource in Oracle Cloud Infrastructure service.
        """
        return pulumi.get(self, "should_use_metrics_flow_for_status")

    @should_use_metrics_flow_for_status.setter
    def should_use_metrics_flow_for_status(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_use_metrics_flow_for_status", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source from where the metrics pushed to telemetry. Possible values:
        * OCI_TELEMETRY_NATIVE      - The metrics are pushed to telemetry from Oracle Cloud Infrastructure Native Services.
        * OCI_TELEMETRY_PROMETHEUS  - The metrics are pushed to telemetry from Prometheus.
        * OCI_TELEMETRY_TELEGRAF    - The metrics are pushed to telemetry from Telegraf receiver.
        * OCI_TELEMETRY_COLLECTD    - The metrics are pushed to telemetry from CollectD receiver.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class MonitoredResourceTaskTaskDetailsReceiverPropertiesArgsDict(TypedDict):
        listener_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Receiver listener port.
        """
elif False:
    MonitoredResourceTaskTaskDetailsReceiverPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTaskTaskDetailsReceiverPropertiesArgs:
    def __init__(__self__, *,
                 listener_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] listener_port: Receiver listener port.
        """
        if listener_port is not None:
            pulumi.set(__self__, "listener_port", listener_port)

    @_builtins.property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Receiver listener port.
        """
        return pulumi.get(self, "listener_port")

    @listener_port.setter
    def listener_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "listener_port", value)


if not MYPY:
    class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationArgsDict(TypedDict):
        availability_metrics_config: NotRequired[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationAvailabilityMetricsConfigArgsDict']]
        """
        Availability metrics details.
        """
        handler_config: NotRequired[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigArgsDict']]
        """
        Specific resource mapping configurations for Agent Extension Handlers.
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource type.
        """
elif False:
    MonitoredResourceTaskTaskDetailsResourceTypesConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationArgs:
    def __init__(__self__, *,
                 availability_metrics_config: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationAvailabilityMetricsConfigArgs']] = None,
                 handler_config: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigArgs']] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationAvailabilityMetricsConfigArgs'] availability_metrics_config: Availability metrics details.
        :param pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigArgs'] handler_config: Specific resource mapping configurations for Agent Extension Handlers.
        :param pulumi.Input[_builtins.str] resource_type: Resource type.
        """
        if availability_metrics_config is not None:
            pulumi.set(__self__, "availability_metrics_config", availability_metrics_config)
        if handler_config is not None:
            pulumi.set(__self__, "handler_config", handler_config)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="availabilityMetricsConfig")
    def availability_metrics_config(self) -> Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationAvailabilityMetricsConfigArgs']]:
        """
        Availability metrics details.
        """
        return pulumi.get(self, "availability_metrics_config")

    @availability_metrics_config.setter
    def availability_metrics_config(self, value: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationAvailabilityMetricsConfigArgs']]):
        pulumi.set(self, "availability_metrics_config", value)

    @_builtins.property
    @pulumi.getter(name="handlerConfig")
    def handler_config(self) -> Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigArgs']]:
        """
        Specific resource mapping configurations for Agent Extension Handlers.
        """
        return pulumi.get(self, "handler_config")

    @handler_config.setter
    def handler_config(self, value: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigArgs']]):
        pulumi.set(self, "handler_config", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationAvailabilityMetricsConfigArgsDict(TypedDict):
        collection_interval_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Availability metric collection internal in seconds.
        """
        metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of metrics used for availability calculation for the resource.
        """
elif False:
    MonitoredResourceTaskTaskDetailsResourceTypesConfigurationAvailabilityMetricsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationAvailabilityMetricsConfigArgs:
    def __init__(__self__, *,
                 collection_interval_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 metrics: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] collection_interval_in_seconds: Availability metric collection internal in seconds.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metrics: List of metrics used for availability calculation for the resource.
        """
        if collection_interval_in_seconds is not None:
            pulumi.set(__self__, "collection_interval_in_seconds", collection_interval_in_seconds)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter(name="collectionIntervalInSeconds")
    def collection_interval_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Availability metric collection internal in seconds.
        """
        return pulumi.get(self, "collection_interval_in_seconds")

    @collection_interval_in_seconds.setter
    def collection_interval_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "collection_interval_in_seconds", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of metrics used for availability calculation for the resource.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigArgsDict(TypedDict):
        collectd_resource_name_config: NotRequired[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigCollectdResourceNameConfigArgsDict']]
        """
        Resource name generation overriding configurations for collectd resource types.
        """
        collector_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of collector/plugin names.
        """
        handler_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigHandlerPropertyArgsDict']]]]
        """
        List of handler configuration properties
        """
        metric_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricMappingArgsDict']]]]
        """
        List of AgentExtensionHandlerMetricMappingDetails.
        """
        metric_name_config: NotRequired[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricNameConfigArgsDict']]
        """
        Metric name generation overriding configurations.
        """
        metric_upload_interval_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        """
        telegraf_resource_name_config: NotRequired[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigTelegrafResourceNameConfigArgsDict']]
        """
        Resource name generation overriding configurations for telegraf resource types.
        """
        telemetry_resource_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource group string; if not specified, the resource group string will be generated by the handler.
        """
elif False:
    MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigArgs:
    def __init__(__self__, *,
                 collectd_resource_name_config: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigCollectdResourceNameConfigArgs']] = None,
                 collector_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 handler_properties: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigHandlerPropertyArgs']]]] = None,
                 metric_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricMappingArgs']]]] = None,
                 metric_name_config: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricNameConfigArgs']] = None,
                 metric_upload_interval_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 telegraf_resource_name_config: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigTelegrafResourceNameConfigArgs']] = None,
                 telemetry_resource_group: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigCollectdResourceNameConfigArgs'] collectd_resource_name_config: Resource name generation overriding configurations for collectd resource types.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] collector_types: List of collector/plugin names.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigHandlerPropertyArgs']]] handler_properties: List of handler configuration properties
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricMappingArgs']]] metric_mappings: List of AgentExtensionHandlerMetricMappingDetails.
        :param pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricNameConfigArgs'] metric_name_config: Metric name generation overriding configurations.
        :param pulumi.Input[_builtins.int] metric_upload_interval_in_seconds: Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        :param pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigTelegrafResourceNameConfigArgs'] telegraf_resource_name_config: Resource name generation overriding configurations for telegraf resource types.
        :param pulumi.Input[_builtins.str] telemetry_resource_group: Resource group string; if not specified, the resource group string will be generated by the handler.
        """
        if collectd_resource_name_config is not None:
            pulumi.set(__self__, "collectd_resource_name_config", collectd_resource_name_config)
        if collector_types is not None:
            pulumi.set(__self__, "collector_types", collector_types)
        if handler_properties is not None:
            pulumi.set(__self__, "handler_properties", handler_properties)
        if metric_mappings is not None:
            pulumi.set(__self__, "metric_mappings", metric_mappings)
        if metric_name_config is not None:
            pulumi.set(__self__, "metric_name_config", metric_name_config)
        if metric_upload_interval_in_seconds is not None:
            pulumi.set(__self__, "metric_upload_interval_in_seconds", metric_upload_interval_in_seconds)
        if telegraf_resource_name_config is not None:
            pulumi.set(__self__, "telegraf_resource_name_config", telegraf_resource_name_config)
        if telemetry_resource_group is not None:
            pulumi.set(__self__, "telemetry_resource_group", telemetry_resource_group)

    @_builtins.property
    @pulumi.getter(name="collectdResourceNameConfig")
    def collectd_resource_name_config(self) -> Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigCollectdResourceNameConfigArgs']]:
        """
        Resource name generation overriding configurations for collectd resource types.
        """
        return pulumi.get(self, "collectd_resource_name_config")

    @collectd_resource_name_config.setter
    def collectd_resource_name_config(self, value: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigCollectdResourceNameConfigArgs']]):
        pulumi.set(self, "collectd_resource_name_config", value)

    @_builtins.property
    @pulumi.getter(name="collectorTypes")
    def collector_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of collector/plugin names.
        """
        return pulumi.get(self, "collector_types")

    @collector_types.setter
    def collector_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "collector_types", value)

    @_builtins.property
    @pulumi.getter(name="handlerProperties")
    def handler_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigHandlerPropertyArgs']]]]:
        """
        List of handler configuration properties
        """
        return pulumi.get(self, "handler_properties")

    @handler_properties.setter
    def handler_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigHandlerPropertyArgs']]]]):
        pulumi.set(self, "handler_properties", value)

    @_builtins.property
    @pulumi.getter(name="metricMappings")
    def metric_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricMappingArgs']]]]:
        """
        List of AgentExtensionHandlerMetricMappingDetails.
        """
        return pulumi.get(self, "metric_mappings")

    @metric_mappings.setter
    def metric_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricMappingArgs']]]]):
        pulumi.set(self, "metric_mappings", value)

    @_builtins.property
    @pulumi.getter(name="metricNameConfig")
    def metric_name_config(self) -> Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricNameConfigArgs']]:
        """
        Metric name generation overriding configurations.
        """
        return pulumi.get(self, "metric_name_config")

    @metric_name_config.setter
    def metric_name_config(self, value: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricNameConfigArgs']]):
        pulumi.set(self, "metric_name_config", value)

    @_builtins.property
    @pulumi.getter(name="metricUploadIntervalInSeconds")
    def metric_upload_interval_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        """
        return pulumi.get(self, "metric_upload_interval_in_seconds")

    @metric_upload_interval_in_seconds.setter
    def metric_upload_interval_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric_upload_interval_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="telegrafResourceNameConfig")
    def telegraf_resource_name_config(self) -> Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigTelegrafResourceNameConfigArgs']]:
        """
        Resource name generation overriding configurations for telegraf resource types.
        """
        return pulumi.get(self, "telegraf_resource_name_config")

    @telegraf_resource_name_config.setter
    def telegraf_resource_name_config(self, value: Optional[pulumi.Input['MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigTelegrafResourceNameConfigArgs']]):
        pulumi.set(self, "telegraf_resource_name_config", value)

    @_builtins.property
    @pulumi.getter(name="telemetryResourceGroup")
    def telemetry_resource_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource group string; if not specified, the resource group string will be generated by the handler.
        """
        return pulumi.get(self, "telemetry_resource_group")

    @telemetry_resource_group.setter
    def telemetry_resource_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "telemetry_resource_group", value)


if not MYPY:
    class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigCollectdResourceNameConfigArgsDict(TypedDict):
        exclude_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of property names to be excluded.
        """
        include_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of property names to be included.
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        String to be suffixed to the resource name.
        """
elif False:
    MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigCollectdResourceNameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigCollectdResourceNameConfigArgs:
    def __init__(__self__, *,
                 exclude_properties: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_properties: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_properties: List of property names to be excluded.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_properties: List of property names to be included.
        :param pulumi.Input[_builtins.str] suffix: String to be suffixed to the resource name.
        """
        if exclude_properties is not None:
            pulumi.set(__self__, "exclude_properties", exclude_properties)
        if include_properties is not None:
            pulumi.set(__self__, "include_properties", include_properties)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter(name="excludeProperties")
    def exclude_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of property names to be excluded.
        """
        return pulumi.get(self, "exclude_properties")

    @exclude_properties.setter
    def exclude_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_properties", value)

    @_builtins.property
    @pulumi.getter(name="includeProperties")
    def include_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of property names to be included.
        """
        return pulumi.get(self, "include_properties")

    @include_properties.setter
    def include_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_properties", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String to be suffixed to the resource name.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigHandlerPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property value.
        """
elif False:
    MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigHandlerPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigHandlerPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Property name.
        :param pulumi.Input[_builtins.str] value: Property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricMappingArgsDict(TypedDict):
        collector_metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric name as defined by the collector.
        """
        is_skip_upload: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is ignoring this metric.
        """
        metric_upload_interval_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        """
        telemetry_metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric name to be upload to telemetry.
        """
elif False:
    MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricMappingArgs:
    def __init__(__self__, *,
                 collector_metric_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_skip_upload: Optional[pulumi.Input[_builtins.bool]] = None,
                 metric_upload_interval_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 telemetry_metric_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] collector_metric_name: Metric name as defined by the collector.
        :param pulumi.Input[_builtins.bool] is_skip_upload: Is ignoring this metric.
        :param pulumi.Input[_builtins.int] metric_upload_interval_in_seconds: Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        :param pulumi.Input[_builtins.str] telemetry_metric_name: Metric name to be upload to telemetry.
        """
        if collector_metric_name is not None:
            pulumi.set(__self__, "collector_metric_name", collector_metric_name)
        if is_skip_upload is not None:
            pulumi.set(__self__, "is_skip_upload", is_skip_upload)
        if metric_upload_interval_in_seconds is not None:
            pulumi.set(__self__, "metric_upload_interval_in_seconds", metric_upload_interval_in_seconds)
        if telemetry_metric_name is not None:
            pulumi.set(__self__, "telemetry_metric_name", telemetry_metric_name)

    @_builtins.property
    @pulumi.getter(name="collectorMetricName")
    def collector_metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric name as defined by the collector.
        """
        return pulumi.get(self, "collector_metric_name")

    @collector_metric_name.setter
    def collector_metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collector_metric_name", value)

    @_builtins.property
    @pulumi.getter(name="isSkipUpload")
    def is_skip_upload(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is ignoring this metric.
        """
        return pulumi.get(self, "is_skip_upload")

    @is_skip_upload.setter
    def is_skip_upload(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_skip_upload", value)

    @_builtins.property
    @pulumi.getter(name="metricUploadIntervalInSeconds")
    def metric_upload_interval_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        """
        return pulumi.get(self, "metric_upload_interval_in_seconds")

    @metric_upload_interval_in_seconds.setter
    def metric_upload_interval_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric_upload_interval_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="telemetryMetricName")
    def telemetry_metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric name to be upload to telemetry.
        """
        return pulumi.get(self, "telemetry_metric_name")

    @telemetry_metric_name.setter
    def telemetry_metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "telemetry_metric_name", value)


if not MYPY:
    class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricNameConfigArgsDict(TypedDict):
        exclude_pattern_on_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        String pattern to be removed from the prefix of the metric name.
        """
        is_prefix_with_collector_type: NotRequired[pulumi.Input[_builtins.bool]]
        """
        is prefixing the metric with collector type.
        """
elif False:
    MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricNameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigMetricNameConfigArgs:
    def __init__(__self__, *,
                 exclude_pattern_on_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 is_prefix_with_collector_type: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] exclude_pattern_on_prefix: String pattern to be removed from the prefix of the metric name.
        :param pulumi.Input[_builtins.bool] is_prefix_with_collector_type: is prefixing the metric with collector type.
        """
        if exclude_pattern_on_prefix is not None:
            pulumi.set(__self__, "exclude_pattern_on_prefix", exclude_pattern_on_prefix)
        if is_prefix_with_collector_type is not None:
            pulumi.set(__self__, "is_prefix_with_collector_type", is_prefix_with_collector_type)

    @_builtins.property
    @pulumi.getter(name="excludePatternOnPrefix")
    def exclude_pattern_on_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String pattern to be removed from the prefix of the metric name.
        """
        return pulumi.get(self, "exclude_pattern_on_prefix")

    @exclude_pattern_on_prefix.setter
    def exclude_pattern_on_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_pattern_on_prefix", value)

    @_builtins.property
    @pulumi.getter(name="isPrefixWithCollectorType")
    def is_prefix_with_collector_type(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        is prefixing the metric with collector type.
        """
        return pulumi.get(self, "is_prefix_with_collector_type")

    @is_prefix_with_collector_type.setter
    def is_prefix_with_collector_type(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_prefix_with_collector_type", value)


if not MYPY:
    class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigTelegrafResourceNameConfigArgsDict(TypedDict):
        exclude_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of tag names to be excluded.
        """
        include_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of tag names to be included.
        """
        is_use_tags_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag to indicate if only tags will be used for resource name generation.
        """
elif False:
    MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigTelegrafResourceNameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTaskTaskDetailsResourceTypesConfigurationHandlerConfigTelegrafResourceNameConfigArgs:
    def __init__(__self__, *,
                 exclude_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 is_use_tags_only: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_tags: List of tag names to be excluded.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_tags: List of tag names to be included.
        :param pulumi.Input[_builtins.bool] is_use_tags_only: Flag to indicate if only tags will be used for resource name generation.
        """
        if exclude_tags is not None:
            pulumi.set(__self__, "exclude_tags", exclude_tags)
        if include_tags is not None:
            pulumi.set(__self__, "include_tags", include_tags)
        if is_use_tags_only is not None:
            pulumi.set(__self__, "is_use_tags_only", is_use_tags_only)

    @_builtins.property
    @pulumi.getter(name="excludeTags")
    def exclude_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of tag names to be excluded.
        """
        return pulumi.get(self, "exclude_tags")

    @exclude_tags.setter
    def exclude_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_tags", value)

    @_builtins.property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of tag names to be included.
        """
        return pulumi.get(self, "include_tags")

    @include_tags.setter
    def include_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_tags", value)

    @_builtins.property
    @pulumi.getter(name="isUseTagsOnly")
    def is_use_tags_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag to indicate if only tags will be used for resource name generation.
        """
        return pulumi.get(self, "is_use_tags_only")

    @is_use_tags_only.setter
    def is_use_tags_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_use_tags_only", value)


if not MYPY:
    class MonitoredResourceTypeAvailabilityMetricsConfigArgsDict(TypedDict):
        collection_interval_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Availability metric collection internal in seconds.
        """
        metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of metrics used for availability calculation for the resource.
        """
elif False:
    MonitoredResourceTypeAvailabilityMetricsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTypeAvailabilityMetricsConfigArgs:
    def __init__(__self__, *,
                 collection_interval_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 metrics: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] collection_interval_in_seconds: Availability metric collection internal in seconds.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metrics: List of metrics used for availability calculation for the resource.
        """
        if collection_interval_in_seconds is not None:
            pulumi.set(__self__, "collection_interval_in_seconds", collection_interval_in_seconds)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter(name="collectionIntervalInSeconds")
    def collection_interval_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Availability metric collection internal in seconds.
        """
        return pulumi.get(self, "collection_interval_in_seconds")

    @collection_interval_in_seconds.setter
    def collection_interval_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "collection_interval_in_seconds", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of metrics used for availability calculation for the resource.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class MonitoredResourceTypeHandlerConfigArgsDict(TypedDict):
        collectd_resource_name_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigCollectdResourceNameConfigArgsDict']]]]
        """
        Resource name generation overriding configurations for collectd resource types.
        """
        collector_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of collector/plugin names.
        """
        handler_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigHandlerPropertyArgsDict']]]]
        """
        List of handler configuration properties
        """
        metric_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigMetricMappingArgsDict']]]]
        """
        List of AgentExtensionHandlerMetricMappingDetails.
        """
        metric_name_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigMetricNameConfigArgsDict']]]]
        """
        Metric name generation overriding configurations.
        """
        metric_upload_interval_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        """
        telegraf_resource_name_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigTelegrafResourceNameConfigArgsDict']]]]
        """
        Resource name generation overriding configurations for telegraf resource types.
        """
        telemetry_resource_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource group string; if not specified, the resource group string will be generated by the handler.
        """
elif False:
    MonitoredResourceTypeHandlerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTypeHandlerConfigArgs:
    def __init__(__self__, *,
                 collectd_resource_name_configs: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigCollectdResourceNameConfigArgs']]]] = None,
                 collector_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 handler_properties: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigHandlerPropertyArgs']]]] = None,
                 metric_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigMetricMappingArgs']]]] = None,
                 metric_name_configs: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigMetricNameConfigArgs']]]] = None,
                 metric_upload_interval_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 telegraf_resource_name_configs: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigTelegrafResourceNameConfigArgs']]]] = None,
                 telemetry_resource_group: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigCollectdResourceNameConfigArgs']]] collectd_resource_name_configs: Resource name generation overriding configurations for collectd resource types.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] collector_types: List of collector/plugin names.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigHandlerPropertyArgs']]] handler_properties: List of handler configuration properties
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigMetricMappingArgs']]] metric_mappings: List of AgentExtensionHandlerMetricMappingDetails.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigMetricNameConfigArgs']]] metric_name_configs: Metric name generation overriding configurations.
        :param pulumi.Input[_builtins.int] metric_upload_interval_in_seconds: Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigTelegrafResourceNameConfigArgs']]] telegraf_resource_name_configs: Resource name generation overriding configurations for telegraf resource types.
        :param pulumi.Input[_builtins.str] telemetry_resource_group: Resource group string; if not specified, the resource group string will be generated by the handler.
        """
        if collectd_resource_name_configs is not None:
            pulumi.set(__self__, "collectd_resource_name_configs", collectd_resource_name_configs)
        if collector_types is not None:
            pulumi.set(__self__, "collector_types", collector_types)
        if handler_properties is not None:
            pulumi.set(__self__, "handler_properties", handler_properties)
        if metric_mappings is not None:
            pulumi.set(__self__, "metric_mappings", metric_mappings)
        if metric_name_configs is not None:
            pulumi.set(__self__, "metric_name_configs", metric_name_configs)
        if metric_upload_interval_in_seconds is not None:
            pulumi.set(__self__, "metric_upload_interval_in_seconds", metric_upload_interval_in_seconds)
        if telegraf_resource_name_configs is not None:
            pulumi.set(__self__, "telegraf_resource_name_configs", telegraf_resource_name_configs)
        if telemetry_resource_group is not None:
            pulumi.set(__self__, "telemetry_resource_group", telemetry_resource_group)

    @_builtins.property
    @pulumi.getter(name="collectdResourceNameConfigs")
    def collectd_resource_name_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigCollectdResourceNameConfigArgs']]]]:
        """
        Resource name generation overriding configurations for collectd resource types.
        """
        return pulumi.get(self, "collectd_resource_name_configs")

    @collectd_resource_name_configs.setter
    def collectd_resource_name_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigCollectdResourceNameConfigArgs']]]]):
        pulumi.set(self, "collectd_resource_name_configs", value)

    @_builtins.property
    @pulumi.getter(name="collectorTypes")
    def collector_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of collector/plugin names.
        """
        return pulumi.get(self, "collector_types")

    @collector_types.setter
    def collector_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "collector_types", value)

    @_builtins.property
    @pulumi.getter(name="handlerProperties")
    def handler_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigHandlerPropertyArgs']]]]:
        """
        List of handler configuration properties
        """
        return pulumi.get(self, "handler_properties")

    @handler_properties.setter
    def handler_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigHandlerPropertyArgs']]]]):
        pulumi.set(self, "handler_properties", value)

    @_builtins.property
    @pulumi.getter(name="metricMappings")
    def metric_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigMetricMappingArgs']]]]:
        """
        List of AgentExtensionHandlerMetricMappingDetails.
        """
        return pulumi.get(self, "metric_mappings")

    @metric_mappings.setter
    def metric_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigMetricMappingArgs']]]]):
        pulumi.set(self, "metric_mappings", value)

    @_builtins.property
    @pulumi.getter(name="metricNameConfigs")
    def metric_name_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigMetricNameConfigArgs']]]]:
        """
        Metric name generation overriding configurations.
        """
        return pulumi.get(self, "metric_name_configs")

    @metric_name_configs.setter
    def metric_name_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigMetricNameConfigArgs']]]]):
        pulumi.set(self, "metric_name_configs", value)

    @_builtins.property
    @pulumi.getter(name="metricUploadIntervalInSeconds")
    def metric_upload_interval_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        """
        return pulumi.get(self, "metric_upload_interval_in_seconds")

    @metric_upload_interval_in_seconds.setter
    def metric_upload_interval_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric_upload_interval_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="telegrafResourceNameConfigs")
    def telegraf_resource_name_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigTelegrafResourceNameConfigArgs']]]]:
        """
        Resource name generation overriding configurations for telegraf resource types.
        """
        return pulumi.get(self, "telegraf_resource_name_configs")

    @telegraf_resource_name_configs.setter
    def telegraf_resource_name_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeHandlerConfigTelegrafResourceNameConfigArgs']]]]):
        pulumi.set(self, "telegraf_resource_name_configs", value)

    @_builtins.property
    @pulumi.getter(name="telemetryResourceGroup")
    def telemetry_resource_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource group string; if not specified, the resource group string will be generated by the handler.
        """
        return pulumi.get(self, "telemetry_resource_group")

    @telemetry_resource_group.setter
    def telemetry_resource_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "telemetry_resource_group", value)


if not MYPY:
    class MonitoredResourceTypeHandlerConfigCollectdResourceNameConfigArgsDict(TypedDict):
        exclude_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of property names to be excluded.
        """
        include_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of property names to be included.
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        String to be suffixed to the resource name.
        """
elif False:
    MonitoredResourceTypeHandlerConfigCollectdResourceNameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTypeHandlerConfigCollectdResourceNameConfigArgs:
    def __init__(__self__, *,
                 exclude_properties: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_properties: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_properties: List of property names to be excluded.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_properties: List of property names to be included.
        :param pulumi.Input[_builtins.str] suffix: String to be suffixed to the resource name.
        """
        if exclude_properties is not None:
            pulumi.set(__self__, "exclude_properties", exclude_properties)
        if include_properties is not None:
            pulumi.set(__self__, "include_properties", include_properties)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter(name="excludeProperties")
    def exclude_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of property names to be excluded.
        """
        return pulumi.get(self, "exclude_properties")

    @exclude_properties.setter
    def exclude_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_properties", value)

    @_builtins.property
    @pulumi.getter(name="includeProperties")
    def include_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of property names to be included.
        """
        return pulumi.get(self, "include_properties")

    @include_properties.setter
    def include_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_properties", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String to be suffixed to the resource name.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class MonitoredResourceTypeHandlerConfigHandlerPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A unique monitored resource type name. The name must be unique across tenancy.  Name can not be changed.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property value.
        """
elif False:
    MonitoredResourceTypeHandlerConfigHandlerPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTypeHandlerConfigHandlerPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A unique monitored resource type name. The name must be unique across tenancy.  Name can not be changed.
        :param pulumi.Input[_builtins.str] value: Property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A unique monitored resource type name. The name must be unique across tenancy.  Name can not be changed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MonitoredResourceTypeHandlerConfigMetricMappingArgsDict(TypedDict):
        collector_metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric name as defined by the collector.
        """
        is_skip_upload: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is ignoring this metric.
        """
        metric_upload_interval_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        """
        telemetry_metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric name to be upload to telemetry.
        """
elif False:
    MonitoredResourceTypeHandlerConfigMetricMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTypeHandlerConfigMetricMappingArgs:
    def __init__(__self__, *,
                 collector_metric_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_skip_upload: Optional[pulumi.Input[_builtins.bool]] = None,
                 metric_upload_interval_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 telemetry_metric_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] collector_metric_name: Metric name as defined by the collector.
        :param pulumi.Input[_builtins.bool] is_skip_upload: Is ignoring this metric.
        :param pulumi.Input[_builtins.int] metric_upload_interval_in_seconds: Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        :param pulumi.Input[_builtins.str] telemetry_metric_name: Metric name to be upload to telemetry.
        """
        if collector_metric_name is not None:
            pulumi.set(__self__, "collector_metric_name", collector_metric_name)
        if is_skip_upload is not None:
            pulumi.set(__self__, "is_skip_upload", is_skip_upload)
        if metric_upload_interval_in_seconds is not None:
            pulumi.set(__self__, "metric_upload_interval_in_seconds", metric_upload_interval_in_seconds)
        if telemetry_metric_name is not None:
            pulumi.set(__self__, "telemetry_metric_name", telemetry_metric_name)

    @_builtins.property
    @pulumi.getter(name="collectorMetricName")
    def collector_metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric name as defined by the collector.
        """
        return pulumi.get(self, "collector_metric_name")

    @collector_metric_name.setter
    def collector_metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collector_metric_name", value)

    @_builtins.property
    @pulumi.getter(name="isSkipUpload")
    def is_skip_upload(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is ignoring this metric.
        """
        return pulumi.get(self, "is_skip_upload")

    @is_skip_upload.setter
    def is_skip_upload(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_skip_upload", value)

    @_builtins.property
    @pulumi.getter(name="metricUploadIntervalInSeconds")
    def metric_upload_interval_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric upload interval in seconds. Any metric sent by telegraf/collectd before the  configured interval expires will be dropped.
        """
        return pulumi.get(self, "metric_upload_interval_in_seconds")

    @metric_upload_interval_in_seconds.setter
    def metric_upload_interval_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric_upload_interval_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="telemetryMetricName")
    def telemetry_metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric name to be upload to telemetry.
        """
        return pulumi.get(self, "telemetry_metric_name")

    @telemetry_metric_name.setter
    def telemetry_metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "telemetry_metric_name", value)


if not MYPY:
    class MonitoredResourceTypeHandlerConfigMetricNameConfigArgsDict(TypedDict):
        exclude_pattern_on_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        String pattern to be removed from the prefix of the metric name.
        """
        is_prefix_with_collector_type: NotRequired[pulumi.Input[_builtins.bool]]
        """
        is prefixing the metric with collector type.
        """
elif False:
    MonitoredResourceTypeHandlerConfigMetricNameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTypeHandlerConfigMetricNameConfigArgs:
    def __init__(__self__, *,
                 exclude_pattern_on_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 is_prefix_with_collector_type: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] exclude_pattern_on_prefix: String pattern to be removed from the prefix of the metric name.
        :param pulumi.Input[_builtins.bool] is_prefix_with_collector_type: is prefixing the metric with collector type.
        """
        if exclude_pattern_on_prefix is not None:
            pulumi.set(__self__, "exclude_pattern_on_prefix", exclude_pattern_on_prefix)
        if is_prefix_with_collector_type is not None:
            pulumi.set(__self__, "is_prefix_with_collector_type", is_prefix_with_collector_type)

    @_builtins.property
    @pulumi.getter(name="excludePatternOnPrefix")
    def exclude_pattern_on_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String pattern to be removed from the prefix of the metric name.
        """
        return pulumi.get(self, "exclude_pattern_on_prefix")

    @exclude_pattern_on_prefix.setter
    def exclude_pattern_on_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_pattern_on_prefix", value)

    @_builtins.property
    @pulumi.getter(name="isPrefixWithCollectorType")
    def is_prefix_with_collector_type(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        is prefixing the metric with collector type.
        """
        return pulumi.get(self, "is_prefix_with_collector_type")

    @is_prefix_with_collector_type.setter
    def is_prefix_with_collector_type(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_prefix_with_collector_type", value)


if not MYPY:
    class MonitoredResourceTypeHandlerConfigTelegrafResourceNameConfigArgsDict(TypedDict):
        exclude_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of tag names to be excluded.
        """
        include_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of tag names to be included.
        """
        is_use_tags_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag to indicate if only tags will be used for resource name generation.
        """
elif False:
    MonitoredResourceTypeHandlerConfigTelegrafResourceNameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTypeHandlerConfigTelegrafResourceNameConfigArgs:
    def __init__(__self__, *,
                 exclude_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 is_use_tags_only: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_tags: List of tag names to be excluded.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_tags: List of tag names to be included.
        :param pulumi.Input[_builtins.bool] is_use_tags_only: Flag to indicate if only tags will be used for resource name generation.
        """
        if exclude_tags is not None:
            pulumi.set(__self__, "exclude_tags", exclude_tags)
        if include_tags is not None:
            pulumi.set(__self__, "include_tags", include_tags)
        if is_use_tags_only is not None:
            pulumi.set(__self__, "is_use_tags_only", is_use_tags_only)

    @_builtins.property
    @pulumi.getter(name="excludeTags")
    def exclude_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of tag names to be excluded.
        """
        return pulumi.get(self, "exclude_tags")

    @exclude_tags.setter
    def exclude_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_tags", value)

    @_builtins.property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of tag names to be included.
        """
        return pulumi.get(self, "include_tags")

    @include_tags.setter
    def include_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_tags", value)

    @_builtins.property
    @pulumi.getter(name="isUseTagsOnly")
    def is_use_tags_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag to indicate if only tags will be used for resource name generation.
        """
        return pulumi.get(self, "is_use_tags_only")

    @is_use_tags_only.setter
    def is_use_tags_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_use_tags_only", value)


if not MYPY:
    class MonitoredResourceTypeMetadataArgsDict(TypedDict):
        format: pulumi.Input[_builtins.str]
        """
        (Updatable) ResourceType metadata format to be used. Currently supports only one format. Possible values - SYSTEM_FORMAT.
        * SYSTEM_FORMAT - The resource type metadata is defined in machine friendly format.
        """
        agent_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of properties needed by the agent for monitoring the resource.  Valid only if resource type is Oracle Cloud Infrastructure management agent based. When specified,  these properties are passed to the management agent during resource create or update.
        """
        required_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of required properties for resource type.
        """
        unique_property_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeMetadataUniquePropertySetArgsDict']]]]
        """
        (Updatable) List of property sets used to uniquely identify the resources.  This check is made during create or update of stack monitoring resource.  The resource has to pass unique check for each set in the list.  For example, database can have user, password and SID as one unique set.  Another unique set would be user, password and service name.
        """
        valid_properties_for_creates: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of valid properties for resource type while creating the monitored resource.  If resources of this type specifies any other properties during create operation,  the operation will fail.
        """
        valid_properties_for_updates: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of valid properties for resource type while updating the monitored resource.  If resources of this type specifies any other properties during update operation,  the operation will fail.
        """
        valid_property_values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of valid values for the properties. This is useful when resource type wants to restrict only certain values for some properties. For instance for 'osType' property,  supported values can be restricted to be either Linux or Windows. Example: `{ "osType": "Linux,Windows,Solaris"}`
        """
        valid_sub_resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of valid sub-resource types for a composite resource type. The sub-resource types will be obtained from the valid association pairs corresponding to the composite resource types. It will be empty for non composite resource types
        """
elif False:
    MonitoredResourceTypeMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTypeMetadataArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[_builtins.str],
                 agent_properties: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 required_properties: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unique_property_sets: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeMetadataUniquePropertySetArgs']]]] = None,
                 valid_properties_for_creates: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 valid_properties_for_updates: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 valid_property_values: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 valid_sub_resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] format: (Updatable) ResourceType metadata format to be used. Currently supports only one format. Possible values - SYSTEM_FORMAT.
               * SYSTEM_FORMAT - The resource type metadata is defined in machine friendly format.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] agent_properties: (Updatable) List of properties needed by the agent for monitoring the resource.  Valid only if resource type is Oracle Cloud Infrastructure management agent based. When specified,  these properties are passed to the management agent during resource create or update.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] required_properties: (Updatable) List of required properties for resource type.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeMetadataUniquePropertySetArgs']]] unique_property_sets: (Updatable) List of property sets used to uniquely identify the resources.  This check is made during create or update of stack monitoring resource.  The resource has to pass unique check for each set in the list.  For example, database can have user, password and SID as one unique set.  Another unique set would be user, password and service name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] valid_properties_for_creates: (Updatable) List of valid properties for resource type while creating the monitored resource.  If resources of this type specifies any other properties during create operation,  the operation will fail.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] valid_properties_for_updates: (Updatable) List of valid properties for resource type while updating the monitored resource.  If resources of this type specifies any other properties during update operation,  the operation will fail.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] valid_property_values: (Updatable) List of valid values for the properties. This is useful when resource type wants to restrict only certain values for some properties. For instance for 'osType' property,  supported values can be restricted to be either Linux or Windows. Example: `{ "osType": "Linux,Windows,Solaris"}`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] valid_sub_resource_types: (Updatable) List of valid sub-resource types for a composite resource type. The sub-resource types will be obtained from the valid association pairs corresponding to the composite resource types. It will be empty for non composite resource types
        """
        pulumi.set(__self__, "format", format)
        if agent_properties is not None:
            pulumi.set(__self__, "agent_properties", agent_properties)
        if required_properties is not None:
            pulumi.set(__self__, "required_properties", required_properties)
        if unique_property_sets is not None:
            pulumi.set(__self__, "unique_property_sets", unique_property_sets)
        if valid_properties_for_creates is not None:
            pulumi.set(__self__, "valid_properties_for_creates", valid_properties_for_creates)
        if valid_properties_for_updates is not None:
            pulumi.set(__self__, "valid_properties_for_updates", valid_properties_for_updates)
        if valid_property_values is not None:
            pulumi.set(__self__, "valid_property_values", valid_property_values)
        if valid_sub_resource_types is not None:
            pulumi.set(__self__, "valid_sub_resource_types", valid_sub_resource_types)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) ResourceType metadata format to be used. Currently supports only one format. Possible values - SYSTEM_FORMAT.
        * SYSTEM_FORMAT - The resource type metadata is defined in machine friendly format.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="agentProperties")
    def agent_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of properties needed by the agent for monitoring the resource.  Valid only if resource type is Oracle Cloud Infrastructure management agent based. When specified,  these properties are passed to the management agent during resource create or update.
        """
        return pulumi.get(self, "agent_properties")

    @agent_properties.setter
    def agent_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "agent_properties", value)

    @_builtins.property
    @pulumi.getter(name="requiredProperties")
    def required_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of required properties for resource type.
        """
        return pulumi.get(self, "required_properties")

    @required_properties.setter
    def required_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "required_properties", value)

    @_builtins.property
    @pulumi.getter(name="uniquePropertySets")
    def unique_property_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeMetadataUniquePropertySetArgs']]]]:
        """
        (Updatable) List of property sets used to uniquely identify the resources.  This check is made during create or update of stack monitoring resource.  The resource has to pass unique check for each set in the list.  For example, database can have user, password and SID as one unique set.  Another unique set would be user, password and service name.
        """
        return pulumi.get(self, "unique_property_sets")

    @unique_property_sets.setter
    def unique_property_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceTypeMetadataUniquePropertySetArgs']]]]):
        pulumi.set(self, "unique_property_sets", value)

    @_builtins.property
    @pulumi.getter(name="validPropertiesForCreates")
    def valid_properties_for_creates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of valid properties for resource type while creating the monitored resource.  If resources of this type specifies any other properties during create operation,  the operation will fail.
        """
        return pulumi.get(self, "valid_properties_for_creates")

    @valid_properties_for_creates.setter
    def valid_properties_for_creates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "valid_properties_for_creates", value)

    @_builtins.property
    @pulumi.getter(name="validPropertiesForUpdates")
    def valid_properties_for_updates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of valid properties for resource type while updating the monitored resource.  If resources of this type specifies any other properties during update operation,  the operation will fail.
        """
        return pulumi.get(self, "valid_properties_for_updates")

    @valid_properties_for_updates.setter
    def valid_properties_for_updates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "valid_properties_for_updates", value)

    @_builtins.property
    @pulumi.getter(name="validPropertyValues")
    def valid_property_values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of valid values for the properties. This is useful when resource type wants to restrict only certain values for some properties. For instance for 'osType' property,  supported values can be restricted to be either Linux or Windows. Example: `{ "osType": "Linux,Windows,Solaris"}`
        """
        return pulumi.get(self, "valid_property_values")

    @valid_property_values.setter
    def valid_property_values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "valid_property_values", value)

    @_builtins.property
    @pulumi.getter(name="validSubResourceTypes")
    def valid_sub_resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of valid sub-resource types for a composite resource type. The sub-resource types will be obtained from the valid association pairs corresponding to the composite resource types. It will be empty for non composite resource types
        """
        return pulumi.get(self, "valid_sub_resource_types")

    @valid_sub_resource_types.setter
    def valid_sub_resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "valid_sub_resource_types", value)


if not MYPY:
    class MonitoredResourceTypeMetadataUniquePropertySetArgsDict(TypedDict):
        properties: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) List of properties.
        """
elif False:
    MonitoredResourceTypeMetadataUniquePropertySetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourceTypeMetadataUniquePropertySetArgs:
    def __init__(__self__, *,
                 properties: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] properties: (Updatable) List of properties.
        """
        pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) List of properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class MonitoredResourcesAssociateMonitoredResourceDestinationResourceDetailArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored Resource Name.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored Resource Type.
        """
elif False:
    MonitoredResourcesAssociateMonitoredResourceDestinationResourceDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourcesAssociateMonitoredResourceDestinationResourceDetailArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[_builtins.str] name: Monitored Resource Name.
        :param pulumi.Input[_builtins.str] type: Monitored Resource Type.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored Resource Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MonitoredResourcesAssociateMonitoredResourceSourceResourceDetailArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored Resource Name.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored Resource Type.
        """
elif False:
    MonitoredResourcesAssociateMonitoredResourceSourceResourceDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourcesAssociateMonitoredResourceSourceResourceDetailArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[_builtins.str] name: Monitored Resource Name.
        :param pulumi.Input[_builtins.str] type: Monitored Resource Type.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored Resource Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MonitoredResourcesListMemberItemArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External resource is any Oracle Cloud Infrastructure resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) which is not a Stack Monitoring service resource. Currently supports only following resource types - Container database, non-container database,  pluggable database and Oracle Cloud Infrastructure compute instance.
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored Resource Host Name.
        """
        license: NotRequired[pulumi.Input[_builtins.str]]
        """
        License edition of the monitored resource.
        """
        parent_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parent monitored resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        resource_category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource Category to indicate the kind of resource type.
        """
        resource_display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored resource display name.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored Resource Name.
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored Resource Type.
        """
        source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source type to indicate if the resource is stack monitoring discovered, Oracle Cloud Infrastructure native resource, etc.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current state of the Resource.
        """
        system_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
elif False:
    MonitoredResourcesListMemberItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourcesListMemberItemArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 license: Optional[pulumi.Input[_builtins.str]] = None,
                 parent_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_category: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 source_type: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 system_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param pulumi.Input[_builtins.str] external_id: External resource is any Oracle Cloud Infrastructure resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) which is not a Stack Monitoring service resource. Currently supports only following resource types - Container database, non-container database,  pluggable database and Oracle Cloud Infrastructure compute instance.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param pulumi.Input[_builtins.str] host_name: Monitored Resource Host Name.
        :param pulumi.Input[_builtins.str] license: License edition of the monitored resource.
        :param pulumi.Input[_builtins.str] parent_id: Parent monitored resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[_builtins.str] resource_category: Resource Category to indicate the kind of resource type.
        :param pulumi.Input[_builtins.str] resource_display_name: Monitored resource display name.
        :param pulumi.Input[_builtins.str] resource_id: Monitored resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[_builtins.str] resource_name: Monitored Resource Name.
        :param pulumi.Input[_builtins.str] resource_type: Monitored Resource Type.
        :param pulumi.Input[_builtins.str] source_type: Source type to indicate if the resource is stack monitoring discovered, Oracle Cloud Infrastructure native resource, etc.
        :param pulumi.Input[_builtins.str] state: The current state of the Resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if license is not None:
            pulumi.set(__self__, "license", license)
        if parent_id is not None:
            pulumi.set(__self__, "parent_id", parent_id)
        if resource_category is not None:
            pulumi.set(__self__, "resource_category", resource_category)
        if resource_display_name is not None:
            pulumi.set(__self__, "resource_display_name", resource_display_name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if system_tags is not None:
            pulumi.set(__self__, "system_tags", system_tags)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "defined_tags", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External resource is any Oracle Cloud Infrastructure resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) which is not a Stack Monitoring service resource. Currently supports only following resource types - Container database, non-container database,  pluggable database and Oracle Cloud Infrastructure compute instance.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored Resource Host Name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def license(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License edition of the monitored resource.
        """
        return pulumi.get(self, "license")

    @license.setter
    def license(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license", value)

    @_builtins.property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parent monitored resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "parent_id")

    @parent_id.setter
    def parent_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parent_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceCategory")
    def resource_category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource Category to indicate the kind of resource type.
        """
        return pulumi.get(self, "resource_category")

    @resource_category.setter
    def resource_category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_category", value)

    @_builtins.property
    @pulumi.getter(name="resourceDisplayName")
    def resource_display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored resource display name.
        """
        return pulumi.get(self, "resource_display_name")

    @resource_display_name.setter
    def resource_display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_display_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored Resource Name.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored Resource Type.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source type to indicate if the resource is stack monitoring discovered, Oracle Cloud Infrastructure native resource, etc.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_type", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current state of the Resource.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @system_tags.setter
    def system_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "system_tags", value)


if not MYPY:
    class MonitoredResourcesSearchAssociationItemArgsDict(TypedDict):
        association_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Association type filter to search associated resources.
        """
        destination_resource_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchAssociationItemDestinationResourceDetailArgsDict']]]]
        """
        Association Resource Details.
        """
        destination_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination Monitored Resource Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        source_resource_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchAssociationItemSourceResourceDetailArgsDict']]]]
        """
        Association Resource Details.
        """
        source_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source Monitored Resource Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The association creation time. An RFC3339 formatted datetime string.
        """
elif False:
    MonitoredResourcesSearchAssociationItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourcesSearchAssociationItemArgs:
    def __init__(__self__, *,
                 association_type: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_resource_details: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchAssociationItemDestinationResourceDetailArgs']]]] = None,
                 destination_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_resource_details: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchAssociationItemSourceResourceDetailArgs']]]] = None,
                 source_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] association_type: Association type filter to search associated resources.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchAssociationItemDestinationResourceDetailArgs']]] destination_resource_details: Association Resource Details.
        :param pulumi.Input[_builtins.str] destination_resource_id: Destination Monitored Resource Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchAssociationItemSourceResourceDetailArgs']]] source_resource_details: Association Resource Details.
        :param pulumi.Input[_builtins.str] source_resource_id: Source Monitored Resource Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[_builtins.str] time_created: The association creation time. An RFC3339 formatted datetime string.
        """
        if association_type is not None:
            pulumi.set(__self__, "association_type", association_type)
        if destination_resource_details is not None:
            pulumi.set(__self__, "destination_resource_details", destination_resource_details)
        if destination_resource_id is not None:
            pulumi.set(__self__, "destination_resource_id", destination_resource_id)
        if source_resource_details is not None:
            pulumi.set(__self__, "source_resource_details", source_resource_details)
        if source_resource_id is not None:
            pulumi.set(__self__, "source_resource_id", source_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter(name="associationType")
    def association_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Association type filter to search associated resources.
        """
        return pulumi.get(self, "association_type")

    @association_type.setter
    def association_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "association_type", value)

    @_builtins.property
    @pulumi.getter(name="destinationResourceDetails")
    def destination_resource_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchAssociationItemDestinationResourceDetailArgs']]]]:
        """
        Association Resource Details.
        """
        return pulumi.get(self, "destination_resource_details")

    @destination_resource_details.setter
    def destination_resource_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchAssociationItemDestinationResourceDetailArgs']]]]):
        pulumi.set(self, "destination_resource_details", value)

    @_builtins.property
    @pulumi.getter(name="destinationResourceId")
    def destination_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination Monitored Resource Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "destination_resource_id")

    @destination_resource_id.setter
    def destination_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceResourceDetails")
    def source_resource_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchAssociationItemSourceResourceDetailArgs']]]]:
        """
        Association Resource Details.
        """
        return pulumi.get(self, "source_resource_details")

    @source_resource_details.setter
    def source_resource_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchAssociationItemSourceResourceDetailArgs']]]]):
        pulumi.set(self, "source_resource_details", value)

    @_builtins.property
    @pulumi.getter(name="sourceResourceId")
    def source_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source Monitored Resource Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "source_resource_id")

    @source_resource_id.setter
    def source_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The association creation time. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class MonitoredResourcesSearchAssociationItemDestinationResourceDetailArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored Resource Name.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored Resource Type.
        """
elif False:
    MonitoredResourcesSearchAssociationItemDestinationResourceDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourcesSearchAssociationItemDestinationResourceDetailArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[_builtins.str] name: Monitored Resource Name.
        :param pulumi.Input[_builtins.str] type: Monitored Resource Type.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored Resource Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MonitoredResourcesSearchAssociationItemSourceResourceDetailArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored Resource Name.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored Resource Type.
        """
elif False:
    MonitoredResourcesSearchAssociationItemSourceResourceDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourcesSearchAssociationItemSourceResourceDetailArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[_builtins.str] name: Monitored Resource Name.
        :param pulumi.Input[_builtins.str] type: Monitored Resource Type.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored Resource Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MonitoredResourcesSearchItemArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored resource display name.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External resource is any Oracle Cloud Infrastructure resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) which is not a Stack Monitoring service resource. Currently supports only following resource types - Container database, non-container database,  pluggable database and Oracle Cloud Infrastructure compute instance.
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter to return resources with host name match.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        license: NotRequired[pulumi.Input[_builtins.str]]
        """
        License edition of the monitored resource.
        """
        management_agent_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter to return resources with matching management agent id.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter to return resources that match exact resource name.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchItemPropertyArgsDict']]]]
        """
        List of monitored resource properties.
        """
        resource_category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource category filter.
        """
        source_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source type filter.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter to return resources with matching lifecycle state.
        """
        system_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored resource creation time. An RFC3339 formatted datetime string.
        """
        time_updated: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitored resource update time. An RFC3339 formatted datetime string.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter to return resources that match resource type. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    MonitoredResourcesSearchItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourcesSearchItemArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 license: Optional[pulumi.Input[_builtins.str]] = None,
                 management_agent_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchItemPropertyArgs']]]] = None,
                 resource_category: Optional[pulumi.Input[_builtins.str]] = None,
                 source_type: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 system_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 time_updated: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param pulumi.Input[_builtins.str] display_name: Monitored resource display name.
        :param pulumi.Input[_builtins.str] external_id: External resource is any Oracle Cloud Infrastructure resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) which is not a Stack Monitoring service resource. Currently supports only following resource types - Container database, non-container database,  pluggable database and Oracle Cloud Infrastructure compute instance.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param pulumi.Input[_builtins.str] host_name: A filter to return resources with host name match.
        :param pulumi.Input[_builtins.str] id: Monitored resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[_builtins.str] license: License edition of the monitored resource.
        :param pulumi.Input[_builtins.str] management_agent_id: A filter to return resources with matching management agent id.
        :param pulumi.Input[_builtins.str] name: A filter to return resources that match exact resource name.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchItemPropertyArgs']]] properties: List of monitored resource properties.
        :param pulumi.Input[_builtins.str] resource_category: Resource category filter.
        :param pulumi.Input[_builtins.str] source_type: Source type filter.
        :param pulumi.Input[_builtins.str] state: A filter to return resources with matching lifecycle state.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param pulumi.Input[_builtins.str] time_created: Monitored resource creation time. An RFC3339 formatted datetime string.
        :param pulumi.Input[_builtins.str] time_updated: Monitored resource update time. An RFC3339 formatted datetime string.
        :param pulumi.Input[_builtins.str] type: A filter to return resources that match resource type. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if license is not None:
            pulumi.set(__self__, "license", license)
        if management_agent_id is not None:
            pulumi.set(__self__, "management_agent_id", management_agent_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_category is not None:
            pulumi.set(__self__, "resource_category", resource_category)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if system_tags is not None:
            pulumi.set(__self__, "system_tags", system_tags)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Compartment Identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "defined_tags", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored resource display name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External resource is any Oracle Cloud Infrastructure resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) which is not a Stack Monitoring service resource. Currently supports only following resource types - Container database, non-container database,  pluggable database and Oracle Cloud Infrastructure compute instance.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter to return resources with host name match.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored resource identifier [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def license(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        License edition of the monitored resource.
        """
        return pulumi.get(self, "license")

    @license.setter
    def license(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license", value)

    @_builtins.property
    @pulumi.getter(name="managementAgentId")
    def management_agent_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter to return resources with matching management agent id.
        """
        return pulumi.get(self, "management_agent_id")

    @management_agent_id.setter
    def management_agent_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "management_agent_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter to return resources that match exact resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchItemPropertyArgs']]]]:
        """
        List of monitored resource properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourcesSearchItemPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="resourceCategory")
    def resource_category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource category filter.
        """
        return pulumi.get(self, "resource_category")

    @resource_category.setter
    def resource_category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_category", value)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source type filter.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_type", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter to return resources with matching lifecycle state.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @system_tags.setter
    def system_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "system_tags", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored resource creation time. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitored resource update time. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_updated", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter to return resources that match resource type. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MonitoredResourcesSearchItemPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter to return resources that match exact resource name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property Value.
        """
elif False:
    MonitoredResourcesSearchItemPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredResourcesSearchItemPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A filter to return resources that match exact resource name.
        :param pulumi.Input[_builtins.str] value: Property Value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter to return resources that match exact resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MonitoringTemplateAlarmConditionConditionArgsDict(TypedDict):
        query: pulumi.Input[_builtins.str]
        """
        (Updatable) The Monitoring Query Language (MQL) expression to evaluate for the alarm.
        """
        severity: pulumi.Input[_builtins.str]
        """
        (Updatable) Severity - Critical/Warning
        """
        body: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The human-readable content of the delivered alarm notification. Oracle recommends providing guidance to operators for resolving the alarm condition. Consider adding links to standard runbook practices. Avoid entering confidential information.
        """
        should_append_note: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether the note need to add into bottom of the body for mapping the alarms information with template or not.
        """
        should_append_url: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether the URL need to add into bottom of the body for mapping the alarms information with template or not.
        """
        trigger_delay: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING".
        """
elif False:
    MonitoringTemplateAlarmConditionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringTemplateAlarmConditionConditionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[_builtins.str],
                 severity: pulumi.Input[_builtins.str],
                 body: Optional[pulumi.Input[_builtins.str]] = None,
                 should_append_note: Optional[pulumi.Input[_builtins.bool]] = None,
                 should_append_url: Optional[pulumi.Input[_builtins.bool]] = None,
                 trigger_delay: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] query: (Updatable) The Monitoring Query Language (MQL) expression to evaluate for the alarm.
        :param pulumi.Input[_builtins.str] severity: (Updatable) Severity - Critical/Warning
        :param pulumi.Input[_builtins.str] body: (Updatable) The human-readable content of the delivered alarm notification. Oracle recommends providing guidance to operators for resolving the alarm condition. Consider adding links to standard runbook practices. Avoid entering confidential information.
        :param pulumi.Input[_builtins.bool] should_append_note: (Updatable) Whether the note need to add into bottom of the body for mapping the alarms information with template or not.
        :param pulumi.Input[_builtins.bool] should_append_url: (Updatable) Whether the URL need to add into bottom of the body for mapping the alarms information with template or not.
        :param pulumi.Input[_builtins.str] trigger_delay: (Updatable) The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING".
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "severity", severity)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if should_append_note is not None:
            pulumi.set(__self__, "should_append_note", should_append_note)
        if should_append_url is not None:
            pulumi.set(__self__, "should_append_url", should_append_url)
        if trigger_delay is not None:
            pulumi.set(__self__, "trigger_delay", trigger_delay)

    @_builtins.property
    @pulumi.getter
    def query(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The Monitoring Query Language (MQL) expression to evaluate for the alarm.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Severity - Critical/Warning
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "severity", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The human-readable content of the delivered alarm notification. Oracle recommends providing guidance to operators for resolving the alarm condition. Consider adding links to standard runbook practices. Avoid entering confidential information.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter(name="shouldAppendNote")
    def should_append_note(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether the note need to add into bottom of the body for mapping the alarms information with template or not.
        """
        return pulumi.get(self, "should_append_note")

    @should_append_note.setter
    def should_append_note(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_append_note", value)

    @_builtins.property
    @pulumi.getter(name="shouldAppendUrl")
    def should_append_url(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether the URL need to add into bottom of the body for mapping the alarms information with template or not.
        """
        return pulumi.get(self, "should_append_url")

    @should_append_url.setter
    def should_append_url(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_append_url", value)

    @_builtins.property
    @pulumi.getter(name="triggerDelay")
    def trigger_delay(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING".
        """
        return pulumi.get(self, "trigger_delay")

    @trigger_delay.setter
    def trigger_delay(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_delay", value)


if not MYPY:
    class MonitoringTemplateMemberArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        (Updatable) The OCID of the resourceInstance/resourceType/resourceGroup
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the member reference RESOURCE_INSTANCE, RESOURCE_TYPE, RESOURCE_GROUP
        """
        composite_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the composite resource type like EBS or Peoplesoft.
        """
elif False:
    MonitoringTemplateMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringTemplateMemberArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 composite_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: (Updatable) The OCID of the resourceInstance/resourceType/resourceGroup
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the member reference RESOURCE_INSTANCE, RESOURCE_TYPE, RESOURCE_GROUP
        :param pulumi.Input[_builtins.str] composite_type: (Updatable) The OCID of the composite resource type like EBS or Peoplesoft.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if composite_type is not None:
            pulumi.set(__self__, "composite_type", composite_type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The OCID of the resourceInstance/resourceType/resourceGroup
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the member reference RESOURCE_INSTANCE, RESOURCE_TYPE, RESOURCE_GROUP
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="compositeType")
    def composite_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the composite resource type like EBS or Peoplesoft.
        """
        return pulumi.get(self, "composite_type")

    @composite_type.setter
    def composite_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "composite_type", value)


if not MYPY:
    class ProcessSetSpecificationArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['ProcessSetSpecificationItemArgsDict']]]
        """
        (Updatable) List of Process Set specification details.
        """
elif False:
    ProcessSetSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProcessSetSpecificationArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ProcessSetSpecificationItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProcessSetSpecificationItemArgs']]] items: (Updatable) List of Process Set specification details.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ProcessSetSpecificationItemArgs']]]:
        """
        (Updatable) List of Process Set specification details.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ProcessSetSpecificationItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ProcessSetSpecificationItemArgsDict(TypedDict):
        label: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Optional label used to identify a single filter.
        """
        process_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) String literal used for exact matching on process name.
        """
        process_line_regex_pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Regex pattern matching on process arguments.
        """
        process_user: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) String literal used for exact matching on process user.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ProcessSetSpecificationItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProcessSetSpecificationItemArgs:
    def __init__(__self__, *,
                 label: Optional[pulumi.Input[_builtins.str]] = None,
                 process_command: Optional[pulumi.Input[_builtins.str]] = None,
                 process_line_regex_pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 process_user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] label: (Updatable) Optional label used to identify a single filter.
        :param pulumi.Input[_builtins.str] process_command: (Updatable) String literal used for exact matching on process name.
        :param pulumi.Input[_builtins.str] process_line_regex_pattern: (Updatable) Regex pattern matching on process arguments.
        :param pulumi.Input[_builtins.str] process_user: (Updatable) String literal used for exact matching on process user.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if process_command is not None:
            pulumi.set(__self__, "process_command", process_command)
        if process_line_regex_pattern is not None:
            pulumi.set(__self__, "process_line_regex_pattern", process_line_regex_pattern)
        if process_user is not None:
            pulumi.set(__self__, "process_user", process_user)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Optional label used to identify a single filter.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter(name="processCommand")
    def process_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) String literal used for exact matching on process name.
        """
        return pulumi.get(self, "process_command")

    @process_command.setter
    def process_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "process_command", value)

    @_builtins.property
    @pulumi.getter(name="processLineRegexPattern")
    def process_line_regex_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Regex pattern matching on process arguments.
        """
        return pulumi.get(self, "process_line_regex_pattern")

    @process_line_regex_pattern.setter
    def process_line_regex_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "process_line_regex_pattern", value)

    @_builtins.property
    @pulumi.getter(name="processUser")
    def process_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) String literal used for exact matching on process user.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "process_user")

    @process_user.setter
    def process_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "process_user", value)


if not MYPY:
    class GetBaselineableMetricsEvaluateItemArgsDict(TypedDict):
        data_points: Sequence['GetBaselineableMetricsEvaluateItemDataPointArgsDict']
        """
        list of anomaly data points for the metric
        """
        dimensions: Mapping[str, _builtins.str]
        """
        list of dimensions for the metric
        """
        evaluation_data_points: Sequence['GetBaselineableMetricsEvaluateItemEvaluationDataPointArgsDict']
        """
        list of data points for the metric for evaluation of anomalies
        """
        training_data_points: Sequence['GetBaselineableMetricsEvaluateItemTrainingDataPointArgsDict']
        """
        list of data points for the metric for training of baseline
        """
elif False:
    GetBaselineableMetricsEvaluateItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBaselineableMetricsEvaluateItemArgs:
    def __init__(__self__, *,
                 data_points: Sequence['GetBaselineableMetricsEvaluateItemDataPointArgs'],
                 dimensions: Mapping[str, _builtins.str],
                 evaluation_data_points: Sequence['GetBaselineableMetricsEvaluateItemEvaluationDataPointArgs'],
                 training_data_points: Sequence['GetBaselineableMetricsEvaluateItemTrainingDataPointArgs']):
        """
        :param Sequence['GetBaselineableMetricsEvaluateItemDataPointArgs'] data_points: list of anomaly data points for the metric
        :param Mapping[str, _builtins.str] dimensions: list of dimensions for the metric
        :param Sequence['GetBaselineableMetricsEvaluateItemEvaluationDataPointArgs'] evaluation_data_points: list of data points for the metric for evaluation of anomalies
        :param Sequence['GetBaselineableMetricsEvaluateItemTrainingDataPointArgs'] training_data_points: list of data points for the metric for training of baseline
        """
        pulumi.set(__self__, "data_points", data_points)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "evaluation_data_points", evaluation_data_points)
        pulumi.set(__self__, "training_data_points", training_data_points)

    @_builtins.property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Sequence['GetBaselineableMetricsEvaluateItemDataPointArgs']:
        """
        list of anomaly data points for the metric
        """
        return pulumi.get(self, "data_points")

    @data_points.setter
    def data_points(self, value: Sequence['GetBaselineableMetricsEvaluateItemDataPointArgs']):
        pulumi.set(self, "data_points", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Mapping[str, _builtins.str]:
        """
        list of dimensions for the metric
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="evaluationDataPoints")
    def evaluation_data_points(self) -> Sequence['GetBaselineableMetricsEvaluateItemEvaluationDataPointArgs']:
        """
        list of data points for the metric for evaluation of anomalies
        """
        return pulumi.get(self, "evaluation_data_points")

    @evaluation_data_points.setter
    def evaluation_data_points(self, value: Sequence['GetBaselineableMetricsEvaluateItemEvaluationDataPointArgs']):
        pulumi.set(self, "evaluation_data_points", value)

    @_builtins.property
    @pulumi.getter(name="trainingDataPoints")
    def training_data_points(self) -> Sequence['GetBaselineableMetricsEvaluateItemTrainingDataPointArgs']:
        """
        list of data points for the metric for training of baseline
        """
        return pulumi.get(self, "training_data_points")

    @training_data_points.setter
    def training_data_points(self, value: Sequence['GetBaselineableMetricsEvaluateItemTrainingDataPointArgs']):
        pulumi.set(self, "training_data_points", value)


if not MYPY:
    class GetBaselineableMetricsEvaluateItemDataPointArgsDict(TypedDict):
        anomaly: _builtins.float
        """
        if the value is anomaly or not 0 indicates not an anomaly -1 indicates value is below the threshold +1 indicates value is above the threshold
        """
        high: _builtins.float
        """
        upper threshold for the metric value
        """
        low: _builtins.float
        """
        lower threshold for the metric value
        """
        timestamp: _builtins.str
        """
        timestamp of when the metric was collected
        """
        value: _builtins.float
        """
        value for the metric data point
        """
elif False:
    GetBaselineableMetricsEvaluateItemDataPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBaselineableMetricsEvaluateItemDataPointArgs:
    def __init__(__self__, *,
                 anomaly: _builtins.float,
                 high: _builtins.float,
                 low: _builtins.float,
                 timestamp: _builtins.str,
                 value: _builtins.float):
        """
        :param _builtins.float anomaly: if the value is anomaly or not 0 indicates not an anomaly -1 indicates value is below the threshold +1 indicates value is above the threshold
        :param _builtins.float high: upper threshold for the metric value
        :param _builtins.float low: lower threshold for the metric value
        :param _builtins.str timestamp: timestamp of when the metric was collected
        :param _builtins.float value: value for the metric data point
        """
        pulumi.set(__self__, "anomaly", anomaly)
        pulumi.set(__self__, "high", high)
        pulumi.set(__self__, "low", low)
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def anomaly(self) -> _builtins.float:
        """
        if the value is anomaly or not 0 indicates not an anomaly -1 indicates value is below the threshold +1 indicates value is above the threshold
        """
        return pulumi.get(self, "anomaly")

    @anomaly.setter
    def anomaly(self, value: _builtins.float):
        pulumi.set(self, "anomaly", value)

    @_builtins.property
    @pulumi.getter
    def high(self) -> _builtins.float:
        """
        upper threshold for the metric value
        """
        return pulumi.get(self, "high")

    @high.setter
    def high(self, value: _builtins.float):
        pulumi.set(self, "high", value)

    @_builtins.property
    @pulumi.getter
    def low(self) -> _builtins.float:
        """
        lower threshold for the metric value
        """
        return pulumi.get(self, "low")

    @low.setter
    def low(self, value: _builtins.float):
        pulumi.set(self, "low", value)

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        timestamp of when the metric was collected
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: _builtins.str):
        pulumi.set(self, "timestamp", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        value for the metric data point
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.float):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetBaselineableMetricsEvaluateItemEvaluationDataPointArgsDict(TypedDict):
        timestamp: _builtins.str
        """
        timestamp of when the metric was collected
        """
        value: _builtins.float
        """
        value for the metric data point
        """
elif False:
    GetBaselineableMetricsEvaluateItemEvaluationDataPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBaselineableMetricsEvaluateItemEvaluationDataPointArgs:
    def __init__(__self__, *,
                 timestamp: _builtins.str,
                 value: _builtins.float):
        """
        :param _builtins.str timestamp: timestamp of when the metric was collected
        :param _builtins.float value: value for the metric data point
        """
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        timestamp of when the metric was collected
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: _builtins.str):
        pulumi.set(self, "timestamp", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        value for the metric data point
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.float):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetBaselineableMetricsEvaluateItemTrainingDataPointArgsDict(TypedDict):
        timestamp: _builtins.str
        """
        timestamp of when the metric was collected
        """
        value: _builtins.float
        """
        value for the metric data point
        """
elif False:
    GetBaselineableMetricsEvaluateItemTrainingDataPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBaselineableMetricsEvaluateItemTrainingDataPointArgs:
    def __init__(__self__, *,
                 timestamp: _builtins.str,
                 value: _builtins.float):
        """
        :param _builtins.str timestamp: timestamp of when the metric was collected
        :param _builtins.float value: value for the metric data point
        """
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        timestamp of when the metric was collected
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: _builtins.str):
        pulumi.set(self, "timestamp", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        value for the metric data point
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.float):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetBaselineableMetricsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Metric Name
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetBaselineableMetricsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBaselineableMetricsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Metric Name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Metric Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetConfigsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of user Group
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetConfigsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConfigsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of user Group
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of user Group
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDefinedMonitoringTemplatesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDefinedMonitoringTemplatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDefinedMonitoringTemplatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDiscoveryJobLogsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDiscoveryJobLogsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDiscoveryJobLogsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDiscoveryJobsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only discovery jobs that match the entire resource name given.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDiscoveryJobsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDiscoveryJobsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only discovery jobs that match the entire resource name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only discovery jobs that match the entire resource name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaintenanceWindowsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return maintenance windows that match exact resource name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaintenanceWindowsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaintenanceWindowsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return maintenance windows that match exact resource name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return maintenance windows that match exact resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMetricExtensionsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return resources based on name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMetricExtensionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMetricExtensionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return resources based on name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return resources based on name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMonitoredResourceTasksFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Property name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMonitoredResourceTasksFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMonitoredResourceTasksFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Property name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMonitoredResourceTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return monitored resource types that match exactly with the resource type name given.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMonitoredResourceTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMonitoredResourceTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return monitored resource types that match exactly with the resource type name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return monitored resource types that match exactly with the resource type name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMonitoredResourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return resources that match exact resource name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMonitoredResourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMonitoredResourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return resources that match exact resource name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return resources that match exact resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMonitoringTemplateAlarmConditionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMonitoringTemplateAlarmConditionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMonitoringTemplateAlarmConditionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMonitoringTemplatesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMonitoringTemplatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMonitoringTemplatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProcessSetsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetProcessSetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProcessSetsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


