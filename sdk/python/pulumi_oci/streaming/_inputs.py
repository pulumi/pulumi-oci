# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'StreamPoolCustomEncryptionKeyArgs',
    'StreamPoolCustomEncryptionKeyArgsDict',
    'StreamPoolKafkaSettingsArgs',
    'StreamPoolKafkaSettingsArgsDict',
    'StreamPoolPrivateEndpointSettingsArgs',
    'StreamPoolPrivateEndpointSettingsArgsDict',
    'GetConnectHarnessesFilterArgs',
    'GetConnectHarnessesFilterArgsDict',
    'GetStreamPoolsFilterArgs',
    'GetStreamPoolsFilterArgsDict',
    'GetStreamsFilterArgs',
    'GetStreamsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class StreamPoolCustomEncryptionKeyArgsDict(TypedDict):
        kms_key_id: pulumi.Input[_builtins.str]
        """
        (Updatable) Custom Encryption Key (Master Key) ocid.
        """
        key_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Life cycle State of the custom key
        """
elif False:
    StreamPoolCustomEncryptionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamPoolCustomEncryptionKeyArgs:
    def __init__(__self__, *,
                 kms_key_id: pulumi.Input[_builtins.str],
                 key_state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] kms_key_id: (Updatable) Custom Encryption Key (Master Key) ocid.
        :param pulumi.Input[_builtins.str] key_state: Life cycle State of the custom key
        """
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        if key_state is not None:
            pulumi.set(__self__, "key_state", key_state)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Custom Encryption Key (Master Key) ocid.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="keyState")
    def key_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Life cycle State of the custom key
        """
        return pulumi.get(self, "key_state")

    @key_state.setter
    def key_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_state", value)


if not MYPY:
    class StreamPoolKafkaSettingsArgsDict(TypedDict):
        auto_create_topics_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enable auto creation of topic on the server.
        """
        bootstrap_servers: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Bootstrap servers.
        """
        log_retention_hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The number of hours to keep a log file before deleting it (in hours).
        """
        num_partitions: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The default number of log partitions per topic.
        """
elif False:
    StreamPoolKafkaSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamPoolKafkaSettingsArgs:
    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 bootstrap_servers: Optional[pulumi.Input[_builtins.str]] = None,
                 log_retention_hours: Optional[pulumi.Input[_builtins.int]] = None,
                 num_partitions: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] auto_create_topics_enable: (Updatable) Enable auto creation of topic on the server.
        :param pulumi.Input[_builtins.str] bootstrap_servers: (Updatable) Bootstrap servers.
        :param pulumi.Input[_builtins.int] log_retention_hours: (Updatable) The number of hours to keep a log file before deleting it (in hours).
        :param pulumi.Input[_builtins.int] num_partitions: (Updatable) The default number of log partitions per topic.
        """
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if bootstrap_servers is not None:
            pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)

    @_builtins.property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enable auto creation of topic on the server.
        """
        return pulumi.get(self, "auto_create_topics_enable")

    @auto_create_topics_enable.setter
    def auto_create_topics_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_create_topics_enable", value)

    @_builtins.property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Bootstrap servers.
        """
        return pulumi.get(self, "bootstrap_servers")

    @bootstrap_servers.setter
    def bootstrap_servers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bootstrap_servers", value)

    @_builtins.property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The number of hours to keep a log file before deleting it (in hours).
        """
        return pulumi.get(self, "log_retention_hours")

    @log_retention_hours.setter
    def log_retention_hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "log_retention_hours", value)

    @_builtins.property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The default number of log partitions per topic.
        """
        return pulumi.get(self, "num_partitions")

    @num_partitions.setter
    def num_partitions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_partitions", value)


if not MYPY:
    class StreamPoolPrivateEndpointSettingsArgsDict(TypedDict):
        nsg_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The optional list of network security groups to be used with the private endpoint of the stream pool. That value cannot be changed.
        """
        private_endpoint_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The optional private IP you want to be associated with your private stream pool. That parameter can only be specified when the subnetId parameter is set. It cannot be changed. The private IP needs to be part of the CIDR range of the specified subnetId or the creation will fail. If not specified a random IP inside the subnet will be chosen. After the stream pool is created, a custom FQDN, pointing to this private IP, is created. The FQDN is then used to access the service instead of the private IP.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        If specified, the stream pool will be private and only accessible from inside that subnet. Producing-to and consuming-from a stream inside a private stream pool can also only be done from inside the subnet. That value cannot be changed. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    StreamPoolPrivateEndpointSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamPoolPrivateEndpointSettingsArgs:
    def __init__(__self__, *,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 private_endpoint_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nsg_ids: The optional list of network security groups to be used with the private endpoint of the stream pool. That value cannot be changed.
        :param pulumi.Input[_builtins.str] private_endpoint_ip: The optional private IP you want to be associated with your private stream pool. That parameter can only be specified when the subnetId parameter is set. It cannot be changed. The private IP needs to be part of the CIDR range of the specified subnetId or the creation will fail. If not specified a random IP inside the subnet will be chosen. After the stream pool is created, a custom FQDN, pointing to this private IP, is created. The FQDN is then used to access the service instead of the private IP.
        :param pulumi.Input[_builtins.str] subnet_id: If specified, the stream pool will be private and only accessible from inside that subnet. Producing-to and consuming-from a stream inside a private stream pool can also only be done from inside the subnet. That value cannot be changed. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if private_endpoint_ip is not None:
            pulumi.set(__self__, "private_endpoint_ip", private_endpoint_ip)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The optional list of network security groups to be used with the private endpoint of the stream pool. That value cannot be changed.
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointIp")
    def private_endpoint_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The optional private IP you want to be associated with your private stream pool. That parameter can only be specified when the subnetId parameter is set. It cannot be changed. The private IP needs to be part of the CIDR range of the specified subnetId or the creation will fail. If not specified a random IP inside the subnet will be chosen. After the stream pool is created, a custom FQDN, pointing to this private IP, is created. The FQDN is then used to access the service instead of the private IP.
        """
        return pulumi.get(self, "private_endpoint_ip")

    @private_endpoint_ip.setter
    def private_endpoint_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_ip", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If specified, the stream pool will be private and only accessible from inside that subnet. Producing-to and consuming-from a stream inside a private stream pool can also only be done from inside the subnet. That value cannot be changed. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class GetConnectHarnessesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the given name exactly.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetConnectHarnessesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectHarnessesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetStreamPoolsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the given name exactly.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetStreamPoolsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStreamPoolsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetStreamsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the given name exactly.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetStreamsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStreamsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


