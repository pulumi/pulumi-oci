# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ContainerScanRecipeScanSettingsArgs',
    'ContainerScanRecipeScanSettingsArgsDict',
    'ContainerScanTargetTargetRegistryArgs',
    'ContainerScanTargetTargetRegistryArgsDict',
    'HostScanRecipeAgentSettingsArgs',
    'HostScanRecipeAgentSettingsArgsDict',
    'HostScanRecipeAgentSettingsAgentConfigurationArgs',
    'HostScanRecipeAgentSettingsAgentConfigurationArgsDict',
    'HostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs',
    'HostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgsDict',
    'HostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs',
    'HostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgsDict',
    'HostScanRecipeApplicationSettingsArgs',
    'HostScanRecipeApplicationSettingsArgsDict',
    'HostScanRecipeApplicationSettingsFoldersToScanArgs',
    'HostScanRecipeApplicationSettingsFoldersToScanArgsDict',
    'HostScanRecipePortSettingsArgs',
    'HostScanRecipePortSettingsArgsDict',
    'HostScanRecipeScheduleArgs',
    'HostScanRecipeScheduleArgsDict',
    'GetContainerScanRecipesFilterArgs',
    'GetContainerScanRecipesFilterArgsDict',
    'GetContainerScanTargetsFilterArgs',
    'GetContainerScanTargetsFilterArgsDict',
    'GetHostScanRecipesFilterArgs',
    'GetHostScanRecipesFilterArgsDict',
    'GetHostScanTargetErrorsFilterArgs',
    'GetHostScanTargetErrorsFilterArgsDict',
    'GetHostScanTargetsFilterArgs',
    'GetHostScanTargetsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ContainerScanRecipeScanSettingsArgsDict(TypedDict):
        scan_level: pulumi.Input[_builtins.str]
        """
        (Updatable) The scan level


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ContainerScanRecipeScanSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerScanRecipeScanSettingsArgs:
    def __init__(__self__, *,
                 scan_level: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] scan_level: (Updatable) The scan level
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "scan_level", scan_level)

    @_builtins.property
    @pulumi.getter(name="scanLevel")
    def scan_level(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The scan level


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "scan_level")

    @scan_level.setter
    def scan_level(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scan_level", value)


if not MYPY:
    class ContainerScanTargetTargetRegistryArgsDict(TypedDict):
        compartment_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment to perform the scans in. All listed repositories must be in the compartment.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) The scan level
        """
        repositories: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of repositories to scan images in. If left empty, the target defaults to scanning all repos in the compartmentId
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) URL of the registry. Required for non-OCIR registry types (for OCIR registry types, it can be inferred from the tenancy).


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ContainerScanTargetTargetRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerScanTargetTargetRegistryArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 repositories: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment to perform the scans in. All listed repositories must be in the compartment.
        :param pulumi.Input[_builtins.str] type: (Updatable) The scan level
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repositories: (Updatable) List of repositories to scan images in. If left empty, the target defaults to scanning all repos in the compartmentId
        :param pulumi.Input[_builtins.str] url: (Updatable) URL of the registry. Required for non-OCIR registry types (for OCIR registry types, it can be inferred from the tenancy).
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "type", type)
        if repositories is not None:
            pulumi.set(__self__, "repositories", repositories)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment to perform the scans in. All listed repositories must be in the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The scan level
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of repositories to scan images in. If left empty, the target defaults to scanning all repos in the compartmentId
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "repositories", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) URL of the registry. Required for non-OCIR registry types (for OCIR registry types, it can be inferred from the tenancy).


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class HostScanRecipeAgentSettingsArgsDict(TypedDict):
        scan_level: pulumi.Input[_builtins.str]
        """
        (Updatable) The scan level
        """
        agent_configuration: NotRequired[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationArgsDict']]
        """
        (Updatable) Agent configuration for host scan agent settings. This model is polymorphic, presenting different configuration options based on selected agent vendor.
        """
elif False:
    HostScanRecipeAgentSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostScanRecipeAgentSettingsArgs:
    def __init__(__self__, *,
                 scan_level: pulumi.Input[_builtins.str],
                 agent_configuration: Optional[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] scan_level: (Updatable) The scan level
        :param pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationArgs'] agent_configuration: (Updatable) Agent configuration for host scan agent settings. This model is polymorphic, presenting different configuration options based on selected agent vendor.
        """
        pulumi.set(__self__, "scan_level", scan_level)
        if agent_configuration is not None:
            pulumi.set(__self__, "agent_configuration", agent_configuration)

    @_builtins.property
    @pulumi.getter(name="scanLevel")
    def scan_level(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The scan level
        """
        return pulumi.get(self, "scan_level")

    @scan_level.setter
    def scan_level(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scan_level", value)

    @_builtins.property
    @pulumi.getter(name="agentConfiguration")
    def agent_configuration(self) -> Optional[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationArgs']]:
        """
        (Updatable) Agent configuration for host scan agent settings. This model is polymorphic, presenting different configuration options based on selected agent vendor.
        """
        return pulumi.get(self, "agent_configuration")

    @agent_configuration.setter
    def agent_configuration(self, value: Optional[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationArgs']]):
        pulumi.set(self, "agent_configuration", value)


if not MYPY:
    class HostScanRecipeAgentSettingsAgentConfigurationArgsDict(TypedDict):
        vendor: pulumi.Input[_builtins.str]
        """
        (Updatable) Vendor to use for the host scan agent.
        """
        cis_benchmark_settings: NotRequired[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgsDict']]
        """
        (Updatable) CIS (Center for Internet Security) Benchmark scan settings for a host scan
        """
        endpoint_protection_settings: NotRequired[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgsDict']]
        """
        (Updatable) Endpoint Protection scan settings for a host scan
        """
        should_un_install: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Boolean flag letting agent know if it should un-install the Qualys agent when it is stopped.
        """
        vault_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Vault secret OCID which stores license information. Content inside this secret in vault would be base64 string containing information about customer's Qualys susbcription license.
        """
        vendor_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Vendor to use for the host scan agent.
        """
elif False:
    HostScanRecipeAgentSettingsAgentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostScanRecipeAgentSettingsAgentConfigurationArgs:
    def __init__(__self__, *,
                 vendor: pulumi.Input[_builtins.str],
                 cis_benchmark_settings: Optional[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs']] = None,
                 endpoint_protection_settings: Optional[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs']] = None,
                 should_un_install: Optional[pulumi.Input[_builtins.bool]] = None,
                 vault_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vendor_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] vendor: (Updatable) Vendor to use for the host scan agent.
        :param pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs'] cis_benchmark_settings: (Updatable) CIS (Center for Internet Security) Benchmark scan settings for a host scan
        :param pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs'] endpoint_protection_settings: (Updatable) Endpoint Protection scan settings for a host scan
        :param pulumi.Input[_builtins.bool] should_un_install: (Updatable) Boolean flag letting agent know if it should un-install the Qualys agent when it is stopped.
        :param pulumi.Input[_builtins.str] vault_secret_id: (Updatable) Vault secret OCID which stores license information. Content inside this secret in vault would be base64 string containing information about customer's Qualys susbcription license.
        :param pulumi.Input[_builtins.str] vendor_type: (Updatable) Vendor to use for the host scan agent.
        """
        pulumi.set(__self__, "vendor", vendor)
        if cis_benchmark_settings is not None:
            pulumi.set(__self__, "cis_benchmark_settings", cis_benchmark_settings)
        if endpoint_protection_settings is not None:
            pulumi.set(__self__, "endpoint_protection_settings", endpoint_protection_settings)
        if should_un_install is not None:
            pulumi.set(__self__, "should_un_install", should_un_install)
        if vault_secret_id is not None:
            pulumi.set(__self__, "vault_secret_id", vault_secret_id)
        if vendor_type is not None:
            pulumi.set(__self__, "vendor_type", vendor_type)

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Vendor to use for the host scan agent.
        """
        return pulumi.get(self, "vendor")

    @vendor.setter
    def vendor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vendor", value)

    @_builtins.property
    @pulumi.getter(name="cisBenchmarkSettings")
    def cis_benchmark_settings(self) -> Optional[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs']]:
        """
        (Updatable) CIS (Center for Internet Security) Benchmark scan settings for a host scan
        """
        return pulumi.get(self, "cis_benchmark_settings")

    @cis_benchmark_settings.setter
    def cis_benchmark_settings(self, value: Optional[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs']]):
        pulumi.set(self, "cis_benchmark_settings", value)

    @_builtins.property
    @pulumi.getter(name="endpointProtectionSettings")
    def endpoint_protection_settings(self) -> Optional[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs']]:
        """
        (Updatable) Endpoint Protection scan settings for a host scan
        """
        return pulumi.get(self, "endpoint_protection_settings")

    @endpoint_protection_settings.setter
    def endpoint_protection_settings(self, value: Optional[pulumi.Input['HostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs']]):
        pulumi.set(self, "endpoint_protection_settings", value)

    @_builtins.property
    @pulumi.getter(name="shouldUnInstall")
    def should_un_install(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Boolean flag letting agent know if it should un-install the Qualys agent when it is stopped.
        """
        return pulumi.get(self, "should_un_install")

    @should_un_install.setter
    def should_un_install(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_un_install", value)

    @_builtins.property
    @pulumi.getter(name="vaultSecretId")
    def vault_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Vault secret OCID which stores license information. Content inside this secret in vault would be base64 string containing information about customer's Qualys susbcription license.
        """
        return pulumi.get(self, "vault_secret_id")

    @vault_secret_id.setter
    def vault_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="vendorType")
    def vendor_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Vendor to use for the host scan agent.
        """
        return pulumi.get(self, "vendor_type")

    @vendor_type.setter
    def vendor_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vendor_type", value)


if not MYPY:
    class HostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgsDict(TypedDict):
        scan_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The level of strictness to apply for CIS Benchmarks. Use 'NONE' to disable CIS Benchmark checks entirely.
        """
elif False:
    HostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs:
    def __init__(__self__, *,
                 scan_level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] scan_level: (Updatable) The level of strictness to apply for CIS Benchmarks. Use 'NONE' to disable CIS Benchmark checks entirely.
        """
        if scan_level is not None:
            pulumi.set(__self__, "scan_level", scan_level)

    @_builtins.property
    @pulumi.getter(name="scanLevel")
    def scan_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The level of strictness to apply for CIS Benchmarks. Use 'NONE' to disable CIS Benchmark checks entirely.
        """
        return pulumi.get(self, "scan_level")

    @scan_level.setter
    def scan_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scan_level", value)


if not MYPY:
    class HostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgsDict(TypedDict):
        scan_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The scan level. Use 'NONE' to disable Endpoint Protection checks entirely.
        """
elif False:
    HostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs:
    def __init__(__self__, *,
                 scan_level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] scan_level: (Updatable) The scan level. Use 'NONE' to disable Endpoint Protection checks entirely.
        """
        if scan_level is not None:
            pulumi.set(__self__, "scan_level", scan_level)

    @_builtins.property
    @pulumi.getter(name="scanLevel")
    def scan_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The scan level. Use 'NONE' to disable Endpoint Protection checks entirely.
        """
        return pulumi.get(self, "scan_level")

    @scan_level.setter
    def scan_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scan_level", value)


if not MYPY:
    class HostScanRecipeApplicationSettingsArgsDict(TypedDict):
        application_scan_recurrence: pulumi.Input[_builtins.str]
        """
        (Updatable) Scan recurrences in RFC-5545 section 3.3.10 format. Only supported input are weekly, biweekly, monthly listed below FREQ=WEEKLY;WKST=<weekday>;INTERVAL=1 - This weekly scan on the specified weekday (e.g. SU for Sunday) FREQ=WEEKLY;WKST=<weekday>;INTERVAL=2 - This bi-weekly scan on the specified weekday (e.g. SU for Sunday) FREQ=MONTHLY;WKST=<weekday>;INTERVAL=1 - This monthly scan on the specified weekday (e.g. SU for Sunday, starting from the next such weekday based on the time of setting creation)
        """
        folders_to_scans: pulumi.Input[Sequence[pulumi.Input['HostScanRecipeApplicationSettingsFoldersToScanArgsDict']]]
        """
        (Updatable) List of folders selected for scanning
        """
        is_enabled: pulumi.Input[_builtins.bool]
        """
        (Updatable) Enable or disable application scan
        """
elif False:
    HostScanRecipeApplicationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostScanRecipeApplicationSettingsArgs:
    def __init__(__self__, *,
                 application_scan_recurrence: pulumi.Input[_builtins.str],
                 folders_to_scans: pulumi.Input[Sequence[pulumi.Input['HostScanRecipeApplicationSettingsFoldersToScanArgs']]],
                 is_enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.str] application_scan_recurrence: (Updatable) Scan recurrences in RFC-5545 section 3.3.10 format. Only supported input are weekly, biweekly, monthly listed below FREQ=WEEKLY;WKST=<weekday>;INTERVAL=1 - This weekly scan on the specified weekday (e.g. SU for Sunday) FREQ=WEEKLY;WKST=<weekday>;INTERVAL=2 - This bi-weekly scan on the specified weekday (e.g. SU for Sunday) FREQ=MONTHLY;WKST=<weekday>;INTERVAL=1 - This monthly scan on the specified weekday (e.g. SU for Sunday, starting from the next such weekday based on the time of setting creation)
        :param pulumi.Input[Sequence[pulumi.Input['HostScanRecipeApplicationSettingsFoldersToScanArgs']]] folders_to_scans: (Updatable) List of folders selected for scanning
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Enable or disable application scan
        """
        pulumi.set(__self__, "application_scan_recurrence", application_scan_recurrence)
        pulumi.set(__self__, "folders_to_scans", folders_to_scans)
        pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="applicationScanRecurrence")
    def application_scan_recurrence(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Scan recurrences in RFC-5545 section 3.3.10 format. Only supported input are weekly, biweekly, monthly listed below FREQ=WEEKLY;WKST=<weekday>;INTERVAL=1 - This weekly scan on the specified weekday (e.g. SU for Sunday) FREQ=WEEKLY;WKST=<weekday>;INTERVAL=2 - This bi-weekly scan on the specified weekday (e.g. SU for Sunday) FREQ=MONTHLY;WKST=<weekday>;INTERVAL=1 - This monthly scan on the specified weekday (e.g. SU for Sunday, starting from the next such weekday based on the time of setting creation)
        """
        return pulumi.get(self, "application_scan_recurrence")

    @application_scan_recurrence.setter
    def application_scan_recurrence(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "application_scan_recurrence", value)

    @_builtins.property
    @pulumi.getter(name="foldersToScans")
    def folders_to_scans(self) -> pulumi.Input[Sequence[pulumi.Input['HostScanRecipeApplicationSettingsFoldersToScanArgs']]]:
        """
        (Updatable) List of folders selected for scanning
        """
        return pulumi.get(self, "folders_to_scans")

    @folders_to_scans.setter
    def folders_to_scans(self, value: pulumi.Input[Sequence[pulumi.Input['HostScanRecipeApplicationSettingsFoldersToScanArgs']]]):
        pulumi.set(self, "folders_to_scans", value)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) Enable or disable application scan
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class HostScanRecipeApplicationSettingsFoldersToScanArgsDict(TypedDict):
        folder: pulumi.Input[_builtins.str]
        """
        (Updatable) Folder to be scanned in the corresponding operating system
        """
        operatingsystem: pulumi.Input[_builtins.str]
        """
        (Updatable) Operating system type
        """
elif False:
    HostScanRecipeApplicationSettingsFoldersToScanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostScanRecipeApplicationSettingsFoldersToScanArgs:
    def __init__(__self__, *,
                 folder: pulumi.Input[_builtins.str],
                 operatingsystem: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] folder: (Updatable) Folder to be scanned in the corresponding operating system
        :param pulumi.Input[_builtins.str] operatingsystem: (Updatable) Operating system type
        """
        pulumi.set(__self__, "folder", folder)
        pulumi.set(__self__, "operatingsystem", operatingsystem)

    @_builtins.property
    @pulumi.getter
    def folder(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Folder to be scanned in the corresponding operating system
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "folder", value)

    @_builtins.property
    @pulumi.getter
    def operatingsystem(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Operating system type
        """
        return pulumi.get(self, "operatingsystem")

    @operatingsystem.setter
    def operatingsystem(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operatingsystem", value)


if not MYPY:
    class HostScanRecipePortSettingsArgsDict(TypedDict):
        scan_level: pulumi.Input[_builtins.str]
        """
        (Updatable) The scan level
        """
elif False:
    HostScanRecipePortSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostScanRecipePortSettingsArgs:
    def __init__(__self__, *,
                 scan_level: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] scan_level: (Updatable) The scan level
        """
        pulumi.set(__self__, "scan_level", scan_level)

    @_builtins.property
    @pulumi.getter(name="scanLevel")
    def scan_level(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The scan level
        """
        return pulumi.get(self, "scan_level")

    @scan_level.setter
    def scan_level(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scan_level", value)


if not MYPY:
    class HostScanRecipeScheduleArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) How often the scan occurs


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        day_of_week: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Day of week the scheduled scan occurs (not applicable for DAILY type)
        """
elif False:
    HostScanRecipeScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostScanRecipeScheduleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 day_of_week: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) How often the scan occurs
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] day_of_week: (Updatable) Day of week the scheduled scan occurs (not applicable for DAILY type)
        """
        pulumi.set(__self__, "type", type)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) How often the scan occurs


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Day of week the scheduled scan occurs (not applicable for DAILY type)
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "day_of_week", value)


if not MYPY:
    class GetContainerScanRecipesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetContainerScanRecipesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetContainerScanRecipesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetContainerScanTargetsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetContainerScanTargetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetContainerScanTargetsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetHostScanRecipesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetHostScanRecipesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHostScanRecipesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetHostScanTargetErrorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetHostScanTargetErrorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHostScanTargetErrorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetHostScanTargetsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetHostScanTargetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHostScanTargetsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


