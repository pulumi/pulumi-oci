# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AppAccelerationPolicyResponseCachingPolicyArgs',
    'AppAccelerationPolicyResponseCachingPolicyArgsDict',
    'AppAccelerationPolicyResponseCompressionPolicyArgs',
    'AppAccelerationPolicyResponseCompressionPolicyArgsDict',
    'AppAccelerationPolicyResponseCompressionPolicyGzipCompressionArgs',
    'AppAccelerationPolicyResponseCompressionPolicyGzipCompressionArgsDict',
    'GetAppAccelerationPoliciesFilterArgs',
    'GetAppAccelerationPoliciesFilterArgsDict',
    'GetAppAccelerationsFilterArgs',
    'GetAppAccelerationsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AppAccelerationPolicyResponseCachingPolicyArgsDict(TypedDict):
        is_response_header_based_caching_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) When false, responses will not be cached by the backend based on response headers.

        When true, responses that contain one of the supported cache control headers will be cached according to the values specified in the cache control headers.

        The "X-Accel-Expires" header field sets caching time of a response in seconds. The zero value disables caching for a response. If the value starts with the @ prefix, it sets an absolute time in seconds since Epoch, up to which the response may be cached.

        If the header does not include the "X-Accel-Expires" field, parameters of caching may be set in the header fields "Expires" or "Cache-Control".

        If the header includes the "Set-Cookie" field, such a response will not be cached.

        If the header includes the "Vary" field with the special value "*", such a response will not be cached. If the header includes the "Vary" field with another value, such a response will be cached taking into account the corresponding request header fields.
        """
elif False:
    AppAccelerationPolicyResponseCachingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAccelerationPolicyResponseCachingPolicyArgs:
    def __init__(__self__, *,
                 is_response_header_based_caching_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_response_header_based_caching_enabled: (Updatable) When false, responses will not be cached by the backend based on response headers.
               
               When true, responses that contain one of the supported cache control headers will be cached according to the values specified in the cache control headers.
               
               The "X-Accel-Expires" header field sets caching time of a response in seconds. The zero value disables caching for a response. If the value starts with the @ prefix, it sets an absolute time in seconds since Epoch, up to which the response may be cached.
               
               If the header does not include the "X-Accel-Expires" field, parameters of caching may be set in the header fields "Expires" or "Cache-Control".
               
               If the header includes the "Set-Cookie" field, such a response will not be cached.
               
               If the header includes the "Vary" field with the special value "*", such a response will not be cached. If the header includes the "Vary" field with another value, such a response will be cached taking into account the corresponding request header fields.
        """
        if is_response_header_based_caching_enabled is not None:
            pulumi.set(__self__, "is_response_header_based_caching_enabled", is_response_header_based_caching_enabled)

    @_builtins.property
    @pulumi.getter(name="isResponseHeaderBasedCachingEnabled")
    def is_response_header_based_caching_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) When false, responses will not be cached by the backend based on response headers.

        When true, responses that contain one of the supported cache control headers will be cached according to the values specified in the cache control headers.

        The "X-Accel-Expires" header field sets caching time of a response in seconds. The zero value disables caching for a response. If the value starts with the @ prefix, it sets an absolute time in seconds since Epoch, up to which the response may be cached.

        If the header does not include the "X-Accel-Expires" field, parameters of caching may be set in the header fields "Expires" or "Cache-Control".

        If the header includes the "Set-Cookie" field, such a response will not be cached.

        If the header includes the "Vary" field with the special value "*", such a response will not be cached. If the header includes the "Vary" field with another value, such a response will be cached taking into account the corresponding request header fields.
        """
        return pulumi.get(self, "is_response_header_based_caching_enabled")

    @is_response_header_based_caching_enabled.setter
    def is_response_header_based_caching_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_response_header_based_caching_enabled", value)


if not MYPY:
    class AppAccelerationPolicyResponseCompressionPolicyArgsDict(TypedDict):
        gzip_compression: NotRequired[pulumi.Input['AppAccelerationPolicyResponseCompressionPolicyGzipCompressionArgsDict']]
        """
        (Updatable) An object that specifies the gzip compression policy.
        """
elif False:
    AppAccelerationPolicyResponseCompressionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAccelerationPolicyResponseCompressionPolicyArgs:
    def __init__(__self__, *,
                 gzip_compression: Optional[pulumi.Input['AppAccelerationPolicyResponseCompressionPolicyGzipCompressionArgs']] = None):
        """
        :param pulumi.Input['AppAccelerationPolicyResponseCompressionPolicyGzipCompressionArgs'] gzip_compression: (Updatable) An object that specifies the gzip compression policy.
        """
        if gzip_compression is not None:
            pulumi.set(__self__, "gzip_compression", gzip_compression)

    @_builtins.property
    @pulumi.getter(name="gzipCompression")
    def gzip_compression(self) -> Optional[pulumi.Input['AppAccelerationPolicyResponseCompressionPolicyGzipCompressionArgs']]:
        """
        (Updatable) An object that specifies the gzip compression policy.
        """
        return pulumi.get(self, "gzip_compression")

    @gzip_compression.setter
    def gzip_compression(self, value: Optional[pulumi.Input['AppAccelerationPolicyResponseCompressionPolicyGzipCompressionArgs']]):
        pulumi.set(self, "gzip_compression", value)


if not MYPY:
    class AppAccelerationPolicyResponseCompressionPolicyGzipCompressionArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) When true, support for gzip compression is enabled. HTTP responses will be compressed with gzip only if the client indicates support for gzip via the "Accept-Encoding: gzip" request header.

        When false, support for gzip compression is disabled and HTTP responses will not be compressed with gzip even if the client indicates support for gzip.
        """
elif False:
    AppAccelerationPolicyResponseCompressionPolicyGzipCompressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAccelerationPolicyResponseCompressionPolicyGzipCompressionArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) When true, support for gzip compression is enabled. HTTP responses will be compressed with gzip only if the client indicates support for gzip via the "Accept-Encoding: gzip" request header.
               
               When false, support for gzip compression is disabled and HTTP responses will not be compressed with gzip even if the client indicates support for gzip.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) When true, support for gzip compression is enabled. HTTP responses will be compressed with gzip only if the client indicates support for gzip via the "Accept-Encoding: gzip" request header.

        When false, support for gzip compression is disabled and HTTP responses will not be compressed with gzip even if the client indicates support for gzip.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class GetAppAccelerationPoliciesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAppAccelerationPoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppAccelerationPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAppAccelerationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAppAccelerationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppAccelerationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


