# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AppFirewallPolicyActionArgs',
    'AppFirewallPolicyActionArgsDict',
    'AppFirewallPolicyActionBodyArgs',
    'AppFirewallPolicyActionBodyArgsDict',
    'AppFirewallPolicyActionHeaderArgs',
    'AppFirewallPolicyActionHeaderArgsDict',
    'AppFirewallPolicyRequestAccessControlArgs',
    'AppFirewallPolicyRequestAccessControlArgsDict',
    'AppFirewallPolicyRequestAccessControlRuleArgs',
    'AppFirewallPolicyRequestAccessControlRuleArgsDict',
    'AppFirewallPolicyRequestProtectionArgs',
    'AppFirewallPolicyRequestProtectionArgsDict',
    'AppFirewallPolicyRequestProtectionRuleArgs',
    'AppFirewallPolicyRequestProtectionRuleArgsDict',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgsDict',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgsDict',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgsDict',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgsDict',
    'AppFirewallPolicyRequestRateLimitingArgs',
    'AppFirewallPolicyRequestRateLimitingArgsDict',
    'AppFirewallPolicyRequestRateLimitingRuleArgs',
    'AppFirewallPolicyRequestRateLimitingRuleArgsDict',
    'AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs',
    'AppFirewallPolicyRequestRateLimitingRuleConfigurationArgsDict',
    'AppFirewallPolicyResponseAccessControlArgs',
    'AppFirewallPolicyResponseAccessControlArgsDict',
    'AppFirewallPolicyResponseAccessControlRuleArgs',
    'AppFirewallPolicyResponseAccessControlRuleArgsDict',
    'AppFirewallPolicyResponseProtectionArgs',
    'AppFirewallPolicyResponseProtectionArgsDict',
    'AppFirewallPolicyResponseProtectionRuleArgs',
    'AppFirewallPolicyResponseProtectionRuleArgsDict',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgsDict',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgsDict',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgsDict',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgsDict',
    'NetworkAddressListVcnAddressArgs',
    'NetworkAddressListVcnAddressArgsDict',
    'GetFirewallsFilterArgs',
    'GetFirewallsFilterArgsDict',
    'GetNetworkAddressListsFilterArgs',
    'GetNetworkAddressListsFilterArgsDict',
    'GetProtectionCapabilitiesFilterArgs',
    'GetProtectionCapabilitiesFilterArgsDict',
    'GetProtectionCapabilityGroupTagsFilterArgs',
    'GetProtectionCapabilityGroupTagsFilterArgsDict',
    'GetWebAppFirewallPoliciesFilterArgs',
    'GetWebAppFirewallPoliciesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AppFirewallPolicyActionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Action name. Can be used to reference the action.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) 
        * **CHECK** is a non-terminating action that does not stop the execution of rules in current module, just emits a log message documenting result of rule execution.
        * **ALLOW** is a non-terminating action which upon matching rule skips all remaining rules in the current module.
        * **RETURN_HTTP_RESPONSE** is a terminating action which is executed immediately, returns a defined HTTP response.
        """
        body: NotRequired[pulumi.Input['AppFirewallPolicyActionBodyArgsDict']]
        """
        (Updatable) Type of returned HTTP response body.
        """
        code: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Response code.

        The following response codes are valid values for this property:
        * 2xx

        200 OK 201 Created 202 Accepted 206 Partial Content
        * 3xx

        300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 307 Temporary Redirect
        * 4xx

        400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 405 Method Not Allowed 408 Request Timeout 409 Conflict 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 422 Unprocessable Entity 494 Request Header Too Large 495 Cert Error 496 No Cert 497 HTTP to HTTPS
        * 5xx

        500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 507 Insufficient Storage

        Example: `200`
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyActionHeaderArgsDict']]]]
        """
        (Updatable) Adds headers defined in this array for HTTP response.

        Hop-by-hop headers are not allowed to be set:
        * Connection
        * Keep-Alive
        * Proxy-Authenticate
        * Proxy-Authorization
        * TE
        * Trailer
        * Transfer-Encoding
        * Upgrade
        """
elif False:
    AppFirewallPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 body: Optional[pulumi.Input['AppFirewallPolicyActionBodyArgs']] = None,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyActionHeaderArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) Action name. Can be used to reference the action.
        :param pulumi.Input[_builtins.str] type: (Updatable) 
               * **CHECK** is a non-terminating action that does not stop the execution of rules in current module, just emits a log message documenting result of rule execution.
               * **ALLOW** is a non-terminating action which upon matching rule skips all remaining rules in the current module.
               * **RETURN_HTTP_RESPONSE** is a terminating action which is executed immediately, returns a defined HTTP response.
        :param pulumi.Input['AppFirewallPolicyActionBodyArgs'] body: (Updatable) Type of returned HTTP response body.
        :param pulumi.Input[_builtins.int] code: (Updatable) Response code.
               
               The following response codes are valid values for this property:
               * 2xx
               
               200 OK 201 Created 202 Accepted 206 Partial Content
               * 3xx
               
               300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 307 Temporary Redirect
               * 4xx
               
               400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 405 Method Not Allowed 408 Request Timeout 409 Conflict 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 422 Unprocessable Entity 494 Request Header Too Large 495 Cert Error 496 No Cert 497 HTTP to HTTPS
               * 5xx
               
               500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 507 Insufficient Storage
               
               Example: `200`
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyActionHeaderArgs']]] headers: (Updatable) Adds headers defined in this array for HTTP response.
               
               Hop-by-hop headers are not allowed to be set:
               * Connection
               * Keep-Alive
               * Proxy-Authenticate
               * Proxy-Authorization
               * TE
               * Trailer
               * Transfer-Encoding
               * Upgrade
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Action name. Can be used to reference the action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) 
        * **CHECK** is a non-terminating action that does not stop the execution of rules in current module, just emits a log message documenting result of rule execution.
        * **ALLOW** is a non-terminating action which upon matching rule skips all remaining rules in the current module.
        * **RETURN_HTTP_RESPONSE** is a terminating action which is executed immediately, returns a defined HTTP response.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['AppFirewallPolicyActionBodyArgs']]:
        """
        (Updatable) Type of returned HTTP response body.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['AppFirewallPolicyActionBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Response code.

        The following response codes are valid values for this property:
        * 2xx

        200 OK 201 Created 202 Accepted 206 Partial Content
        * 3xx

        300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 307 Temporary Redirect
        * 4xx

        400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 405 Method Not Allowed 408 Request Timeout 409 Conflict 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 422 Unprocessable Entity 494 Request Header Too Large 495 Cert Error 496 No Cert 497 HTTP to HTTPS
        * 5xx

        500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 507 Insufficient Storage

        Example: `200`
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyActionHeaderArgs']]]]:
        """
        (Updatable) Adds headers defined in this array for HTTP response.

        Hop-by-hop headers are not allowed to be set:
        * Connection
        * Keep-Alive
        * Proxy-Authenticate
        * Proxy-Authorization
        * TE
        * Trailer
        * Transfer-Encoding
        * Upgrade
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class AppFirewallPolicyActionBodyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of HttpResponseBody.
        """
        template: NotRequired[pulumi.Input[_builtins.str]]
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Static response body text.
        """
elif False:
    AppFirewallPolicyActionBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyActionBodyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 template: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of HttpResponseBody.
        :param pulumi.Input[_builtins.str] text: (Updatable) Static response body text.
        """
        pulumi.set(__self__, "type", type)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of HttpResponseBody.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Static response body text.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AppFirewallPolicyActionHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the header field.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The value of the header field.
        """
elif False:
    AppFirewallPolicyActionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyActionHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the header field.
        :param pulumi.Input[_builtins.str] value: (Updatable) The value of the header field.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the header field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The value of the header field.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppFirewallPolicyRequestAccessControlArgsDict(TypedDict):
        default_action_name: pulumi.Input[_builtins.str]
        """
        (Updatable) References an default Action to take if no AccessControlRule was matched. Allowed action types:
        * **ALLOW** continues execution of other modules and their rules.
        * **RETURN_HTTP_RESPONSE** terminates further execution of modules and rules and returns defined HTTP response.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestAccessControlRuleArgsDict']]]]
        """
        (Updatable) Ordered list of AccessControlRules. Rules are executed in order of appearance in this array.
        """
elif False:
    AppFirewallPolicyRequestAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyRequestAccessControlArgs:
    def __init__(__self__, *,
                 default_action_name: pulumi.Input[_builtins.str],
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestAccessControlRuleArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] default_action_name: (Updatable) References an default Action to take if no AccessControlRule was matched. Allowed action types:
               * **ALLOW** continues execution of other modules and their rules.
               * **RETURN_HTTP_RESPONSE** terminates further execution of modules and rules and returns defined HTTP response.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestAccessControlRuleArgs']]] rules: (Updatable) Ordered list of AccessControlRules. Rules are executed in order of appearance in this array.
        """
        pulumi.set(__self__, "default_action_name", default_action_name)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="defaultActionName")
    def default_action_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) References an default Action to take if no AccessControlRule was matched. Allowed action types:
        * **ALLOW** continues execution of other modules and their rules.
        * **RETURN_HTTP_RESPONSE** terminates further execution of modules and rules and returns defined HTTP response.
        """
        return pulumi.get(self, "default_action_name")

    @default_action_name.setter
    def default_action_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_action_name", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestAccessControlRuleArgs']]]]:
        """
        (Updatable) Ordered list of AccessControlRules. Rules are executed in order of appearance in this array.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestAccessControlRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AppFirewallPolicyRequestAccessControlRuleArgsDict(TypedDict):
        action_name: pulumi.Input[_builtins.str]
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        """
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        condition_language: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
elif False:
    AppFirewallPolicyRequestAccessControlRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyRequestAccessControlRuleArgs:
    def __init__(__self__, *,
                 action_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 condition_language: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action_name: (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        :param pulumi.Input[_builtins.str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        :param pulumi.Input[_builtins.str] condition: (Updatable) An expression that determines whether or not the rule action should be executed.
        :param pulumi.Input[_builtins.str] condition_language: (Updatable) The language used to parse condition from field `condition`. Available languages:
               * **JMESPATH** an extended JMESPath language syntax.
        """
        pulumi.set(__self__, "action_name", action_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if condition_language is not None:
            pulumi.set(__self__, "condition_language", condition_language)

    @_builtins.property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="conditionLanguage")
    def condition_language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        return pulumi.get(self, "condition_language")

    @condition_language.setter
    def condition_language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition_language", value)


if not MYPY:
    class AppFirewallPolicyRequestProtectionArgsDict(TypedDict):
        body_inspection_size_limit_exceeded_action_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy. Executed if HTTP message body size exceeds limit set in field `bodyInspectionSizeLimitInBytes`.

        If this field is `null` HTTP message body will inspected up to `bodyInspectionSizeLimitInBytes` and the rest will not be inspected by Protection Capabilities.

        Allowed action types:
        * **RETURN_HTTP_RESPONSE** terminates further execution of modules and rules and returns defined HTTP response.
        """
        body_inspection_size_limit_in_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Maximum size of inspected HTTP message body in bytes. Actions to take if this limit is exceeded are defined in `bodyInspectionSizeLimitExceededActionName`.

        Body inspection maximum size allowed is defined with per-tenancy limit: 8192 bytes.

        For steps to request a limit increase, see [Requesting a Service Limit Increase](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/servicelimits.htm).
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleArgsDict']]]]
        """
        (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection Capabilities of REQUEST_PROTECTION_CAPABILITY type.
        """
elif False:
    AppFirewallPolicyRequestProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyRequestProtectionArgs:
    def __init__(__self__, *,
                 body_inspection_size_limit_exceeded_action_name: Optional[pulumi.Input[_builtins.str]] = None,
                 body_inspection_size_limit_in_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] body_inspection_size_limit_exceeded_action_name: (Updatable) References action by name from actions defined in WebAppFirewallPolicy. Executed if HTTP message body size exceeds limit set in field `bodyInspectionSizeLimitInBytes`.
               
               If this field is `null` HTTP message body will inspected up to `bodyInspectionSizeLimitInBytes` and the rest will not be inspected by Protection Capabilities.
               
               Allowed action types:
               * **RETURN_HTTP_RESPONSE** terminates further execution of modules and rules and returns defined HTTP response.
        :param pulumi.Input[_builtins.int] body_inspection_size_limit_in_bytes: (Updatable) Maximum size of inspected HTTP message body in bytes. Actions to take if this limit is exceeded are defined in `bodyInspectionSizeLimitExceededActionName`.
               
               Body inspection maximum size allowed is defined with per-tenancy limit: 8192 bytes.
               
               For steps to request a limit increase, see [Requesting a Service Limit Increase](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/servicelimits.htm).
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleArgs']]] rules: (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection Capabilities of REQUEST_PROTECTION_CAPABILITY type.
        """
        if body_inspection_size_limit_exceeded_action_name is not None:
            pulumi.set(__self__, "body_inspection_size_limit_exceeded_action_name", body_inspection_size_limit_exceeded_action_name)
        if body_inspection_size_limit_in_bytes is not None:
            pulumi.set(__self__, "body_inspection_size_limit_in_bytes", body_inspection_size_limit_in_bytes)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="bodyInspectionSizeLimitExceededActionName")
    def body_inspection_size_limit_exceeded_action_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy. Executed if HTTP message body size exceeds limit set in field `bodyInspectionSizeLimitInBytes`.

        If this field is `null` HTTP message body will inspected up to `bodyInspectionSizeLimitInBytes` and the rest will not be inspected by Protection Capabilities.

        Allowed action types:
        * **RETURN_HTTP_RESPONSE** terminates further execution of modules and rules and returns defined HTTP response.
        """
        return pulumi.get(self, "body_inspection_size_limit_exceeded_action_name")

    @body_inspection_size_limit_exceeded_action_name.setter
    def body_inspection_size_limit_exceeded_action_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body_inspection_size_limit_exceeded_action_name", value)

    @_builtins.property
    @pulumi.getter(name="bodyInspectionSizeLimitInBytes")
    def body_inspection_size_limit_in_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Maximum size of inspected HTTP message body in bytes. Actions to take if this limit is exceeded are defined in `bodyInspectionSizeLimitExceededActionName`.

        Body inspection maximum size allowed is defined with per-tenancy limit: 8192 bytes.

        For steps to request a limit increase, see [Requesting a Service Limit Increase](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/servicelimits.htm).
        """
        return pulumi.get(self, "body_inspection_size_limit_in_bytes")

    @body_inspection_size_limit_in_bytes.setter
    def body_inspection_size_limit_in_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "body_inspection_size_limit_in_bytes", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleArgs']]]]:
        """
        (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection Capabilities of REQUEST_PROTECTION_CAPABILITY type.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AppFirewallPolicyRequestProtectionRuleArgsDict(TypedDict):
        action_name: pulumi.Input[_builtins.str]
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        """
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        protection_capabilities: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgsDict']]]
        """
        (Updatable) An ordered list that references OCI-managed protection capabilities. Referenced protection capabilities are not necessarily executed in order of appearance. Their execution order is decided at runtime for improved performance. The array cannot contain entries with the same pair of capability key and version more than once.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        condition_language: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        is_body_inspection_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables/disables body inspection for this protection rule. Only Protection Rules in RequestProtection can have this option enabled. Response body inspection will be available at a later date.
        """
        protection_capability_settings: NotRequired[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgsDict']]
        """
        (Updatable) Settings for protection capabilities
        """
elif False:
    AppFirewallPolicyRequestProtectionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyRequestProtectionRuleArgs:
    def __init__(__self__, *,
                 action_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 protection_capabilities: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs']]],
                 type: pulumi.Input[_builtins.str],
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 condition_language: Optional[pulumi.Input[_builtins.str]] = None,
                 is_body_inspection_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 protection_capability_settings: Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action_name: (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        :param pulumi.Input[_builtins.str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs']]] protection_capabilities: (Updatable) An ordered list that references OCI-managed protection capabilities. Referenced protection capabilities are not necessarily executed in order of appearance. Their execution order is decided at runtime for improved performance. The array cannot contain entries with the same pair of capability key and version more than once.
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        :param pulumi.Input[_builtins.str] condition: (Updatable) An expression that determines whether or not the rule action should be executed.
        :param pulumi.Input[_builtins.str] condition_language: (Updatable) The language used to parse condition from field `condition`. Available languages:
               * **JMESPATH** an extended JMESPath language syntax.
        :param pulumi.Input[_builtins.bool] is_body_inspection_enabled: (Updatable) Enables/disables body inspection for this protection rule. Only Protection Rules in RequestProtection can have this option enabled. Response body inspection will be available at a later date.
        :param pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs'] protection_capability_settings: (Updatable) Settings for protection capabilities
        """
        pulumi.set(__self__, "action_name", action_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protection_capabilities", protection_capabilities)
        pulumi.set(__self__, "type", type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if condition_language is not None:
            pulumi.set(__self__, "condition_language", condition_language)
        if is_body_inspection_enabled is not None:
            pulumi.set(__self__, "is_body_inspection_enabled", is_body_inspection_enabled)
        if protection_capability_settings is not None:
            pulumi.set(__self__, "protection_capability_settings", protection_capability_settings)

    @_builtins.property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="protectionCapabilities")
    def protection_capabilities(self) -> pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs']]]:
        """
        (Updatable) An ordered list that references OCI-managed protection capabilities. Referenced protection capabilities are not necessarily executed in order of appearance. Their execution order is decided at runtime for improved performance. The array cannot contain entries with the same pair of capability key and version more than once.
        """
        return pulumi.get(self, "protection_capabilities")

    @protection_capabilities.setter
    def protection_capabilities(self, value: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs']]]):
        pulumi.set(self, "protection_capabilities", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="conditionLanguage")
    def condition_language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        return pulumi.get(self, "condition_language")

    @condition_language.setter
    def condition_language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition_language", value)

    @_builtins.property
    @pulumi.getter(name="isBodyInspectionEnabled")
    def is_body_inspection_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables/disables body inspection for this protection rule. Only Protection Rules in RequestProtection can have this option enabled. Response body inspection will be available at a later date.
        """
        return pulumi.get(self, "is_body_inspection_enabled")

    @is_body_inspection_enabled.setter
    def is_body_inspection_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_body_inspection_enabled", value)

    @_builtins.property
    @pulumi.getter(name="protectionCapabilitySettings")
    def protection_capability_settings(self) -> Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs']]:
        """
        (Updatable) Settings for protection capabilities
        """
        return pulumi.get(self, "protection_capability_settings")

    @protection_capability_settings.setter
    def protection_capability_settings(self, value: Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs']]):
        pulumi.set(self, "protection_capability_settings", value)


if not MYPY:
    class AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        (Updatable) Unique key of referenced protection capability.
        """
        version: pulumi.Input[_builtins.int]
        """
        (Updatable) Version of referenced protection capability.
        """
        action_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        """
        collaborative_action_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The minimum sum of weights of associated collaborative protection capabilities that have triggered which must be reached in order for _this_ capability to trigger. This field is ignored for non-collaborative capabilities.
        """
        collaborative_weights: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgsDict']]]]
        """
        (Updatable) Explicit weight values to use for associated collaborative protection capabilities.
        """
        exclusions: NotRequired[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgsDict']]
        """
        (Updatable) Identifies specific HTTP message parameters to exclude from inspection by a protection capability.
        """
elif False:
    AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.int],
                 action_name: Optional[pulumi.Input[_builtins.str]] = None,
                 collaborative_action_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 collaborative_weights: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]] = None,
                 exclusions: Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] key: (Updatable) Unique key of referenced protection capability.
        :param pulumi.Input[_builtins.int] version: (Updatable) Version of referenced protection capability.
        :param pulumi.Input[_builtins.str] action_name: (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        :param pulumi.Input[_builtins.int] collaborative_action_threshold: (Updatable) The minimum sum of weights of associated collaborative protection capabilities that have triggered which must be reached in order for _this_ capability to trigger. This field is ignored for non-collaborative capabilities.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]] collaborative_weights: (Updatable) Explicit weight values to use for associated collaborative protection capabilities.
        :param pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs'] exclusions: (Updatable) Identifies specific HTTP message parameters to exclude from inspection by a protection capability.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "version", version)
        if action_name is not None:
            pulumi.set(__self__, "action_name", action_name)
        if collaborative_action_threshold is not None:
            pulumi.set(__self__, "collaborative_action_threshold", collaborative_action_threshold)
        if collaborative_weights is not None:
            pulumi.set(__self__, "collaborative_weights", collaborative_weights)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Unique key of referenced protection capability.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Version of referenced protection capability.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="actionName")
    def action_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_name", value)

    @_builtins.property
    @pulumi.getter(name="collaborativeActionThreshold")
    def collaborative_action_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The minimum sum of weights of associated collaborative protection capabilities that have triggered which must be reached in order for _this_ capability to trigger. This field is ignored for non-collaborative capabilities.
        """
        return pulumi.get(self, "collaborative_action_threshold")

    @collaborative_action_threshold.setter
    def collaborative_action_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "collaborative_action_threshold", value)

    @_builtins.property
    @pulumi.getter(name="collaborativeWeights")
    def collaborative_weights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]]:
        """
        (Updatable) Explicit weight values to use for associated collaborative protection capabilities.
        """
        return pulumi.get(self, "collaborative_weights")

    @collaborative_weights.setter
    def collaborative_weights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]]):
        pulumi.set(self, "collaborative_weights", value)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs']]:
        """
        (Updatable) Identifies specific HTTP message parameters to exclude from inspection by a protection capability.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs']]):
        pulumi.set(self, "exclusions", value)


if not MYPY:
    class AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        (Updatable) Unique key of collaborative capability for which weight will be overridden.
        """
        weight: pulumi.Input[_builtins.int]
        """
        (Updatable) The value of weight to set.
        """
elif False:
    AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 weight: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] key: (Updatable) Unique key of collaborative capability for which weight will be overridden.
        :param pulumi.Input[_builtins.int] weight: (Updatable) The value of weight to set.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Unique key of collaborative capability for which weight will be overridden.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The value of weight to set.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgsDict(TypedDict):
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of URL query parameter values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from inspecting. Example: If we have query parameter 'argumentName=argumentValue' and args=['argumentName'], both 'argumentName' and 'argumentValue' will not be inspected.
        """
        request_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of HTTP request cookie values (by cookie name) to exclude from inspecting. Example: If we have cookie 'cookieName=cookieValue' and requestCookies=['cookieName'], both 'cookieName' and 'cookieValue' will not be inspected.
        """
elif False:
    AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 request_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] args: (Updatable) List of URL query parameter values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from inspecting. Example: If we have query parameter 'argumentName=argumentValue' and args=['argumentName'], both 'argumentName' and 'argumentValue' will not be inspected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] request_cookies: (Updatable) List of HTTP request cookie values (by cookie name) to exclude from inspecting. Example: If we have cookie 'cookieName=cookieValue' and requestCookies=['cookieName'], both 'cookieName' and 'cookieValue' will not be inspected.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if request_cookies is not None:
            pulumi.set(__self__, "request_cookies", request_cookies)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of URL query parameter values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from inspecting. Example: If we have query parameter 'argumentName=argumentValue' and args=['argumentName'], both 'argumentName' and 'argumentValue' will not be inspected.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter(name="requestCookies")
    def request_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of HTTP request cookie values (by cookie name) to exclude from inspecting. Example: If we have cookie 'cookieName=cookieValue' and requestCookies=['cookieName'], both 'cookieName' and 'cookieValue' will not be inspected.
        """
        return pulumi.get(self, "request_cookies")

    @request_cookies.setter
    def request_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "request_cookies", value)


if not MYPY:
    class AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgsDict(TypedDict):
        allowed_http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of allowed HTTP methods. Each value as a RFC7230 formated token string. Used in protection capability 911100: Restrict HTTP Request Methods.
        """
        max_http_request_header_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Maximum allowed length of headers in an HTTP request. Used in protection capability: 9200024: Limit length of request header size.
        """
        max_http_request_headers: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Maximum number of headers allowed in an HTTP request. Used in protection capability 9200014: Limit Number of Request Headers.
        """
        max_number_of_arguments: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Maximum number of arguments allowed. Used in protection capability 920380: Number of Arguments Limits.
        """
        max_single_argument_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Maximum allowed length of a single argument. Used in protection capability 920370: Limit argument value length.
        """
        max_total_argument_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Maximum allowed total length of all arguments. Used in protection capability 920390: Limit arguments total length.
        """
elif False:
    AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs:
    def __init__(__self__, *,
                 allowed_http_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_http_request_header_length: Optional[pulumi.Input[_builtins.int]] = None,
                 max_http_request_headers: Optional[pulumi.Input[_builtins.int]] = None,
                 max_number_of_arguments: Optional[pulumi.Input[_builtins.int]] = None,
                 max_single_argument_length: Optional[pulumi.Input[_builtins.int]] = None,
                 max_total_argument_length: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_http_methods: (Updatable) List of allowed HTTP methods. Each value as a RFC7230 formated token string. Used in protection capability 911100: Restrict HTTP Request Methods.
        :param pulumi.Input[_builtins.int] max_http_request_header_length: (Updatable) Maximum allowed length of headers in an HTTP request. Used in protection capability: 9200024: Limit length of request header size.
        :param pulumi.Input[_builtins.int] max_http_request_headers: (Updatable) Maximum number of headers allowed in an HTTP request. Used in protection capability 9200014: Limit Number of Request Headers.
        :param pulumi.Input[_builtins.int] max_number_of_arguments: (Updatable) Maximum number of arguments allowed. Used in protection capability 920380: Number of Arguments Limits.
        :param pulumi.Input[_builtins.int] max_single_argument_length: (Updatable) Maximum allowed length of a single argument. Used in protection capability 920370: Limit argument value length.
        :param pulumi.Input[_builtins.int] max_total_argument_length: (Updatable) Maximum allowed total length of all arguments. Used in protection capability 920390: Limit arguments total length.
        """
        if allowed_http_methods is not None:
            pulumi.set(__self__, "allowed_http_methods", allowed_http_methods)
        if max_http_request_header_length is not None:
            pulumi.set(__self__, "max_http_request_header_length", max_http_request_header_length)
        if max_http_request_headers is not None:
            pulumi.set(__self__, "max_http_request_headers", max_http_request_headers)
        if max_number_of_arguments is not None:
            pulumi.set(__self__, "max_number_of_arguments", max_number_of_arguments)
        if max_single_argument_length is not None:
            pulumi.set(__self__, "max_single_argument_length", max_single_argument_length)
        if max_total_argument_length is not None:
            pulumi.set(__self__, "max_total_argument_length", max_total_argument_length)

    @_builtins.property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of allowed HTTP methods. Each value as a RFC7230 formated token string. Used in protection capability 911100: Restrict HTTP Request Methods.
        """
        return pulumi.get(self, "allowed_http_methods")

    @allowed_http_methods.setter
    def allowed_http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_http_methods", value)

    @_builtins.property
    @pulumi.getter(name="maxHttpRequestHeaderLength")
    def max_http_request_header_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Maximum allowed length of headers in an HTTP request. Used in protection capability: 9200024: Limit length of request header size.
        """
        return pulumi.get(self, "max_http_request_header_length")

    @max_http_request_header_length.setter
    def max_http_request_header_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_http_request_header_length", value)

    @_builtins.property
    @pulumi.getter(name="maxHttpRequestHeaders")
    def max_http_request_headers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Maximum number of headers allowed in an HTTP request. Used in protection capability 9200014: Limit Number of Request Headers.
        """
        return pulumi.get(self, "max_http_request_headers")

    @max_http_request_headers.setter
    def max_http_request_headers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_http_request_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxNumberOfArguments")
    def max_number_of_arguments(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Maximum number of arguments allowed. Used in protection capability 920380: Number of Arguments Limits.
        """
        return pulumi.get(self, "max_number_of_arguments")

    @max_number_of_arguments.setter
    def max_number_of_arguments(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_number_of_arguments", value)

    @_builtins.property
    @pulumi.getter(name="maxSingleArgumentLength")
    def max_single_argument_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Maximum allowed length of a single argument. Used in protection capability 920370: Limit argument value length.
        """
        return pulumi.get(self, "max_single_argument_length")

    @max_single_argument_length.setter
    def max_single_argument_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_single_argument_length", value)

    @_builtins.property
    @pulumi.getter(name="maxTotalArgumentLength")
    def max_total_argument_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Maximum allowed total length of all arguments. Used in protection capability 920390: Limit arguments total length.
        """
        return pulumi.get(self, "max_total_argument_length")

    @max_total_argument_length.setter
    def max_total_argument_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_total_argument_length", value)


if not MYPY:
    class AppFirewallPolicyRequestRateLimitingArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleArgsDict']]]]
        """
        (Updatable) Ordered list of RequestRateLimitingRules. Rules are executed in order of appearance in this array.
        """
elif False:
    AppFirewallPolicyRequestRateLimitingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyRequestRateLimitingArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleArgs']]] rules: (Updatable) Ordered list of RequestRateLimitingRules. Rules are executed in order of appearance in this array.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleArgs']]]]:
        """
        (Updatable) Ordered list of RequestRateLimitingRules. Rules are executed in order of appearance in this array.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AppFirewallPolicyRequestRateLimitingRuleArgsDict(TypedDict):
        action_name: pulumi.Input[_builtins.str]
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        """
        configurations: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleConfigurationArgsDict']]]
        """
        (Updatable) Rate Limiting Configurations. Each configuration counts requests towards its own `requestsLimit`.
        """
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        condition_language: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
elif False:
    AppFirewallPolicyRequestRateLimitingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyRequestRateLimitingRuleArgs:
    def __init__(__self__, *,
                 action_name: pulumi.Input[_builtins.str],
                 configurations: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs']]],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 condition_language: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action_name: (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs']]] configurations: (Updatable) Rate Limiting Configurations. Each configuration counts requests towards its own `requestsLimit`.
        :param pulumi.Input[_builtins.str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        :param pulumi.Input[_builtins.str] condition: (Updatable) An expression that determines whether or not the rule action should be executed.
        :param pulumi.Input[_builtins.str] condition_language: (Updatable) The language used to parse condition from field `condition`. Available languages:
               * **JMESPATH** an extended JMESPath language syntax.
        """
        pulumi.set(__self__, "action_name", action_name)
        pulumi.set(__self__, "configurations", configurations)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if condition_language is not None:
            pulumi.set(__self__, "condition_language", condition_language)

    @_builtins.property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_name", value)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs']]]:
        """
        (Updatable) Rate Limiting Configurations. Each configuration counts requests towards its own `requestsLimit`.
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs']]]):
        pulumi.set(self, "configurations", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="conditionLanguage")
    def condition_language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        return pulumi.get(self, "condition_language")

    @condition_language.setter
    def condition_language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition_language", value)


if not MYPY:
    class AppFirewallPolicyRequestRateLimitingRuleConfigurationArgsDict(TypedDict):
        period_in_seconds: pulumi.Input[_builtins.int]
        """
        (Updatable) Evaluation period in seconds.
        """
        requests_limit: pulumi.Input[_builtins.int]
        """
        (Updatable) Requests allowed per evaluation period.
        """
        action_duration_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Duration of block action application in seconds when `requestsLimit` is reached. Optional and can be 0 (no block duration).
        """
elif False:
    AppFirewallPolicyRequestRateLimitingRuleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs:
    def __init__(__self__, *,
                 period_in_seconds: pulumi.Input[_builtins.int],
                 requests_limit: pulumi.Input[_builtins.int],
                 action_duration_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] period_in_seconds: (Updatable) Evaluation period in seconds.
        :param pulumi.Input[_builtins.int] requests_limit: (Updatable) Requests allowed per evaluation period.
        :param pulumi.Input[_builtins.int] action_duration_in_seconds: (Updatable) Duration of block action application in seconds when `requestsLimit` is reached. Optional and can be 0 (no block duration).
        """
        pulumi.set(__self__, "period_in_seconds", period_in_seconds)
        pulumi.set(__self__, "requests_limit", requests_limit)
        if action_duration_in_seconds is not None:
            pulumi.set(__self__, "action_duration_in_seconds", action_duration_in_seconds)

    @_builtins.property
    @pulumi.getter(name="periodInSeconds")
    def period_in_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Evaluation period in seconds.
        """
        return pulumi.get(self, "period_in_seconds")

    @period_in_seconds.setter
    def period_in_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="requestsLimit")
    def requests_limit(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Requests allowed per evaluation period.
        """
        return pulumi.get(self, "requests_limit")

    @requests_limit.setter
    def requests_limit(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "requests_limit", value)

    @_builtins.property
    @pulumi.getter(name="actionDurationInSeconds")
    def action_duration_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Duration of block action application in seconds when `requestsLimit` is reached. Optional and can be 0 (no block duration).
        """
        return pulumi.get(self, "action_duration_in_seconds")

    @action_duration_in_seconds.setter
    def action_duration_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "action_duration_in_seconds", value)


if not MYPY:
    class AppFirewallPolicyResponseAccessControlArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseAccessControlRuleArgsDict']]]]
        """
        (Updatable) Ordered list of AccessControlRules. Rules are executed in order of appearance in this array.
        """
elif False:
    AppFirewallPolicyResponseAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyResponseAccessControlArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseAccessControlRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseAccessControlRuleArgs']]] rules: (Updatable) Ordered list of AccessControlRules. Rules are executed in order of appearance in this array.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseAccessControlRuleArgs']]]]:
        """
        (Updatable) Ordered list of AccessControlRules. Rules are executed in order of appearance in this array.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseAccessControlRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AppFirewallPolicyResponseAccessControlRuleArgsDict(TypedDict):
        action_name: pulumi.Input[_builtins.str]
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        """
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        condition_language: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
elif False:
    AppFirewallPolicyResponseAccessControlRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyResponseAccessControlRuleArgs:
    def __init__(__self__, *,
                 action_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 condition_language: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action_name: (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        :param pulumi.Input[_builtins.str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        :param pulumi.Input[_builtins.str] condition: (Updatable) An expression that determines whether or not the rule action should be executed.
        :param pulumi.Input[_builtins.str] condition_language: (Updatable) The language used to parse condition from field `condition`. Available languages:
               * **JMESPATH** an extended JMESPath language syntax.
        """
        pulumi.set(__self__, "action_name", action_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if condition_language is not None:
            pulumi.set(__self__, "condition_language", condition_language)

    @_builtins.property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="conditionLanguage")
    def condition_language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        return pulumi.get(self, "condition_language")

    @condition_language.setter
    def condition_language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition_language", value)


if not MYPY:
    class AppFirewallPolicyResponseProtectionArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleArgsDict']]]]
        """
        (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
elif False:
    AppFirewallPolicyResponseProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyResponseProtectionArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleArgs']]] rules: (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleArgs']]]]:
        """
        (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AppFirewallPolicyResponseProtectionRuleArgsDict(TypedDict):
        action_name: pulumi.Input[_builtins.str]
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        """
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        protection_capabilities: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgsDict']]]
        """
        (Updatable) An ordered list that references OCI-managed protection capabilities. Referenced protection capabilities are not necessarily executed in order of appearance. Their execution order is decided at runtime for improved performance. The array cannot contain entries with the same pair of capability key and version more than once.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        condition_language: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        is_body_inspection_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables/disables body inspection for this protection rule. Only Protection Rules in RequestProtection can have this option enabled. Response body inspection will be available at a later date.
        """
        protection_capability_settings: NotRequired[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgsDict']]
        """
        (Updatable) Settings for protection capabilities
        """
elif False:
    AppFirewallPolicyResponseProtectionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyResponseProtectionRuleArgs:
    def __init__(__self__, *,
                 action_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 protection_capabilities: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs']]],
                 type: pulumi.Input[_builtins.str],
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 condition_language: Optional[pulumi.Input[_builtins.str]] = None,
                 is_body_inspection_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 protection_capability_settings: Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action_name: (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        :param pulumi.Input[_builtins.str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs']]] protection_capabilities: (Updatable) An ordered list that references OCI-managed protection capabilities. Referenced protection capabilities are not necessarily executed in order of appearance. Their execution order is decided at runtime for improved performance. The array cannot contain entries with the same pair of capability key and version more than once.
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        :param pulumi.Input[_builtins.str] condition: (Updatable) An expression that determines whether or not the rule action should be executed.
        :param pulumi.Input[_builtins.str] condition_language: (Updatable) The language used to parse condition from field `condition`. Available languages:
               * **JMESPATH** an extended JMESPath language syntax.
        :param pulumi.Input[_builtins.bool] is_body_inspection_enabled: (Updatable) Enables/disables body inspection for this protection rule. Only Protection Rules in RequestProtection can have this option enabled. Response body inspection will be available at a later date.
        :param pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs'] protection_capability_settings: (Updatable) Settings for protection capabilities
        """
        pulumi.set(__self__, "action_name", action_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protection_capabilities", protection_capabilities)
        pulumi.set(__self__, "type", type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if condition_language is not None:
            pulumi.set(__self__, "condition_language", condition_language)
        if is_body_inspection_enabled is not None:
            pulumi.set(__self__, "is_body_inspection_enabled", is_body_inspection_enabled)
        if protection_capability_settings is not None:
            pulumi.set(__self__, "protection_capability_settings", protection_capability_settings)

    @_builtins.property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="protectionCapabilities")
    def protection_capabilities(self) -> pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs']]]:
        """
        (Updatable) An ordered list that references OCI-managed protection capabilities. Referenced protection capabilities are not necessarily executed in order of appearance. Their execution order is decided at runtime for improved performance. The array cannot contain entries with the same pair of capability key and version more than once.
        """
        return pulumi.get(self, "protection_capabilities")

    @protection_capabilities.setter
    def protection_capabilities(self, value: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs']]]):
        pulumi.set(self, "protection_capabilities", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="conditionLanguage")
    def condition_language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        return pulumi.get(self, "condition_language")

    @condition_language.setter
    def condition_language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition_language", value)

    @_builtins.property
    @pulumi.getter(name="isBodyInspectionEnabled")
    def is_body_inspection_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables/disables body inspection for this protection rule. Only Protection Rules in RequestProtection can have this option enabled. Response body inspection will be available at a later date.
        """
        return pulumi.get(self, "is_body_inspection_enabled")

    @is_body_inspection_enabled.setter
    def is_body_inspection_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_body_inspection_enabled", value)

    @_builtins.property
    @pulumi.getter(name="protectionCapabilitySettings")
    def protection_capability_settings(self) -> Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs']]:
        """
        (Updatable) Settings for protection capabilities
        """
        return pulumi.get(self, "protection_capability_settings")

    @protection_capability_settings.setter
    def protection_capability_settings(self, value: Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs']]):
        pulumi.set(self, "protection_capability_settings", value)


if not MYPY:
    class AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        (Updatable) Unique key of referenced protection capability.
        """
        version: pulumi.Input[_builtins.int]
        """
        (Updatable) Version of referenced protection capability.
        """
        action_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        """
        collaborative_action_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The minimum sum of weights of associated collaborative protection capabilities that have triggered which must be reached in order for _this_ capability to trigger. This field is ignored for non-collaborative capabilities.
        """
        collaborative_weights: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgsDict']]]]
        """
        (Updatable) Explicit weight values to use for associated collaborative protection capabilities.
        """
        exclusions: NotRequired[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgsDict']]
        """
        (Updatable) Identifies specific HTTP message parameters to exclude from inspection by a protection capability.
        """
elif False:
    AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.int],
                 action_name: Optional[pulumi.Input[_builtins.str]] = None,
                 collaborative_action_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 collaborative_weights: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]] = None,
                 exclusions: Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] key: (Updatable) Unique key of referenced protection capability.
        :param pulumi.Input[_builtins.int] version: (Updatable) Version of referenced protection capability.
        :param pulumi.Input[_builtins.str] action_name: (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        :param pulumi.Input[_builtins.int] collaborative_action_threshold: (Updatable) The minimum sum of weights of associated collaborative protection capabilities that have triggered which must be reached in order for _this_ capability to trigger. This field is ignored for non-collaborative capabilities.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]] collaborative_weights: (Updatable) Explicit weight values to use for associated collaborative protection capabilities.
        :param pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs'] exclusions: (Updatable) Identifies specific HTTP message parameters to exclude from inspection by a protection capability.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "version", version)
        if action_name is not None:
            pulumi.set(__self__, "action_name", action_name)
        if collaborative_action_threshold is not None:
            pulumi.set(__self__, "collaborative_action_threshold", collaborative_action_threshold)
        if collaborative_weights is not None:
            pulumi.set(__self__, "collaborative_weights", collaborative_weights)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Unique key of referenced protection capability.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Version of referenced protection capability.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="actionName")
    def action_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_name", value)

    @_builtins.property
    @pulumi.getter(name="collaborativeActionThreshold")
    def collaborative_action_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The minimum sum of weights of associated collaborative protection capabilities that have triggered which must be reached in order for _this_ capability to trigger. This field is ignored for non-collaborative capabilities.
        """
        return pulumi.get(self, "collaborative_action_threshold")

    @collaborative_action_threshold.setter
    def collaborative_action_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "collaborative_action_threshold", value)

    @_builtins.property
    @pulumi.getter(name="collaborativeWeights")
    def collaborative_weights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]]:
        """
        (Updatable) Explicit weight values to use for associated collaborative protection capabilities.
        """
        return pulumi.get(self, "collaborative_weights")

    @collaborative_weights.setter
    def collaborative_weights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]]):
        pulumi.set(self, "collaborative_weights", value)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs']]:
        """
        (Updatable) Identifies specific HTTP message parameters to exclude from inspection by a protection capability.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs']]):
        pulumi.set(self, "exclusions", value)


if not MYPY:
    class AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        (Updatable) Unique key of collaborative capability for which weight will be overridden.
        """
        weight: pulumi.Input[_builtins.int]
        """
        (Updatable) The value of weight to set.
        """
elif False:
    AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 weight: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] key: (Updatable) Unique key of collaborative capability for which weight will be overridden.
        :param pulumi.Input[_builtins.int] weight: (Updatable) The value of weight to set.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Unique key of collaborative capability for which weight will be overridden.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The value of weight to set.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgsDict(TypedDict):
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of URL query parameter values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from inspecting. Example: If we have query parameter 'argumentName=argumentValue' and args=['argumentName'], both 'argumentName' and 'argumentValue' will not be inspected.
        """
        request_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of HTTP request cookie values (by cookie name) to exclude from inspecting. Example: If we have cookie 'cookieName=cookieValue' and requestCookies=['cookieName'], both 'cookieName' and 'cookieValue' will not be inspected.
        """
elif False:
    AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 request_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] args: (Updatable) List of URL query parameter values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from inspecting. Example: If we have query parameter 'argumentName=argumentValue' and args=['argumentName'], both 'argumentName' and 'argumentValue' will not be inspected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] request_cookies: (Updatable) List of HTTP request cookie values (by cookie name) to exclude from inspecting. Example: If we have cookie 'cookieName=cookieValue' and requestCookies=['cookieName'], both 'cookieName' and 'cookieValue' will not be inspected.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if request_cookies is not None:
            pulumi.set(__self__, "request_cookies", request_cookies)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of URL query parameter values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from inspecting. Example: If we have query parameter 'argumentName=argumentValue' and args=['argumentName'], both 'argumentName' and 'argumentValue' will not be inspected.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter(name="requestCookies")
    def request_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of HTTP request cookie values (by cookie name) to exclude from inspecting. Example: If we have cookie 'cookieName=cookieValue' and requestCookies=['cookieName'], both 'cookieName' and 'cookieValue' will not be inspected.
        """
        return pulumi.get(self, "request_cookies")

    @request_cookies.setter
    def request_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "request_cookies", value)


if not MYPY:
    class AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgsDict(TypedDict):
        allowed_http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of allowed HTTP methods. Each value as a RFC7230 formated token string. Used in protection capability 911100: Restrict HTTP Request Methods.
        """
        max_http_request_header_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Maximum allowed length of headers in an HTTP request. Used in protection capability: 9200024: Limit length of request header size.
        """
        max_http_request_headers: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Maximum number of headers allowed in an HTTP request. Used in protection capability 9200014: Limit Number of Request Headers.
        """
        max_number_of_arguments: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Maximum number of arguments allowed. Used in protection capability 920380: Number of Arguments Limits.
        """
        max_single_argument_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Maximum allowed length of a single argument. Used in protection capability 920370: Limit argument value length.
        """
        max_total_argument_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Maximum allowed total length of all arguments. Used in protection capability 920390: Limit arguments total length.
        """
elif False:
    AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs:
    def __init__(__self__, *,
                 allowed_http_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_http_request_header_length: Optional[pulumi.Input[_builtins.int]] = None,
                 max_http_request_headers: Optional[pulumi.Input[_builtins.int]] = None,
                 max_number_of_arguments: Optional[pulumi.Input[_builtins.int]] = None,
                 max_single_argument_length: Optional[pulumi.Input[_builtins.int]] = None,
                 max_total_argument_length: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_http_methods: (Updatable) List of allowed HTTP methods. Each value as a RFC7230 formated token string. Used in protection capability 911100: Restrict HTTP Request Methods.
        :param pulumi.Input[_builtins.int] max_http_request_header_length: (Updatable) Maximum allowed length of headers in an HTTP request. Used in protection capability: 9200024: Limit length of request header size.
        :param pulumi.Input[_builtins.int] max_http_request_headers: (Updatable) Maximum number of headers allowed in an HTTP request. Used in protection capability 9200014: Limit Number of Request Headers.
        :param pulumi.Input[_builtins.int] max_number_of_arguments: (Updatable) Maximum number of arguments allowed. Used in protection capability 920380: Number of Arguments Limits.
        :param pulumi.Input[_builtins.int] max_single_argument_length: (Updatable) Maximum allowed length of a single argument. Used in protection capability 920370: Limit argument value length.
        :param pulumi.Input[_builtins.int] max_total_argument_length: (Updatable) Maximum allowed total length of all arguments. Used in protection capability 920390: Limit arguments total length.
        """
        if allowed_http_methods is not None:
            pulumi.set(__self__, "allowed_http_methods", allowed_http_methods)
        if max_http_request_header_length is not None:
            pulumi.set(__self__, "max_http_request_header_length", max_http_request_header_length)
        if max_http_request_headers is not None:
            pulumi.set(__self__, "max_http_request_headers", max_http_request_headers)
        if max_number_of_arguments is not None:
            pulumi.set(__self__, "max_number_of_arguments", max_number_of_arguments)
        if max_single_argument_length is not None:
            pulumi.set(__self__, "max_single_argument_length", max_single_argument_length)
        if max_total_argument_length is not None:
            pulumi.set(__self__, "max_total_argument_length", max_total_argument_length)

    @_builtins.property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of allowed HTTP methods. Each value as a RFC7230 formated token string. Used in protection capability 911100: Restrict HTTP Request Methods.
        """
        return pulumi.get(self, "allowed_http_methods")

    @allowed_http_methods.setter
    def allowed_http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_http_methods", value)

    @_builtins.property
    @pulumi.getter(name="maxHttpRequestHeaderLength")
    def max_http_request_header_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Maximum allowed length of headers in an HTTP request. Used in protection capability: 9200024: Limit length of request header size.
        """
        return pulumi.get(self, "max_http_request_header_length")

    @max_http_request_header_length.setter
    def max_http_request_header_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_http_request_header_length", value)

    @_builtins.property
    @pulumi.getter(name="maxHttpRequestHeaders")
    def max_http_request_headers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Maximum number of headers allowed in an HTTP request. Used in protection capability 9200014: Limit Number of Request Headers.
        """
        return pulumi.get(self, "max_http_request_headers")

    @max_http_request_headers.setter
    def max_http_request_headers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_http_request_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxNumberOfArguments")
    def max_number_of_arguments(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Maximum number of arguments allowed. Used in protection capability 920380: Number of Arguments Limits.
        """
        return pulumi.get(self, "max_number_of_arguments")

    @max_number_of_arguments.setter
    def max_number_of_arguments(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_number_of_arguments", value)

    @_builtins.property
    @pulumi.getter(name="maxSingleArgumentLength")
    def max_single_argument_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Maximum allowed length of a single argument. Used in protection capability 920370: Limit argument value length.
        """
        return pulumi.get(self, "max_single_argument_length")

    @max_single_argument_length.setter
    def max_single_argument_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_single_argument_length", value)

    @_builtins.property
    @pulumi.getter(name="maxTotalArgumentLength")
    def max_total_argument_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Maximum allowed total length of all arguments. Used in protection capability 920390: Limit arguments total length.
        """
        return pulumi.get(self, "max_total_argument_length")

    @max_total_argument_length.setter
    def max_total_argument_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_total_argument_length", value)


if not MYPY:
    class NetworkAddressListVcnAddressArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A private IP address or CIDR IP address range.
        """
        vcn_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VCN.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    NetworkAddressListVcnAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkAddressListVcnAddressArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[_builtins.str]] = None,
                 vcn_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] addresses: (Updatable) A private IP address or CIDR IP address range.
        :param pulumi.Input[_builtins.str] vcn_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VCN.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if vcn_id is not None:
            pulumi.set(__self__, "vcn_id", vcn_id)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A private IP address or CIDR IP address range.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter(name="vcnId")
    def vcn_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VCN.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vcn_id")

    @vcn_id.setter
    def vcn_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vcn_id", value)


if not MYPY:
    class GetFirewallsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetFirewallsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFirewallsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNetworkAddressListsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNetworkAddressListsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkAddressListsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProtectionCapabilitiesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetProtectionCapabilitiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProtectionCapabilitiesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProtectionCapabilityGroupTagsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the entire name given.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetProtectionCapabilityGroupTagsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProtectionCapabilityGroupTagsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWebAppFirewallPoliciesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Rule name. Must be unique within the module.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWebAppFirewallPoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWebAppFirewallPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Rule name. Must be unique within the module.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


