# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'AppFirewallPolicyActionArgs',
    'AppFirewallPolicyActionBodyArgs',
    'AppFirewallPolicyActionHeaderArgs',
    'AppFirewallPolicyRequestAccessControlArgs',
    'AppFirewallPolicyRequestAccessControlRuleArgs',
    'AppFirewallPolicyRequestProtectionArgs',
    'AppFirewallPolicyRequestProtectionRuleArgs',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs',
    'AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs',
    'AppFirewallPolicyRequestRateLimitingArgs',
    'AppFirewallPolicyRequestRateLimitingRuleArgs',
    'AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs',
    'AppFirewallPolicyResponseAccessControlArgs',
    'AppFirewallPolicyResponseAccessControlRuleArgs',
    'AppFirewallPolicyResponseProtectionArgs',
    'AppFirewallPolicyResponseProtectionRuleArgs',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs',
    'AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs',
    'NetworkAddressListVcnAddressArgs',
    'GetFirewallsFilterArgs',
    'GetNetworkAddressListsFilterArgs',
    'GetProtectionCapabilitiesFilterArgs',
    'GetProtectionCapabilityGroupTagsFilterArgs',
    'GetWebAppFirewallPoliciesFilterArgs',
]

@pulumi.input_type
class AppFirewallPolicyActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 body: Optional[pulumi.Input['AppFirewallPolicyActionBodyArgs']] = None,
                 code: Optional[pulumi.Input[int]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyActionHeaderArgs']]]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        :param pulumi.Input['AppFirewallPolicyActionBodyArgs'] body: (Updatable) Type of returned HTTP response body.
        :param pulumi.Input[int] code: (Updatable) Response code.
               
               The following response codes are valid values for this property:
               * 2xx
               
               200 OK 201 Created 202 Accepted 206 Partial Content
               * 3xx
               
               300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 307 Temporary Redirect
               * 4xx
               
               400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 405 Method Not Allowed 408 Request Timeout 409 Conflict 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 422 Unprocessable Entity 494 Request Header Too Large 495 Cert Error 496 No Cert 497 HTTP to HTTPS
               * 5xx
               
               500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 507 Insufficient Storage
               
               Example: `200`
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyActionHeaderArgs']]] headers: (Updatable) Adds headers defined in this array for HTTP response.
               
               Hop-by-hop headers are not allowed to be set:
               * Connection
               * Keep-Alive
               * Proxy-Authenticate
               * Proxy-Authorization
               * TE
               * Trailer
               * Transfer-Encoding
               * Upgrade
        """
        AppFirewallPolicyActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
            body=body,
            code=code,
            headers=headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             type: pulumi.Input[str],
             body: Optional[pulumi.Input['AppFirewallPolicyActionBodyArgs']] = None,
             code: Optional[pulumi.Input[int]] = None,
             headers: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyActionHeaderArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("type", type)
        if body is not None:
            _setter("body", body)
        if code is not None:
            _setter("code", code)
        if headers is not None:
            _setter("headers", headers)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['AppFirewallPolicyActionBodyArgs']]:
        """
        (Updatable) Type of returned HTTP response body.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['AppFirewallPolicyActionBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Response code.

        The following response codes are valid values for this property:
        * 2xx

        200 OK 201 Created 202 Accepted 206 Partial Content
        * 3xx

        300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 307 Temporary Redirect
        * 4xx

        400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 405 Method Not Allowed 408 Request Timeout 409 Conflict 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 422 Unprocessable Entity 494 Request Header Too Large 495 Cert Error 496 No Cert 497 HTTP to HTTPS
        * 5xx

        500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 507 Insufficient Storage

        Example: `200`
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyActionHeaderArgs']]]]:
        """
        (Updatable) Adds headers defined in this array for HTTP response.

        Hop-by-hop headers are not allowed to be set:
        * Connection
        * Keep-Alive
        * Proxy-Authenticate
        * Proxy-Authorization
        * TE
        * Trailer
        * Transfer-Encoding
        * Upgrade
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)


@pulumi.input_type
class AppFirewallPolicyActionBodyArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] text: (Updatable) Static response body text.
        :param pulumi.Input[str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        """
        AppFirewallPolicyActionBodyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text=text,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text: pulumi.Input[str],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("text", text)
        _setter("type", type)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        (Updatable) Static response body text.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class AppFirewallPolicyActionHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[str] value: (Updatable) The value of the header field.
        """
        AppFirewallPolicyActionHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The value of the header field.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class AppFirewallPolicyRequestAccessControlArgs:
    def __init__(__self__, *,
                 default_action_name: pulumi.Input[str],
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestAccessControlRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] default_action_name: (Updatable) References an default Action to take if no AccessControlRule was matched. Allowed action types:
               * **ALLOW** continues execution of other modules and their rules.
               * **RETURN_HTTP_RESPONSE** terminates further execution of modules and rules and returns defined HTTP response.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestAccessControlRuleArgs']]] rules: (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        AppFirewallPolicyRequestAccessControlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_action_name=default_action_name,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_action_name: pulumi.Input[str],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestAccessControlRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_action_name", default_action_name)
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter(name="defaultActionName")
    def default_action_name(self) -> pulumi.Input[str]:
        """
        (Updatable) References an default Action to take if no AccessControlRule was matched. Allowed action types:
        * **ALLOW** continues execution of other modules and their rules.
        * **RETURN_HTTP_RESPONSE** terminates further execution of modules and rules and returns defined HTTP response.
        """
        return pulumi.get(self, "default_action_name")

    @default_action_name.setter
    def default_action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_action_name", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestAccessControlRuleArgs']]]]:
        """
        (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestAccessControlRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class AppFirewallPolicyRequestAccessControlRuleArgs:
    def __init__(__self__, *,
                 action_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 condition_language: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action_name: (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        :param pulumi.Input[str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        :param pulumi.Input[str] condition: (Updatable) An expression that determines whether or not the rule action should be executed.
        :param pulumi.Input[str] condition_language: (Updatable) The language used to parse condition from field `condition`. Available languages:
               * **JMESPATH** an extended JMESPath language syntax.
        """
        AppFirewallPolicyRequestAccessControlRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_name=action_name,
            name=name,
            type=type,
            condition=condition,
            condition_language=condition_language,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_name: pulumi.Input[str],
             name: pulumi.Input[str],
             type: pulumi.Input[str],
             condition: Optional[pulumi.Input[str]] = None,
             condition_language: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action_name", action_name)
        _setter("name", name)
        _setter("type", type)
        if condition is not None:
            _setter("condition", condition)
        if condition_language is not None:
            _setter("condition_language", condition_language)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="conditionLanguage")
    def condition_language(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        return pulumi.get(self, "condition_language")

    @condition_language.setter
    def condition_language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition_language", value)


@pulumi.input_type
class AppFirewallPolicyRequestProtectionArgs:
    def __init__(__self__, *,
                 body_inspection_size_limit_exceeded_action_name: Optional[pulumi.Input[str]] = None,
                 body_inspection_size_limit_in_bytes: Optional[pulumi.Input[int]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] body_inspection_size_limit_exceeded_action_name: (Updatable) References action by name from actions defined in WebAppFirewallPolicy. Executed if HTTP message body size exceeds limit set in field `bodyInspectionSizeLimitInBytes`.
               
               If this field is `null` HTTP message body will inspected up to `bodyInspectionSizeLimitInBytes` and the rest will not be inspected by Protection Capabilities.
               
               Allowed action types:
               * **RETURN_HTTP_RESPONSE** terminates further execution of modules and rules and returns defined HTTP response.
        :param pulumi.Input[int] body_inspection_size_limit_in_bytes: (Updatable) Maximum size of inspected HTTP message body in bytes. Actions to take if this limit is exceeded are defined in `bodyInspectionSizeLimitExceededActionName`.
               
               Body inspection maximum size allowed is defined with per-tenancy limit: 8192 bytes.
               
               For steps to request a limit increase, see [Requesting a Service Limit Increase](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/servicelimits.htm).
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleArgs']]] rules: (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        AppFirewallPolicyRequestProtectionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            body_inspection_size_limit_exceeded_action_name=body_inspection_size_limit_exceeded_action_name,
            body_inspection_size_limit_in_bytes=body_inspection_size_limit_in_bytes,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             body_inspection_size_limit_exceeded_action_name: Optional[pulumi.Input[str]] = None,
             body_inspection_size_limit_in_bytes: Optional[pulumi.Input[int]] = None,
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if body_inspection_size_limit_exceeded_action_name is not None:
            _setter("body_inspection_size_limit_exceeded_action_name", body_inspection_size_limit_exceeded_action_name)
        if body_inspection_size_limit_in_bytes is not None:
            _setter("body_inspection_size_limit_in_bytes", body_inspection_size_limit_in_bytes)
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter(name="bodyInspectionSizeLimitExceededActionName")
    def body_inspection_size_limit_exceeded_action_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) References action by name from actions defined in WebAppFirewallPolicy. Executed if HTTP message body size exceeds limit set in field `bodyInspectionSizeLimitInBytes`.

        If this field is `null` HTTP message body will inspected up to `bodyInspectionSizeLimitInBytes` and the rest will not be inspected by Protection Capabilities.

        Allowed action types:
        * **RETURN_HTTP_RESPONSE** terminates further execution of modules and rules and returns defined HTTP response.
        """
        return pulumi.get(self, "body_inspection_size_limit_exceeded_action_name")

    @body_inspection_size_limit_exceeded_action_name.setter
    def body_inspection_size_limit_exceeded_action_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body_inspection_size_limit_exceeded_action_name", value)

    @property
    @pulumi.getter(name="bodyInspectionSizeLimitInBytes")
    def body_inspection_size_limit_in_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum size of inspected HTTP message body in bytes. Actions to take if this limit is exceeded are defined in `bodyInspectionSizeLimitExceededActionName`.

        Body inspection maximum size allowed is defined with per-tenancy limit: 8192 bytes.

        For steps to request a limit increase, see [Requesting a Service Limit Increase](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/servicelimits.htm).
        """
        return pulumi.get(self, "body_inspection_size_limit_in_bytes")

    @body_inspection_size_limit_in_bytes.setter
    def body_inspection_size_limit_in_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "body_inspection_size_limit_in_bytes", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleArgs']]]]:
        """
        (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class AppFirewallPolicyRequestProtectionRuleArgs:
    def __init__(__self__, *,
                 action_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 protection_capabilities: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs']]],
                 type: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 condition_language: Optional[pulumi.Input[str]] = None,
                 is_body_inspection_enabled: Optional[pulumi.Input[bool]] = None,
                 protection_capability_settings: Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs']] = None):
        """
        :param pulumi.Input[str] action_name: (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        :param pulumi.Input[str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs']]] protection_capabilities: (Updatable) An ordered list that references OCI-managed protection capabilities. Referenced protection capabilities are not necessarily executed in order of appearance. Their execution order is decided at runtime for improved performance. The array cannot contain entries with the same pair of capability key and version more than once.
        :param pulumi.Input[str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        :param pulumi.Input[str] condition: (Updatable) An expression that determines whether or not the rule action should be executed.
        :param pulumi.Input[str] condition_language: (Updatable) The language used to parse condition from field `condition`. Available languages:
               * **JMESPATH** an extended JMESPath language syntax.
        :param pulumi.Input[bool] is_body_inspection_enabled: (Updatable) Enables/disables body inspection for this protection rule. Only Protection Rules in RequestProtection can have this option enabled. Response body inspection will be available at a later date.
        :param pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs'] protection_capability_settings: (Updatable) Settings for protection capabilities
        """
        AppFirewallPolicyRequestProtectionRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_name=action_name,
            name=name,
            protection_capabilities=protection_capabilities,
            type=type,
            condition=condition,
            condition_language=condition_language,
            is_body_inspection_enabled=is_body_inspection_enabled,
            protection_capability_settings=protection_capability_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_name: pulumi.Input[str],
             name: pulumi.Input[str],
             protection_capabilities: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs']]],
             type: pulumi.Input[str],
             condition: Optional[pulumi.Input[str]] = None,
             condition_language: Optional[pulumi.Input[str]] = None,
             is_body_inspection_enabled: Optional[pulumi.Input[bool]] = None,
             protection_capability_settings: Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action_name", action_name)
        _setter("name", name)
        _setter("protection_capabilities", protection_capabilities)
        _setter("type", type)
        if condition is not None:
            _setter("condition", condition)
        if condition_language is not None:
            _setter("condition_language", condition_language)
        if is_body_inspection_enabled is not None:
            _setter("is_body_inspection_enabled", is_body_inspection_enabled)
        if protection_capability_settings is not None:
            _setter("protection_capability_settings", protection_capability_settings)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="protectionCapabilities")
    def protection_capabilities(self) -> pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs']]]:
        """
        (Updatable) An ordered list that references OCI-managed protection capabilities. Referenced protection capabilities are not necessarily executed in order of appearance. Their execution order is decided at runtime for improved performance. The array cannot contain entries with the same pair of capability key and version more than once.
        """
        return pulumi.get(self, "protection_capabilities")

    @protection_capabilities.setter
    def protection_capabilities(self, value: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs']]]):
        pulumi.set(self, "protection_capabilities", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="conditionLanguage")
    def condition_language(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        return pulumi.get(self, "condition_language")

    @condition_language.setter
    def condition_language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition_language", value)

    @property
    @pulumi.getter(name="isBodyInspectionEnabled")
    def is_body_inspection_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables/disables body inspection for this protection rule. Only Protection Rules in RequestProtection can have this option enabled. Response body inspection will be available at a later date.
        """
        return pulumi.get(self, "is_body_inspection_enabled")

    @is_body_inspection_enabled.setter
    def is_body_inspection_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_body_inspection_enabled", value)

    @property
    @pulumi.getter(name="protectionCapabilitySettings")
    def protection_capability_settings(self) -> Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs']]:
        """
        (Updatable) Settings for protection capabilities
        """
        return pulumi.get(self, "protection_capability_settings")

    @protection_capability_settings.setter
    def protection_capability_settings(self, value: Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs']]):
        pulumi.set(self, "protection_capability_settings", value)


@pulumi.input_type
class AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 version: pulumi.Input[int],
                 action_name: Optional[pulumi.Input[str]] = None,
                 collaborative_action_threshold: Optional[pulumi.Input[int]] = None,
                 collaborative_weights: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]] = None,
                 exclusions: Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs']] = None):
        """
        :param pulumi.Input[str] key: (Updatable) Unique key of referenced protection capability.
        :param pulumi.Input[int] version: (Updatable) Version of referenced protection capability.
        :param pulumi.Input[str] action_name: (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        :param pulumi.Input[int] collaborative_action_threshold: (Updatable) The minimum sum of weights of associated collaborative protection capabilities that have triggered which must be reached in order for _this_ capability to trigger. This field is ignored for non-collaborative capabilities.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]] collaborative_weights: (Updatable) Explicit weight values to use for associated collaborative protection capabilities.
        :param pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs'] exclusions: (Updatable) Identifies specific HTTP message parameters to exclude from inspection by a protection capability.
        """
        AppFirewallPolicyRequestProtectionRuleProtectionCapabilityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            version=version,
            action_name=action_name,
            collaborative_action_threshold=collaborative_action_threshold,
            collaborative_weights=collaborative_weights,
            exclusions=exclusions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             version: pulumi.Input[int],
             action_name: Optional[pulumi.Input[str]] = None,
             collaborative_action_threshold: Optional[pulumi.Input[int]] = None,
             collaborative_weights: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]] = None,
             exclusions: Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("version", version)
        if action_name is not None:
            _setter("action_name", action_name)
        if collaborative_action_threshold is not None:
            _setter("collaborative_action_threshold", collaborative_action_threshold)
        if collaborative_weights is not None:
            _setter("collaborative_weights", collaborative_weights)
        if exclusions is not None:
            _setter("exclusions", exclusions)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        (Updatable) Unique key of referenced protection capability.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[int]:
        """
        (Updatable) Version of referenced protection capability.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[int]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_name", value)

    @property
    @pulumi.getter(name="collaborativeActionThreshold")
    def collaborative_action_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The minimum sum of weights of associated collaborative protection capabilities that have triggered which must be reached in order for _this_ capability to trigger. This field is ignored for non-collaborative capabilities.
        """
        return pulumi.get(self, "collaborative_action_threshold")

    @collaborative_action_threshold.setter
    def collaborative_action_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "collaborative_action_threshold", value)

    @property
    @pulumi.getter(name="collaborativeWeights")
    def collaborative_weights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]]:
        """
        (Updatable) Explicit weight values to use for associated collaborative protection capabilities.
        """
        return pulumi.get(self, "collaborative_weights")

    @collaborative_weights.setter
    def collaborative_weights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]]):
        pulumi.set(self, "collaborative_weights", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs']]:
        """
        (Updatable) Identifies specific HTTP message parameters to exclude from inspection by a protection capability.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input['AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs']]):
        pulumi.set(self, "exclusions", value)


@pulumi.input_type
class AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 weight: pulumi.Input[int]):
        """
        :param pulumi.Input[str] key: (Updatable) Unique key of referenced protection capability.
        :param pulumi.Input[int] weight: (Updatable) The value of weight to set.
        """
        AppFirewallPolicyRequestProtectionRuleProtectionCapabilityCollaborativeWeightArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             weight: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        (Updatable) Unique key of referenced protection capability.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        (Updatable) The value of weight to set.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 request_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: (Updatable) List of URL query parameter values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from inspecting. Example: If we have query parameter 'argumentName=argumentValue' and args=['argumentName'], both 'argumentName' and 'argumentValue' will not be inspected.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] request_cookies: (Updatable) List of HTTP request cookie values (by cookie name) to exclude from inspecting. Example: If we have cookie 'cookieName=cookieValue' and requestCookies=['cookieName'], both 'cookieName' and 'cookieValue' will not be inspected.
        """
        AppFirewallPolicyRequestProtectionRuleProtectionCapabilityExclusionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            args=args,
            request_cookies=request_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             request_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if args is not None:
            _setter("args", args)
        if request_cookies is not None:
            _setter("request_cookies", request_cookies)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) List of URL query parameter values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from inspecting. Example: If we have query parameter 'argumentName=argumentValue' and args=['argumentName'], both 'argumentName' and 'argumentValue' will not be inspected.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter(name="requestCookies")
    def request_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) List of HTTP request cookie values (by cookie name) to exclude from inspecting. Example: If we have cookie 'cookieName=cookieValue' and requestCookies=['cookieName'], both 'cookieName' and 'cookieValue' will not be inspected.
        """
        return pulumi.get(self, "request_cookies")

    @request_cookies.setter
    def request_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "request_cookies", value)


@pulumi.input_type
class AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs:
    def __init__(__self__, *,
                 allowed_http_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_http_request_header_length: Optional[pulumi.Input[int]] = None,
                 max_http_request_headers: Optional[pulumi.Input[int]] = None,
                 max_number_of_arguments: Optional[pulumi.Input[int]] = None,
                 max_single_argument_length: Optional[pulumi.Input[int]] = None,
                 max_total_argument_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_http_methods: (Updatable) List of allowed HTTP methods. Each value as a RFC7230 formated token string. Used in protection capability 911100: Restrict HTTP Request Methods.
        :param pulumi.Input[int] max_http_request_header_length: (Updatable) Maximum allowed length of headers in an HTTP request. Used in protection capability: 9200024: Limit length of request header size.
        :param pulumi.Input[int] max_http_request_headers: (Updatable) Maximum number of headers allowed in an HTTP request. Used in protection capability 9200014: Limit Number of Request Headers.
        :param pulumi.Input[int] max_number_of_arguments: (Updatable) Maximum number of arguments allowed. Used in protection capability 920380: Number of Arguments Limits.
        :param pulumi.Input[int] max_single_argument_length: (Updatable) Maximum allowed length of a single argument. Used in protection capability 920370: Limit argument value length.
        :param pulumi.Input[int] max_total_argument_length: (Updatable) Maximum allowed total length of all arguments. Used in protection capability 920390: Limit arguments total length.
        """
        AppFirewallPolicyRequestProtectionRuleProtectionCapabilitySettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_http_methods=allowed_http_methods,
            max_http_request_header_length=max_http_request_header_length,
            max_http_request_headers=max_http_request_headers,
            max_number_of_arguments=max_number_of_arguments,
            max_single_argument_length=max_single_argument_length,
            max_total_argument_length=max_total_argument_length,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_http_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             max_http_request_header_length: Optional[pulumi.Input[int]] = None,
             max_http_request_headers: Optional[pulumi.Input[int]] = None,
             max_number_of_arguments: Optional[pulumi.Input[int]] = None,
             max_single_argument_length: Optional[pulumi.Input[int]] = None,
             max_total_argument_length: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allowed_http_methods is not None:
            _setter("allowed_http_methods", allowed_http_methods)
        if max_http_request_header_length is not None:
            _setter("max_http_request_header_length", max_http_request_header_length)
        if max_http_request_headers is not None:
            _setter("max_http_request_headers", max_http_request_headers)
        if max_number_of_arguments is not None:
            _setter("max_number_of_arguments", max_number_of_arguments)
        if max_single_argument_length is not None:
            _setter("max_single_argument_length", max_single_argument_length)
        if max_total_argument_length is not None:
            _setter("max_total_argument_length", max_total_argument_length)

    @property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) List of allowed HTTP methods. Each value as a RFC7230 formated token string. Used in protection capability 911100: Restrict HTTP Request Methods.
        """
        return pulumi.get(self, "allowed_http_methods")

    @allowed_http_methods.setter
    def allowed_http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_http_methods", value)

    @property
    @pulumi.getter(name="maxHttpRequestHeaderLength")
    def max_http_request_header_length(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum allowed length of headers in an HTTP request. Used in protection capability: 9200024: Limit length of request header size.
        """
        return pulumi.get(self, "max_http_request_header_length")

    @max_http_request_header_length.setter
    def max_http_request_header_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_http_request_header_length", value)

    @property
    @pulumi.getter(name="maxHttpRequestHeaders")
    def max_http_request_headers(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum number of headers allowed in an HTTP request. Used in protection capability 9200014: Limit Number of Request Headers.
        """
        return pulumi.get(self, "max_http_request_headers")

    @max_http_request_headers.setter
    def max_http_request_headers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_http_request_headers", value)

    @property
    @pulumi.getter(name="maxNumberOfArguments")
    def max_number_of_arguments(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum number of arguments allowed. Used in protection capability 920380: Number of Arguments Limits.
        """
        return pulumi.get(self, "max_number_of_arguments")

    @max_number_of_arguments.setter
    def max_number_of_arguments(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_number_of_arguments", value)

    @property
    @pulumi.getter(name="maxSingleArgumentLength")
    def max_single_argument_length(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum allowed length of a single argument. Used in protection capability 920370: Limit argument value length.
        """
        return pulumi.get(self, "max_single_argument_length")

    @max_single_argument_length.setter
    def max_single_argument_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_single_argument_length", value)

    @property
    @pulumi.getter(name="maxTotalArgumentLength")
    def max_total_argument_length(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum allowed total length of all arguments. Used in protection capability 920390: Limit arguments total length.
        """
        return pulumi.get(self, "max_total_argument_length")

    @max_total_argument_length.setter
    def max_total_argument_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_total_argument_length", value)


@pulumi.input_type
class AppFirewallPolicyRequestRateLimitingArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleArgs']]] rules: (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        AppFirewallPolicyRequestRateLimitingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleArgs']]]]:
        """
        (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class AppFirewallPolicyRequestRateLimitingRuleArgs:
    def __init__(__self__, *,
                 action_name: pulumi.Input[str],
                 configurations: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs']]],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 condition_language: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action_name: (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs']]] configurations: (Updatable) Rate Limiting Configurations. Each configuration counts requests towards its own `requestsLimit`.
        :param pulumi.Input[str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        :param pulumi.Input[str] condition: (Updatable) An expression that determines whether or not the rule action should be executed.
        :param pulumi.Input[str] condition_language: (Updatable) The language used to parse condition from field `condition`. Available languages:
               * **JMESPATH** an extended JMESPath language syntax.
        """
        AppFirewallPolicyRequestRateLimitingRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_name=action_name,
            configurations=configurations,
            name=name,
            type=type,
            condition=condition,
            condition_language=condition_language,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_name: pulumi.Input[str],
             configurations: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs']]],
             name: pulumi.Input[str],
             type: pulumi.Input[str],
             condition: Optional[pulumi.Input[str]] = None,
             condition_language: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action_name", action_name)
        _setter("configurations", configurations)
        _setter("name", name)
        _setter("type", type)
        if condition is not None:
            _setter("condition", condition)
        if condition_language is not None:
            _setter("condition_language", condition_language)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)

    @property
    @pulumi.getter
    def configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs']]]:
        """
        (Updatable) Rate Limiting Configurations. Each configuration counts requests towards its own `requestsLimit`.
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs']]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="conditionLanguage")
    def condition_language(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        return pulumi.get(self, "condition_language")

    @condition_language.setter
    def condition_language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition_language", value)


@pulumi.input_type
class AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs:
    def __init__(__self__, *,
                 period_in_seconds: pulumi.Input[int],
                 requests_limit: pulumi.Input[int],
                 action_duration_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] period_in_seconds: (Updatable) Evaluation period in seconds.
        :param pulumi.Input[int] requests_limit: (Updatable) Requests allowed per evaluation period.
        :param pulumi.Input[int] action_duration_in_seconds: (Updatable) Duration of block action application in seconds when `requestsLimit` is reached. Optional and can be 0 (no block duration).
        """
        AppFirewallPolicyRequestRateLimitingRuleConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            period_in_seconds=period_in_seconds,
            requests_limit=requests_limit,
            action_duration_in_seconds=action_duration_in_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             period_in_seconds: pulumi.Input[int],
             requests_limit: pulumi.Input[int],
             action_duration_in_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("period_in_seconds", period_in_seconds)
        _setter("requests_limit", requests_limit)
        if action_duration_in_seconds is not None:
            _setter("action_duration_in_seconds", action_duration_in_seconds)

    @property
    @pulumi.getter(name="periodInSeconds")
    def period_in_seconds(self) -> pulumi.Input[int]:
        """
        (Updatable) Evaluation period in seconds.
        """
        return pulumi.get(self, "period_in_seconds")

    @period_in_seconds.setter
    def period_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "period_in_seconds", value)

    @property
    @pulumi.getter(name="requestsLimit")
    def requests_limit(self) -> pulumi.Input[int]:
        """
        (Updatable) Requests allowed per evaluation period.
        """
        return pulumi.get(self, "requests_limit")

    @requests_limit.setter
    def requests_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "requests_limit", value)

    @property
    @pulumi.getter(name="actionDurationInSeconds")
    def action_duration_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Duration of block action application in seconds when `requestsLimit` is reached. Optional and can be 0 (no block duration).
        """
        return pulumi.get(self, "action_duration_in_seconds")

    @action_duration_in_seconds.setter
    def action_duration_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "action_duration_in_seconds", value)


@pulumi.input_type
class AppFirewallPolicyResponseAccessControlArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseAccessControlRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseAccessControlRuleArgs']]] rules: (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        AppFirewallPolicyResponseAccessControlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseAccessControlRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseAccessControlRuleArgs']]]]:
        """
        (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseAccessControlRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class AppFirewallPolicyResponseAccessControlRuleArgs:
    def __init__(__self__, *,
                 action_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 condition_language: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action_name: (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        :param pulumi.Input[str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        :param pulumi.Input[str] condition: (Updatable) An expression that determines whether or not the rule action should be executed.
        :param pulumi.Input[str] condition_language: (Updatable) The language used to parse condition from field `condition`. Available languages:
               * **JMESPATH** an extended JMESPath language syntax.
        """
        AppFirewallPolicyResponseAccessControlRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_name=action_name,
            name=name,
            type=type,
            condition=condition,
            condition_language=condition_language,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_name: pulumi.Input[str],
             name: pulumi.Input[str],
             type: pulumi.Input[str],
             condition: Optional[pulumi.Input[str]] = None,
             condition_language: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action_name", action_name)
        _setter("name", name)
        _setter("type", type)
        if condition is not None:
            _setter("condition", condition)
        if condition_language is not None:
            _setter("condition_language", condition_language)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="conditionLanguage")
    def condition_language(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        return pulumi.get(self, "condition_language")

    @condition_language.setter
    def condition_language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition_language", value)


@pulumi.input_type
class AppFirewallPolicyResponseProtectionArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleArgs']]] rules: (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        AppFirewallPolicyResponseProtectionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleArgs']]]]:
        """
        (Updatable) Ordered list of ProtectionRules. Rules are executed in order of appearance in this array. ProtectionRules in this array can only use protection capabilities of RESPONSE_PROTECTION_CAPABILITY type.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class AppFirewallPolicyResponseProtectionRuleArgs:
    def __init__(__self__, *,
                 action_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 protection_capabilities: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs']]],
                 type: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 condition_language: Optional[pulumi.Input[str]] = None,
                 is_body_inspection_enabled: Optional[pulumi.Input[bool]] = None,
                 protection_capability_settings: Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs']] = None):
        """
        :param pulumi.Input[str] action_name: (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        :param pulumi.Input[str] name: (Updatable) Rule name. Must be unique within the module.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs']]] protection_capabilities: (Updatable) An ordered list that references OCI-managed protection capabilities. Referenced protection capabilities are not necessarily executed in order of appearance. Their execution order is decided at runtime for improved performance. The array cannot contain entries with the same pair of capability key and version more than once.
        :param pulumi.Input[str] type: (Updatable) Type of WebAppFirewallPolicyRule.
        :param pulumi.Input[str] condition: (Updatable) An expression that determines whether or not the rule action should be executed.
        :param pulumi.Input[str] condition_language: (Updatable) The language used to parse condition from field `condition`. Available languages:
               * **JMESPATH** an extended JMESPath language syntax.
        :param pulumi.Input[bool] is_body_inspection_enabled: (Updatable) Enables/disables body inspection for this protection rule. Only Protection Rules in RequestProtection can have this option enabled. Response body inspection will be available at a later date.
        :param pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs'] protection_capability_settings: (Updatable) Settings for protection capabilities
        """
        AppFirewallPolicyResponseProtectionRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_name=action_name,
            name=name,
            protection_capabilities=protection_capabilities,
            type=type,
            condition=condition,
            condition_language=condition_language,
            is_body_inspection_enabled=is_body_inspection_enabled,
            protection_capability_settings=protection_capability_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_name: pulumi.Input[str],
             name: pulumi.Input[str],
             protection_capabilities: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs']]],
             type: pulumi.Input[str],
             condition: Optional[pulumi.Input[str]] = None,
             condition_language: Optional[pulumi.Input[str]] = None,
             is_body_inspection_enabled: Optional[pulumi.Input[bool]] = None,
             protection_capability_settings: Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action_name", action_name)
        _setter("name", name)
        _setter("protection_capabilities", protection_capabilities)
        _setter("type", type)
        if condition is not None:
            _setter("condition", condition)
        if condition_language is not None:
            _setter("condition_language", condition_language)
        if is_body_inspection_enabled is not None:
            _setter("is_body_inspection_enabled", is_body_inspection_enabled)
        if protection_capability_settings is not None:
            _setter("protection_capability_settings", protection_capability_settings)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="protectionCapabilities")
    def protection_capabilities(self) -> pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs']]]:
        """
        (Updatable) An ordered list that references OCI-managed protection capabilities. Referenced protection capabilities are not necessarily executed in order of appearance. Their execution order is decided at runtime for improved performance. The array cannot contain entries with the same pair of capability key and version more than once.
        """
        return pulumi.get(self, "protection_capabilities")

    @protection_capabilities.setter
    def protection_capabilities(self, value: pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs']]]):
        pulumi.set(self, "protection_capabilities", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of WebAppFirewallPolicyRule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) An expression that determines whether or not the rule action should be executed.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="conditionLanguage")
    def condition_language(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The language used to parse condition from field `condition`. Available languages:
        * **JMESPATH** an extended JMESPath language syntax.
        """
        return pulumi.get(self, "condition_language")

    @condition_language.setter
    def condition_language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition_language", value)

    @property
    @pulumi.getter(name="isBodyInspectionEnabled")
    def is_body_inspection_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables/disables body inspection for this protection rule. Only Protection Rules in RequestProtection can have this option enabled. Response body inspection will be available at a later date.
        """
        return pulumi.get(self, "is_body_inspection_enabled")

    @is_body_inspection_enabled.setter
    def is_body_inspection_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_body_inspection_enabled", value)

    @property
    @pulumi.getter(name="protectionCapabilitySettings")
    def protection_capability_settings(self) -> Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs']]:
        """
        (Updatable) Settings for protection capabilities
        """
        return pulumi.get(self, "protection_capability_settings")

    @protection_capability_settings.setter
    def protection_capability_settings(self, value: Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs']]):
        pulumi.set(self, "protection_capability_settings", value)


@pulumi.input_type
class AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 version: pulumi.Input[int],
                 action_name: Optional[pulumi.Input[str]] = None,
                 collaborative_action_threshold: Optional[pulumi.Input[int]] = None,
                 collaborative_weights: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]] = None,
                 exclusions: Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs']] = None):
        """
        :param pulumi.Input[str] key: (Updatable) Unique key of referenced protection capability.
        :param pulumi.Input[int] version: (Updatable) Version of referenced protection capability.
        :param pulumi.Input[str] action_name: (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        :param pulumi.Input[int] collaborative_action_threshold: (Updatable) The minimum sum of weights of associated collaborative protection capabilities that have triggered which must be reached in order for _this_ capability to trigger. This field is ignored for non-collaborative capabilities.
        :param pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]] collaborative_weights: (Updatable) Explicit weight values to use for associated collaborative protection capabilities.
        :param pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs'] exclusions: (Updatable) Identifies specific HTTP message parameters to exclude from inspection by a protection capability.
        """
        AppFirewallPolicyResponseProtectionRuleProtectionCapabilityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            version=version,
            action_name=action_name,
            collaborative_action_threshold=collaborative_action_threshold,
            collaborative_weights=collaborative_weights,
            exclusions=exclusions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             version: pulumi.Input[int],
             action_name: Optional[pulumi.Input[str]] = None,
             collaborative_action_threshold: Optional[pulumi.Input[int]] = None,
             collaborative_weights: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]] = None,
             exclusions: Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("version", version)
        if action_name is not None:
            _setter("action_name", action_name)
        if collaborative_action_threshold is not None:
            _setter("collaborative_action_threshold", collaborative_action_threshold)
        if collaborative_weights is not None:
            _setter("collaborative_weights", collaborative_weights)
        if exclusions is not None:
            _setter("exclusions", exclusions)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        (Updatable) Unique key of referenced protection capability.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[int]:
        """
        (Updatable) Version of referenced protection capability.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[int]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Override action to take if capability was triggered, defined in Protection Rule for this capability. Only actions of type CHECK are allowed.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_name", value)

    @property
    @pulumi.getter(name="collaborativeActionThreshold")
    def collaborative_action_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The minimum sum of weights of associated collaborative protection capabilities that have triggered which must be reached in order for _this_ capability to trigger. This field is ignored for non-collaborative capabilities.
        """
        return pulumi.get(self, "collaborative_action_threshold")

    @collaborative_action_threshold.setter
    def collaborative_action_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "collaborative_action_threshold", value)

    @property
    @pulumi.getter(name="collaborativeWeights")
    def collaborative_weights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]]:
        """
        (Updatable) Explicit weight values to use for associated collaborative protection capabilities.
        """
        return pulumi.get(self, "collaborative_weights")

    @collaborative_weights.setter
    def collaborative_weights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs']]]]):
        pulumi.set(self, "collaborative_weights", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs']]:
        """
        (Updatable) Identifies specific HTTP message parameters to exclude from inspection by a protection capability.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input['AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs']]):
        pulumi.set(self, "exclusions", value)


@pulumi.input_type
class AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 weight: pulumi.Input[int]):
        """
        :param pulumi.Input[str] key: (Updatable) Unique key of referenced protection capability.
        :param pulumi.Input[int] weight: (Updatable) The value of weight to set.
        """
        AppFirewallPolicyResponseProtectionRuleProtectionCapabilityCollaborativeWeightArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             weight: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        (Updatable) Unique key of referenced protection capability.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        (Updatable) The value of weight to set.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 request_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: (Updatable) List of URL query parameter values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from inspecting. Example: If we have query parameter 'argumentName=argumentValue' and args=['argumentName'], both 'argumentName' and 'argumentValue' will not be inspected.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] request_cookies: (Updatable) List of HTTP request cookie values (by cookie name) to exclude from inspecting. Example: If we have cookie 'cookieName=cookieValue' and requestCookies=['cookieName'], both 'cookieName' and 'cookieValue' will not be inspected.
        """
        AppFirewallPolicyResponseProtectionRuleProtectionCapabilityExclusionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            args=args,
            request_cookies=request_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             request_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if args is not None:
            _setter("args", args)
        if request_cookies is not None:
            _setter("request_cookies", request_cookies)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) List of URL query parameter values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from inspecting. Example: If we have query parameter 'argumentName=argumentValue' and args=['argumentName'], both 'argumentName' and 'argumentValue' will not be inspected.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter(name="requestCookies")
    def request_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) List of HTTP request cookie values (by cookie name) to exclude from inspecting. Example: If we have cookie 'cookieName=cookieValue' and requestCookies=['cookieName'], both 'cookieName' and 'cookieValue' will not be inspected.
        """
        return pulumi.get(self, "request_cookies")

    @request_cookies.setter
    def request_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "request_cookies", value)


@pulumi.input_type
class AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs:
    def __init__(__self__, *,
                 allowed_http_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_http_request_header_length: Optional[pulumi.Input[int]] = None,
                 max_http_request_headers: Optional[pulumi.Input[int]] = None,
                 max_number_of_arguments: Optional[pulumi.Input[int]] = None,
                 max_single_argument_length: Optional[pulumi.Input[int]] = None,
                 max_total_argument_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_http_methods: (Updatable) List of allowed HTTP methods. Each value as a RFC7230 formated token string. Used in protection capability 911100: Restrict HTTP Request Methods.
        :param pulumi.Input[int] max_http_request_header_length: (Updatable) Maximum allowed length of headers in an HTTP request. Used in protection capability: 9200024: Limit length of request header size.
        :param pulumi.Input[int] max_http_request_headers: (Updatable) Maximum number of headers allowed in an HTTP request. Used in protection capability 9200014: Limit Number of Request Headers.
        :param pulumi.Input[int] max_number_of_arguments: (Updatable) Maximum number of arguments allowed. Used in protection capability 920380: Number of Arguments Limits.
        :param pulumi.Input[int] max_single_argument_length: (Updatable) Maximum allowed length of a single argument. Used in protection capability 920370: Limit argument value length.
        :param pulumi.Input[int] max_total_argument_length: (Updatable) Maximum allowed total length of all arguments. Used in protection capability 920390: Limit arguments total length.
        """
        AppFirewallPolicyResponseProtectionRuleProtectionCapabilitySettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_http_methods=allowed_http_methods,
            max_http_request_header_length=max_http_request_header_length,
            max_http_request_headers=max_http_request_headers,
            max_number_of_arguments=max_number_of_arguments,
            max_single_argument_length=max_single_argument_length,
            max_total_argument_length=max_total_argument_length,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_http_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             max_http_request_header_length: Optional[pulumi.Input[int]] = None,
             max_http_request_headers: Optional[pulumi.Input[int]] = None,
             max_number_of_arguments: Optional[pulumi.Input[int]] = None,
             max_single_argument_length: Optional[pulumi.Input[int]] = None,
             max_total_argument_length: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allowed_http_methods is not None:
            _setter("allowed_http_methods", allowed_http_methods)
        if max_http_request_header_length is not None:
            _setter("max_http_request_header_length", max_http_request_header_length)
        if max_http_request_headers is not None:
            _setter("max_http_request_headers", max_http_request_headers)
        if max_number_of_arguments is not None:
            _setter("max_number_of_arguments", max_number_of_arguments)
        if max_single_argument_length is not None:
            _setter("max_single_argument_length", max_single_argument_length)
        if max_total_argument_length is not None:
            _setter("max_total_argument_length", max_total_argument_length)

    @property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) List of allowed HTTP methods. Each value as a RFC7230 formated token string. Used in protection capability 911100: Restrict HTTP Request Methods.
        """
        return pulumi.get(self, "allowed_http_methods")

    @allowed_http_methods.setter
    def allowed_http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_http_methods", value)

    @property
    @pulumi.getter(name="maxHttpRequestHeaderLength")
    def max_http_request_header_length(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum allowed length of headers in an HTTP request. Used in protection capability: 9200024: Limit length of request header size.
        """
        return pulumi.get(self, "max_http_request_header_length")

    @max_http_request_header_length.setter
    def max_http_request_header_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_http_request_header_length", value)

    @property
    @pulumi.getter(name="maxHttpRequestHeaders")
    def max_http_request_headers(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum number of headers allowed in an HTTP request. Used in protection capability 9200014: Limit Number of Request Headers.
        """
        return pulumi.get(self, "max_http_request_headers")

    @max_http_request_headers.setter
    def max_http_request_headers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_http_request_headers", value)

    @property
    @pulumi.getter(name="maxNumberOfArguments")
    def max_number_of_arguments(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum number of arguments allowed. Used in protection capability 920380: Number of Arguments Limits.
        """
        return pulumi.get(self, "max_number_of_arguments")

    @max_number_of_arguments.setter
    def max_number_of_arguments(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_number_of_arguments", value)

    @property
    @pulumi.getter(name="maxSingleArgumentLength")
    def max_single_argument_length(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum allowed length of a single argument. Used in protection capability 920370: Limit argument value length.
        """
        return pulumi.get(self, "max_single_argument_length")

    @max_single_argument_length.setter
    def max_single_argument_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_single_argument_length", value)

    @property
    @pulumi.getter(name="maxTotalArgumentLength")
    def max_total_argument_length(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum allowed total length of all arguments. Used in protection capability 920390: Limit arguments total length.
        """
        return pulumi.get(self, "max_total_argument_length")

    @max_total_argument_length.setter
    def max_total_argument_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_total_argument_length", value)


@pulumi.input_type
class NetworkAddressListVcnAddressArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[str]] = None,
                 vcn_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] addresses: (Updatable) A private IP address or CIDR IP address range.
        :param pulumi.Input[str] vcn_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VCN.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        NetworkAddressListVcnAddressArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            addresses=addresses,
            vcn_id=vcn_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             addresses: Optional[pulumi.Input[str]] = None,
             vcn_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if addresses is not None:
            _setter("addresses", addresses)
        if vcn_id is not None:
            _setter("vcn_id", vcn_id)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A private IP address or CIDR IP address range.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter(name="vcnId")
    def vcn_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VCN.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vcn_id")

    @vcn_id.setter
    def vcn_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcn_id", value)


@pulumi.input_type
class GetFirewallsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetFirewallsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNetworkAddressListsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetNetworkAddressListsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetProtectionCapabilitiesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetProtectionCapabilitiesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetProtectionCapabilityGroupTagsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name given.
        """
        GetProtectionCapabilityGroupTagsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetWebAppFirewallPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Rule name. Must be unique within the module.
        """
        GetWebAppFirewallPoliciesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Rule name. Must be unique within the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


